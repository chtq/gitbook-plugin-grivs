1. 一系统若当前处于全状态则，此系统将不会发生死锁。 A. 对 B. 错 2.
在分时系统中，时间片越小，一个作业的总运行时间越短。 A. 对 B. 错 3.
预防死锁可通过屏弃“互斥条件”实现。 A. 对 B. 错 4.
进程被创建后处于就绪状态。 A. 对 B. 错 5.
作业A处于运行状态，但作业A的进程B可能处于阻塞状态。 A. 对 B. 错 6.
启动外设的工作必须在管态下由操作系统完成。 A. 对 B. 错 7.
当进行地址变换时，必需进行地址重定位。 A. 对 B. 错 8.
并发指的是在操作系统本身存在着许多同时的或并行的活动。 A. 对 B. 错 9.
打开文件操作的目的是建立用户和文件的联系。 A. 对 B. 错 10.
中断系统是由硬件和软件配合完成的。 A. 对 B. 错 11.
作业处于运行状态时，其程序一定在处理机上执行。 A. 对 B. 错 12.
在消息缓冲通信中，消息队列属于临界资源。 A. 对 B. 错 13.
作业A处于运行状态，作业A的进程一定处于执行状态。 A. 对 B. 错 14.
利用Spooling技术可将一台独占设备虚拟为几台“虚拟”设备。 A. 对 B. 错 15.
如果死锁的四个必要条件同时成立，则系统一定产生死锁。 A. 对 B. 错 16.
多道程序的引入是为了提高CPU的利用率。 A. 对 B. 错 17.
访管中断是由于程序执行特权指令引起的。 A. 对 B. 错 18.
当发生缺页中断时必须从内存中淘汰一页。 A. 对 B. 错 19.
信号量的值不一定表示某类可用资源的数量。 A. 对 B. 错 20.
I/O操作是CPU执行通道程序完成的。 A. 对 B. 错 21.
在UNIX系统中所有进程都可在核心态和用户态两种状态下运行。 A. 对 B. 错 22.
多用户实时操作系统一定采用剥夺调度方式。 A. 对 B. 错 23.
进程发出I/O请求后将被阻塞，直至I/O操作完成。 A. 对 B. 错 24.
动态分页管理中，对任一种页面置换算法，分配给一个进程的页帧数越多，发生缺页的次数越少。
A. 对 B. 错 25. 早期批量处理解决了手工操作阶段的操作联机问题。 A. 对 B.
错 26. 交互性是批处理系统的一个特征。 A. 对 B. 错 27.
所谓并行是指两个或两个以上的事件在同一时刻发生。 A. 对 B. 错 28.
处理机从目态转变为管态是通过置程序状态字来实现的。 A. 对 B. 错 29.
进程就是作业。 A. 对 B. 错 30. 原语仅可在管态下执行。 A. 对 B. 错 31.
在请求式分页系统中，缺页的中断率与程序结构无关。 A. 对 B. 错 32.
最短CPU执行期优先算法一定是剥夺式的。 A. 对 B. 错 33.
在采用动态重定位的系统中已装入内存的作业，在其执行的过程中无需再进行地址转换工作。
A. 对 B. 错 34. 用户在编程时直接使用物理地址的存储分配方式为静态方式。
A. 对 B. 错 35. 使用全局置换算法，程序不可控制自身的缺页中断率。 A. 对 B.
错 36. 处于死锁的系统中，没有进程可再运行。 A. 对 B. 错 37.
顺序存取方法就是严格按照物理记录排列的顺序依次存取。 A. 对 B. 错 38.
文件的物理结构仅与文件的存取方法相关。 A. 对 B. 错 39.
不安全状态是死锁状态。 A. 对 B. 错 40.
脱机批处理解决了手工操作阶段的操作联机和输入/输出联机的问题。 A. 对 B.
错 41. 过载保护是分时系统的一个特征。 A. 对 B. 错 42.
所谓并发是指两个或两个以上的事件在同一时刻发生。 A. 对 B. 错 43.
操作系统的不确定性是指同一程序使用相同的输入、在相同的环境下，经过多次运行却可能获得完全不同的结果。
A. 对 B. 错 44. 处理机从管态转变为目态是通过置程序状态字来实现的。 A. 对
B. 错 45. 广义指令必须在管态下执行。 A. 对 B. 错 46.
原语可在目态下执行。 A. 对 B. 错 47. 多级反馈队列属于非剥夺式调度。 A.
对 B. 错 48. 最短ＣＰＵ执行期优先算法一定是剥夺式的。 A. 对 B. 错 49.
在采用动态重定位的系统中已装入内存的作业，在其执行的过程中无需在进行地址转换工作。
A. 对 B. 错 50. 一个作业的缺页中断率与置换算法无关。 A. 对 B. 错 51.
串联文件仅支持顺序访问。 A. 对 B. 错 52.
一系统处于死锁状态则一定是不安全状态。 A. 对 B. 错 53.
在采用顾客/服务员模型的系统中，服务员必须在管态下运行。 A. 对 B. 错 54.
一系统处于不安全状态则此时一定是死锁状态。 A. 对 B. 错 55.
在分时系统中采用的进程调度算法应该是进程优先数调度算法。 A. 对 B. 错 56.
所谓临界资源，指的是可以为多个进程同时使用的资源。 A. 对 B. 错 57.
设备独立性是指设备由用户独占使用。 A. 对 B. 错 58.
文件共享是指某一个或某一部分文件可以让事先规定的某些用户共同使用。 A. 对
B. 错 59.
当一个进程从等待态变成就绪态，则一定有一个进程从就绪态变成运行态。 A. 对
B. 错 60. 在请求页式存储管理中，页面淘汰所花费的时间不属于系统开销。 A.
对 B. 错 61. 执行系统调用时可以中断。 A. 对 B. 错 62.
在作业调用时，采用最高响应比优先的作业调度算法可以得到最短的作业平均周转时间。
A. 对 B. 错 63. 分时操作系统必然建立在多道程序技术的基础之上。 A. 对 B.
错 64. 死锁危害很大，操作系统要绝对防止死锁的发生。 A. 对 B. 错 65.
请求调页的动态分页系统要求CPU的缺页中断支持。 A. 对 B. 错 66.
多道程序技术可将一台物理CPU虚拟为多台逻辑CPU。 A. 对 B. 错 67.
在分时系统中，时间片越小，一个作业的总运行时间越短。 A. 对 B. 错 68.
当进程提出资源请求得不到满足时，系统必定发生死锁。 A. 对 B. 错 69.
原语只能在管态下执行。 A. 对 B. 错 70.
在UNIX系统中，所有进程都是利用系统调用fork创建的。 A. 对 B. 错 71.
对于采用动态重定位的系统中已装入内存的作业，在其执行的过程中无需再进行地址转换工作。
A. 对 B. 错 72.
使用交换技术可使总存储空间需求大于实际存储空间的多个程序投入运行，所以说交换实现了虚拟存储器。
A. 对 B. 错 73. 在请求分页系统中，如发现某页修改后，则该页不换出。 A. 对
B. 错 74. 使用全局页面置换算法，程序不可控制自身的缺页中断率。 A. 对 B.
错 75. 并行是并发的不同表述,其原理相同。 A. 对 B. 错 76.
进程处于就绪状态，是指它正等待着某个事件的发生，这时，即使给它CPU控制权，它也无法执行。
A. 对 B. 错 77.
所谓请调策略指的是，在分页系统中，当发现用户程序所访问的页面不在主存时，由系统负责从辅存调入请求的页面。
A. 对 B. 错 78.
所谓最久未使用（LRU）页面淘汰算法是指将驻留在主存中时间最长的页面淘汰。 A.
对 B. 错 79. 文件系统中不同目录下的文件名不能相同。 A. 对 B. 错 80.
多道程序的引入主要是为了提高资源利用率。 A. 对 B. 错 81.
交互性是批处理系统的一个特征。 A. 对 B. 错 82.
广义指令必须在管态下执行。 A. 对 B. 错 83.
一系统处于不安全状态，则一定是死锁状态。 A. 对 B. 错 84.
在任何系统中地址重定位都是必须进行的。 A. 对 B. 错 85.
在请求页式管理中，当出现缺页中断时，应淘汰一页。 A. 对 B. 错 86.
使用覆盖技术可使总存储空间需求大于实际存储空间的多个程序投入运行，所以说覆盖技术实现了虚存。
A. 对 B. 错 87. 可用磁盘存储器虚拟I/O设备。 A. 对 B. 错 88.
串联文件仅支持顺序访问。 A. 对 B. 错 89.
信号量的值永远代表着某类可用资源的数量 A. 对 B. 错 90.
下列哪一条是在操作系统设计中引入多道程序技术的好处？ A.
使并发执行成为可能 B. 简化操作系统的实现 C. 减少对内存容量的需求 D.
便于实施存储保护 91. Windows 属于下列哪一类操作系统？ A. 单用户单任务 B.
单用户多任务 C. 多用户 D. 批处理 92. 发出I/O请求会导致哪种进程状态演变？
A. 就绪 → 执行 B. 执行 → 就绪 C. 阻塞 → 执行 D. 执行 → 阻塞 93.
“临界区”是指： A. 一组临界资源的集合 B. 可共享的一块内存区 C.
访问临界资源的一段代码 D. 请求访问临界资源的代码 94.
使用一个信号量协调5个进程对3个同类临界资源的访问，下列哪个信号量值不应该出现？
A. 3 B. 0 C. –1 D. –3 95. 操作系统中的高级调度是指： A. 作业调度 B.
进程调度 C. 进程交换调度 D. 线程调度 96.
要求进程一次性申请所需的全部资源，是破坏了死锁必要条件中的哪一条？ A. 互斥
B. 请求与保持 C. 不剥夺 D. 循环等待 97.
使用“银行家算法”决定是否给进程分配资源，这种策略属于： A. 预防死锁 B.
避免死锁 C. 检测死锁 D. 解除死锁 98.
可变分区存储管理中用链表记录分区使用情况，为应用最差适应法(WF)分配空闲分区，链表中应该按照下列哪种方法排列？
A. 按分区起始地址递增排列 B. 按分区起始地址递减排列 C.
按分区大小递增排列 D. 按分区大小递减排列 99. 哪种设备属于字符设备？ A.
磁盘 B. 磁带 C. 光盘 D. 键盘 100.
关于段页式存储管理系统中的页表数，下面哪种说法比较准确？ A. 整个系统有一个
B. 整个系统有多个 C. 每个进程有一个 D. 每个进程有多个 101.
在BFD和SFD分开的系统中，SFD中应记录下列哪类信息？ A. 文件名 B. 文件长度 C.
存取权限 D. 物理存储位置 102. MS-DOS系统中的磁盘文件物理结构属于： A.
连续文件 B. 链接文件 C. 索引文件 D. 散列文件 103.
作业经过下面哪一个过程进入“后备”状态？ A. 作业创建 B. 作业调度 C.
进程调度 D. 作业终止 104. 基于用户（主体）记录存取权限的方法属于： A.
存取控制表 B. 用户目录表 C. 存取控制矩阵 D. 权能表 105.
下列哪一条不是批处理系统的优点？ A. 吞吐量大 B. 资源利用率高 C.
系统开销小 D. 响应及时 106. I/O请求完成会导致哪种进程状态演变？ A. 就绪 →
执行 B. 阻塞 → 就绪 C. 阻塞 → 执行 D. 执行 → 阻塞 107. “临界资源”是指：
A. 正在被占用的资源 B. 不可共享的资源 C. 一次只能被一个进程使用的资源 D.
可同时使用的资源 108.
使用一个信号量协调6个进程对2个同类临界资源的访问，下列哪个信号量值不应该出现？
A. 3 B. 0 C. –1 D. –3 109.
进程向一个中间实体发送消息，等待另一进程异步地接收，这种通信方式属于： A.
共享存储区 B. 消息缓冲 C. 信箱方式 D. 共享文件 110.
对资源编号，要求进程按照序号顺序申请资源，是破坏了死锁必要条件中的哪一条？
A. 互斥 B. 请求与保持 C. 不剥夺 D. 循环等待 111.
通过破坏死锁必要条件之一来防止死锁产生，这种策略属于： A. 预防死锁 B.
避免死锁 C. 检测死锁 D. 解除死锁 112.
可变分区存储管理中用链表记录分区使用情况，为应用最先适应法(FF)分配空闲分区，链表中应该按照下列哪种方法排列？
A. 按分区起始地址递增排列 B. 按分区起始地址递减排列 C.
按分区大小递增排列 D. 按分区大小递减排列 113. 哪种设备属于块设备？ A.
键盘 B. 磁盘 C. 显示器 D. 打印机 114.
分页存储管理系统中引入“快表”，是为了： A. 保存最近访问的数据 B.
保存最近用过的页表项 C. 保存最近用过的物理地址 D. 保存最近用过的虚拟地址
115. MS-DOS系统中的命令文件使用哪种后缀名？ A. EXE B. COM C. BAT D. SYS
116. UNIX系统中的磁盘文件物理结构属于： A. 连续文件 B. 链接文件 C.
索引文件 D. 散列文件 117. 如何从用户方式（用户态）转入特权方式（核心态）？ A.
使用特权指令 B. 发生子程序调用 C. 使用共享代码 D. 进行系统调用 118.
进入输入井的作业其状态处于 A. 提交状态 B. 完成状态 C. 执行状态 D.
后备状态 119. 作业由后备状态转变为执行状态是通过以下那个调度程序实现的
A. 作业调度 B. 进程调度 C. 中级调度 D. 驱臂调度 120.
以下那个不是程序顺序执行的特性 A. 封闭性 B. 顺序性 C. 无关性 D.
不可再现性 121. 以下那种调度算法不可能是剥夺式的 A. 先来先服务 B.
最短ＣＰＵ执行期优先 C. 最高优先权 D. 轮转法 122. 目标程序存在于 A. 名空间
B. 逻辑地址空间 C. 储存空间 D. 物理地址空间 123. 以下那个叙述不正确 A.
使用动态重定位的系统用户的作业可不要求分配连续的存储空间 B.
使用动态重定位的系统作业可在内存中移动 C.
使用动态重定位的系统有可能为用户提供一个比内存大的多的地址空间 D.
使用动态重定位的系统有可能为用户提供一个比内存大的多的存储空间 124.
以下那种存储管理必须使用动态重定位 A. 固定分区存储管理 B.
单一连续区存储管理 C. 可变分区存储管理 D. 段式存储管理 125.
通常以下哪种分区分配算法产生的外零头最小 A. 首次适应 B. 最佳适应 C.
最坏适应 D. 下次适应 126. 以下那种类型的文件不支持直接存取 A. 连续文件
B. Hash文件 C. 索引文件 D. 串联文件 127. XNEIX文件存取控制的方法为 A.
存取控制矩阵 B. 存取控制表 C. 用户权限表 D. 口令 128.
当某个作业被作业调度程序选中，进入内存开始运行时，作业的状态为 A. 提交状态
B. 完成状态 C. 执行状态 D. 后备状态 129.
进程由就绪状态转变为执行状态是通过以下那个调度程序实现的 A. 作业调度 B.
进程调度 C. 中级调度 D. 驱臂调度 130. 以下那个不是程序并发执行的特性： A.
与速度无关性 B. 不可再现性 C. 相互制约性 D. 通信性 131. 以下那个叙述正确
A. 使用静态重定位的系统用户的作业可不要求分配连续的存储空间 B.
使用静态重定位的系统作业可在内存中移动 C.
使用静态重定位的系统有可能为用户提供一个比内存大的多的地址空间 D.
使用静态重定位的系统无需增加硬件地址变换机构 132.
以下那种存储管理不可用于多道程序系统中 A. 固定分区存储管理 B.
单一连续区存储管理 C. 可变分区存储管理 D. 段式存储管理 133.
以下那种存储管理可使用静态重定位 A. 固定分区存储管理 B. 页式存储管理 C.
可重定位分区存储管理 D. 段式存储管理 134.
以下那个关于纯分页存储管理的叙述不正确 A. 此种存储管理会产生内零头 B.
此种存储管理要求作业一次全部调入内存 C. 此种存储管理会产生外零头 D.
此种存储管理不要求作业分配连续的存储区 135.
在移臂调度时读写头从盘的一端开始朝另一端移动，在移动的过程中搜索每个磁道上的请求，若有则服务之，直至到达盘的另一端。在另一端，磁头移动的方向是相反的，并继续
在移动中扫描服务，则此种算法称为 A. 先来先服务 B. 最短查找时间优先 C.
SCAN D. C-SCAN 136. 死锁定理用于 A. 预防死锁 B. 解除死锁 C. 避免死锁 D.
检测死锁 137.
当某个作业被作业调度程序选中，进入内存开始运行时，作业的状态为 A. 提交状态
B. 完成状态 C. 执行状态 D. 后备状态 138.
进程由就绪状态转变为执行状态是通过以下那个调度程序实现的 A. 作业调度 B.
进程调度 C. 中级调度 D. 驱臂调度 139. 以下那个不是程序并发执行的特性： A.
与速度无关性 B. 不可再现性 C. 相互制约性 D. 通信性 140. 以下那个叙述正确
A. 使用静态重定位的系统用户的作业可不要求分配连续的存储空间 B.
使用静态重定位的系统作业可在内存中移动 C.
使用静态重定位的系统有可能为用户提供一个比内存大的多的地址空间 D.
使用静态重定位的系统无需增加硬件地址变换机构 141.
以下那种存储管理不可用于多道程序系统中 A. 固定分区存储管理 B.
单一连续区存储管理 C. 可变分区存储管理 D. 段式存储管理 142.
以下那种存储管理可使用静态重定位 A. 固定分区存储管理 B. 页式存储管理 C.
可重定位分区存储管理 D. 段式存储管理 143. 以下那种存储管理会产生内零头
A. 固定分区存储管理 B. 可变分区存储管理 C. 可重定位分区存储管理 D.
段式存储管理 144. 以下那个关于纯分页存储管理的叙述不正确 A.
此种存储管理会产生内零头 B. 此种存储管理要求作业一次全部调入内存 C.
此种存储管理会产生外零头 D. 此种存储管理不要求作业分配连续的存储区 145.
在移臂调度时读写头从盘的一端开始朝另一端移动，在移动的过程中搜索每个磁道上的请求，若有则服务之，直至到达盘的另一端。在另一端，磁头移动的方向是相反的，并继续
在移动中扫描服务，则此种算法称为 A. 先来先服务 B. 最短查找时间优先 C.
SCAN D. C-SCAN 146. 死锁定理用于 A. 预防死锁 B. 解除死锁 C. 避免死锁 D.
检测死锁 147. 作业由后备状态转变为执行状态是通过以下那个调度程序实现的
A. 作业调度 B. 进程调度 C. 中级调度 D. 驱臂调度 148.
以下那个不是程序顺序执行的特性 A. 封闭性 B. 顺序性 C. 无关性 D.
不可再现性 149. 以下那种调度算法不可能是剥夺式的 A. 先来先服务 B.
最短ＣＰＵ执行期优先 C. 最高优先权 D. 轮转法 150. 目标程序存在于 A. 名空间
B. 逻辑地址空间 C. 储存空间 D. 物理地址空间 151. 以下那个叙述不正确 A.
使用动态重定位的系统用户的作业可不要求分配连续的存储空间 B.
使用动态重定位的系统作业可在内存中移动 C.
使用动态重定位的系统有可能为用户提供一个比内存大的多的地址空间 D.
使用动态重定位的系统有可能为用户提供一个比内存大的多的存储空间 152.
以下那种存储管理必须使用动态重定位 A. 固定分区存储管理 B.
单一连续区存储管理 C. 可变分区存储管理 D. 段式存储管理 153.
通常以下那种分区分配算法产生的外零头最小 A. 首次适应 B. 最佳适应 C.
最坏适应 D. 下次适应 154. 以下那种类型的文件不支持直接存取 A. 连续文件
B. Hash文件 C. 索引文件 D. 串联文件 155. XNEIX文件存取控制的方法为 A.
存取控制矩阵 B. 存取控制表 C. 用户权限表 D. 口令 156.
在可变分区存储管理中,可能存在 A. 内零头 B. 外零头 C. A,B均可能 D.
A,B均不可能 157. 能及时处理由过程控制反馈的数据并作出响应的操作系统是 A.
分时系统 B. 网络系统 C. 实时系统 D. 批处理系统 158.
在设备分配中，独占分配方式的主要缺点是\_\_\_\_\_ 。 A. 设备利用率低 B.
设备利用率高 C. 管理复杂 D. 可使设备并行工作 159.
在UNIX系统中，用来实现进程换入换的是 A. 0进程 B. 1进程 C. kill系统调用 D.
作业调度进程 160. 在段页式存储管理系统中，当访问主存中的一条指令或数据时
A. 需访问两次主存 B. 需访问一次主存 C. 至少访问三次主存 D.
至少访问两次主存 161. 在页式存储管理方案中，进行主存分配的单位是 A. 段 B.
块 C. 作业 D. 不一定 162.
在请求分页存储管理的页面置换策略中，会产生贝莱迪异态的算法是 A. FIFO B.
最佳置换 C. LRU D. 最坏适应 163. 动态重定位是在进行\_\_\_\_\_ 的重定位。
A. 作业执行前 B. 作业执行过程中 C. 作业装入过程中 D. A，B，C均不对 164.
可以破坏环路等待条件的策略是 A. 资源抢占 B. 独享分配 C. 按序分配 D.
共享分配 165. 可解决文件重名问题的最简单的目录结构是 A. 单级目录 B.
树型结构目录 C. 二级目录 D. 便于共享的目录 166.
在段页式存储管理系统中,当访问主存中的一条指令或数据时\_\_\_\_\_ 。 A.
需访问两次主存 B. 需访问一次主存 C. 至少访问三次主存 D. 至少访问两次主存
167. Hash文件采用的寻址方法是\_\_\_\_\_ 。 A. 计算 B. 比较 C. 索引 D.
顺序 168. UNIX系统是一个\_\_\_\_\_ 操作系统。 A. 单用户 B. 单用户多任务
C. 多用户多任务 D. 多用户单任务 169.
可以实现虚拟存储器的方案是\_\_\_\_\_ 。 A. 固定分区方式 B. 可变分区方式
C. 纯分页方式 D. 请求页式 170. 在UNIX系统中使用的目录结构是\_\_\_\_\_ 。
A. 单级 B. 二级 C. 树型 D. 三级 171.
在操作系统中用户进程本身启动的唯一状态转换是\_\_\_\_\_ 。 A. 调度 B.
阻塞 C. 时间片到 D. 唤醒 172. 程序访问的局部性原理决定应使用\_\_\_\_\_
。 A. 中断 B. DMA C. 高速缓存 D. 虚拟存储器 173.
文件系统中文件存储空间的分配是以\_\_\_\_\_ 为单位进行的。 A. 字 B. 字节
C. 文件 D. 块 174. 在消息缓冲通信方式中通信的基本方式是\_\_\_\_\_ 。 A.
文件 B. 消息 C. 记录 D. 字段 175. 可以使用银行家算法\_\_\_\_\_ 死锁。 A.
预防 B. 检测 C. 解除 D. 避免 176.
一般在哪种情况下发生从用户态到核心态的转换？ A. 使用特权指令 B.
发生子程序调用 C. 使用共享代码 D. 进行系统调用 177.
在消息缓冲队列中，消息队列属于\_\_\_\_\_ 资源。 A. 临界 B. 共享 C. 永久
D. 可剥夺 178.
把资源按类型排序编号，并要求进程严格按序申请资源，这种方法摒弃了下述哪一个条件？
A. 互斥条件 B. 部分分配条件 C. 不剥夺条件 D. 环路等待条件 179.
可变式分区管理中存在一些小而无用的分区，称做\_\_\_\_\_ 。 A. 外零头 B.
内零头 C. 页表零头 D. 页内零头 180. 临界区是\_\_\_\_\_ 。 A. 一个进程 B.
一种资源 C. 一段程序 D. 存储区 181.
在分时系统中，当用户数一定时，影响响应时间的主要因素是\_\_\_\_\_ 。 A.
时间片 B. 调度算法 C. 存储分配方式 D. 作业的大小 182.
在段页式存储管理系统中，当访问主存中的一条指令或数据时，\_\_\_\_\_ 。 A.
需访问一次主存 B. 需访问两次主存 C. 至少访问两次主存 D. 至少访问三次主存
183. 在操作系统中，进行资源分配、调度和管理的最小独立单位是\_\_\_\_\_ 。
A. 作业 B. 程序 C. 进程 D. 用户 184. 当发生缺页中断时，\_\_\_\_\_ 。 A.
应淘汰一页 B. 应淘汰多页 C. 应装入一页 D. 将淘汰页写盘 185.
操作系统中的工作集模型与\_\_\_\_\_ 有关。 A. 合并存储区中的空白块 B.
将CPU分配给进程 C. 一个进程访问的页面集合 D. 为进程分配I/O资源 186.
Windows NT属于哪一类操作系统？ A. 单用户单任务 B. 单用户多任务 C.
单道批处理 D. 多用户 187.
在一个可变分区存储管理中，最佳适应算法是将空闲区表中的空闲区按\_\_\_\_\_
的次序排列。 A. 地址递增 B. 地址递减 C. 大小递增 D. 大小递减 188.
成组链法是用于\_\_\_\_\_ 。 A. 文件的逻辑组织 B. 文件的物理组织 C.
文件存储器空闲空间的组织 D. 文件的目录组织 189.
在BFD和SFD分开的目录组织中，哪些信息应放在SFD中？ A. 文件的符号名 B.
文件长度 C. 文件的存取权限 D. 文件的物理入口地址 190.
使用“连访＂方式共享文件是指\_\_\_\_\_ 。 A.
不同目录表目指向同一物理入口地址 B. 一个表目指向另一个目录表目 C.
不同的SFD表目指向同一BFD表目 D. 通过工作目录转换为用户文件固有名进行访问
191. 在UNIX系统中，对换空间的管理采用得是\_\_\_\_\_ 适应算法。 A. 首次 B.
最佳 C. 最坏 D. 下次 192. UNIX系统把设备分为\_\_\_\_\_ 。 A.
输入设备和输出设备 B. 字符设备和块设备 C. 系统设备和用户设备 D.
共享设备和虚拟设备 193. 银行家算法用于\_\_\_\_\_ 。 A. 预防死锁 B.
解除死锁 C. 避免死锁 D. 检测死锁 194.
以下哪种调度算法不可能是剥夺方式的？ A. 先来先服务 B. 最短CPU执行期优先
C. 最高优先权 D. 轮转法 195. Windows NT 属于哪一类操作系统？ A.
单用户任务 B. 单用户多任务 C. 多用户 D. 单道批处理 196.
在操作系统中用户进程本身启动的唯一状态转换是： A. 调度 B. 阻塞 C.
时间片到 D. 唤醒 197. “拼接”技术是用来解决： A. 内零头 B. 外零头 C.
页内零头 D. 页表零头 198.
把内存中空白分区按大小递减链接，可使用哪种分配算法？ A. 最佳适应算法 B.
最坏适应算法 C. 首次适应算法 D. 下次适应算法 199.
在UNIX系统中采用什么方法对空白磁盘块进行组织？ A. 位示图 B. 空白文件目录
C. 链接法 D. 成组链法 200. 在设备分配中，什么时刻的设备状态为等待状态？ A.
设备本身忙 B. 与设备连接的所有控制器和通道都忙 C. 设备出故障 D.
部分通道和控制器忙 201.
流式文件内部没有记录的概念，可将其看作是\_\_\_\_\_ 的有序集合。 A. 数组
B. 记录 C. 字符串 D. 页面 202.
在采用位示图管理文件存储空间时，二进制串的一位对应一个\_\_\_\_\_ 。 A.
物理文件 B. 逻辑文件 C. 物理块 D. 缓冲区 203.
对简单分页系统，作业的信息需要在作业运行前\_\_\_\_\_ 。 A.
必须全部装入内存 B. 可以部分装入内存 C. 不必装入内存 D. 需要时再装 204.
设备从磁盘驱动器中读出一块数据的总时间为\_\_\_\_\_ 。 A. 等待时间 +
传输时间 B. 传输时间 C. 查找时间 + 传输时间 D. 延迟时间 + 查找时间 +
传输时间 205. 以下哪个不是程序顺序执行的特性？ A. 封闭性 B. 顺序性 C.
无关性 D. 不可再现性 206. 目标程序存在于\_\_\_\_\_ 。 A. 符号空间 B.
逻辑地址空间 C. 内存空间 D. 物理地址空间 207.
以下哪种存储管理不可用于多道程序系统中？ A. 固定式区存储管理 B.
单一连续区存储管理 C. 可变分区存储管理 D. 段式存储管理 208.
死锁定理用于\_\_\_\_\_ 。 A. 预防死锁 B. 解除死锁 C. 避免死锁 D.
检测死锁 209. 在BFD和SFD分开的系统中，哪些信息应放在SFD中？ A.
文件的符号名 B. 文件长度 C. 文件的存取权限 D. 文件的物理入口地址 210.
使用链接方式共享文件，是指： A. 不同目录表目指向同一物理入口地址 B.
不同的SFD表目指向同一BFD表目 C. 一个目录表目指向另一个目录表目 D.
通过“值班目录”连接为相同的完全限定名进行访问 211. 临界资源是指： A.
通过SPOOLING技术提供的虚拟设备资源 B. 只能被特定用户使用，不能共享的资源
C. 可同时被多个进程访问的可共享资源 D.
一次仅允许一个进程访问的可共享资源 212.
把资源按类型排序编号，并要求进程严格按虚申请资源，这种方法摒弃了下述哪一个条件？
A. 互斥条件 B. 不剥夺条件 C. 部分分配条件 D. 环路等待条件 213.
作业由后备状态转变为执行状态是通过以下哪个调度程序实现的： A. 作业调度 B.
进程调度 C. 中级调度 D. 驱动调度 214. 以下那种调度算法不可能是剥夺式的
A. 先来先服务 B. 最短CPU执行期优先 C. 最高优先权 D. 轮转法 215.
一个完整的计算机系统是由组成的。 A. 硬件 B. 软件 C. 硬件和软件 D.
用户程序 216. 操作系统的基本职能是。 A.
控制和管理系统内各种资源，有效地组织多道程序的运行 B.
提供用户界面，方便用户使用 C. 提供方便的可视化编辑程序 D.
提供功能强大的网络管理工具 217. 下列进程状态的转换中，哪一个是不正确的。
A. 就绪运行 B. 运行就绪 C. 就绪阻塞 D. 阻塞就绪 218.
某进程由于需要从磁盘上读入数据而处于阻塞状态。当系统完成了所需的读盘操作后，此时该进程的状态将\_\_\_\_\_
。 A. 从就绪变为运行 B. 从运行变为就绪 C. 从运行变为阻塞 D.
从阻塞变为就绪 219. 进程状态从就绪态到运行态的转化工作是由\_\_\_\_\_
完成的。 A. 作业调度 B. 中级调度 C. 进程调度 D. 设备调度 220.
把逻辑地址转变为内存的物理地址的过程称作\_\_\_\_\_ 。 A. 编译 B. 连接 C.
运行 D. 重定位 221.
在分页存储管理系统中，从页号到物理块号的地址映射是通过\_\_\_\_\_ 实现的。
A. 段表 B. 页表 C. PCB D. JCB 222. 在UNIX系统中，目录结构采用\_\_\_\_\_
。 A. 单级目录结构 B. 二级目录结构 C. 单纯树形目录结构 D.
带链接树形目录结构 223.
使用户所编制的程序与实际使用的物理设备无关，这是由设备管理的\_\_\_\_\_
功能实现的。 A. 设备独立性 B. 设备分配 C. 缓冲管理 D. 虚拟设备 224.
资源预先分配策略可以实现死锁的\_\_\_\_\_ 。 A. 预防 B. 避免 C. 检测 D.
恢复 225.
为了使系统中所有的用户都能得到及时的响应，该操作系统应该是\_\_\_\_\_ 。
A. 多道批处理系统 B. 分时系统 C. 实时系统 D. 网络系统 226.
SPOOLing技术可以实现设备的分配\_\_\_\_\_ 。 A. 独占 B. 共享 C. 虚拟 D.
物理 227. 以下存储管理技术中，支持虚拟存储器的技术是\_\_\_\_\_ 。 A.
动态分区法 B. 可重定位分区法 C. 请求分页技术 D. 对换技术 228.
在以下的文件物理存储组织形式中，\_\_\_\_\_ 常用于存放大型的系统文件。 A.
连续文件 B. 串连文件 C. 索引文件 D. 多重索引文件 229.
设备的打开、关闭、读、写等操作是由\_\_\_\_\_ 完成的。 A. 用户程序 B.
编译程序 C. 设备分配程序 D. 设备驱动程序 230.
在计算机系统中，控制和管理各种资源、有效地组织多道程序运行的系统软件称作\_\_\_\_\_
。 A. 文件系统 B. 操作系统 C. 网络管理系统 D. 数据库管理系统 231.
以下著名的操作系统中，属于多用户、分时系统的是\_\_\_\_\_ 。 A. DOS系统 B.
Windows NT系统 C. UNIX系统 D. OS/2系统 232.
多个进程的实体能存在于同一内存中，在一段时间内都得到运行。这种性质称作进程的\_\_\_\_\_
。 A. 动态性 B. 并发性 C. 调度性 D. 异步性 233.
进程控制块是描述进程状态和特性的数据结构，一个进程\_\_\_\_\_ 。 A.
可以有多个进程控制块 B. 可以和其他进程共用一个进程控制块 C.
可以没有进程控制块 D. 只能有惟一的进程控制块 234.
为了使系统中各部分资源得到均衡使用，就必须选择对资源需求不同的作业进行合理搭配。这项工作是由\_\_\_\_\_
完成的。 A. 作业调度 B. 中级调度 C. 进程调度 D. 内存调度 235.
通常，用户编写的程序中所使用的地址是\_\_\_\_\_ 。 A. 逻辑地址 B. 物理地址
C. 绝对地址 D. 内存地址 236.
当前目录是/usr/meng，其下属文件prog/file.c的绝对路径名是\_\_\_\_\_ 。 A.
/usr/meng/file.c B. /usr/file.c C. /prog/file.c D. /usr/meng/prog/file.c
237. 引入缓冲技术的主要目的是\_\_\_\_\_ 。 A. 改善用户编程环境 B.
提高CPU的处理速度 C. 提高CPU与设备之间的并行程度 D. 降低计算机的硬件成本
238. 计算机系统产生死锁的根本原因是\_\_\_\_\_ 。 A. 资源有限 B.
进程推进顺序不当 C. 系统中进程太多 D. A和B 239.
虚拟存储管理策略可以\_\_\_\_\_ 。 A. 扩大物理内存容量 B.
扩大物理外存容量 C. 扩大逻辑内存容量 D. 扩大逻辑外存容量 240.
请求分页存储管理中，若把页面尺寸增加一倍，在程序顺序执行时，则一般缺页中断次数会\_\_\_\_\_
。 A. 增加 B. 减少 C. 不变 D. 可能增加也可能减少 241.
避免死锁的一个著名的算法是\_\_\_\_\_ 。 A. 先入先出法 B. 银行家算法 C.
优先级算法 D. 资源按序分配法 242.
如果进程PA对信号量S执行P操作，则信号量S的值应\_\_\_\_\_ 。 A. 加1 B. 减1
C. 等于0 D. 小于0 243. 操作系统是一种( ) A. 系统软件 B. 系统硬件 C.
应用软件 D. 支援软件 244. MS—DOS的存贮管理采用了( ) A. 段式存贮管理 B.
段页式存贮管理 C. 单用户连续存贮管理 D. 固定式分区存贮管理 245.
用户程序在目态下使用特权指令将引起的中断是属于( ) A. 硬件故障中断 B.
程序中断 C. 外部中断 D. 访管中断 246. MS—DOS中用于软盘整盘复制的命令是(
) A. COMP B. DISKCOPY C. SYS D. BACKUP 247. 位示图方法可用于( ) A.
盘空间的管理 B. 盘的驱动调度 C. 文件目录的查找 D.
页式虚拟存贮管理中的页面调度 248. 下列算法中用于磁盘移臂调度的是( ) A.
时间片轮转法 B. LRU算法 C. 最短寻找时间优先算法 D. 优先级高者优先算法
249. 在以下存贮管理方案中，不适用于多道程序设计系统的是( ) A.
单用户连续分配 B. 固定式分区分配 C. 可变式分区分配 D. 页式存贮管理 250.
已知，作业的周转时间=作业完成时间－作业的到达时间。现有三个同时到达的作业J1，J2和J3，它们的执行时间分别是T1，T2和T3，且T1
A. T1＋T2＋T3 B. (T1＋T2＋T3) C. T1＋ T2＋ T3 D. T1＋ T2＋T3 251.
任何两个并发进程之间( ) A. 一定存在互斥关系 B. 一定存在同步关系 C.
一定彼此独立无关 D. 可能存在同步或互斥关系 252.
进程从运行状态进入就绪状态的原因可能是( ) A. 被选中占有处理机 B.
等待某一事件 C. 等待的事件已发生 D. 时间片用完 253.
用磁带作为文件存贮介质时，文件只能组织成( ) A. 顺序文件 B. 链接文件 C.
索引文件 D. 目录文件 254.
一作业8：00到达系统，估计运行时间为1小时，若10：00开始执行该作业，其响应比是(
) A. 2 B. 1 C. 3 D. 0.5 255. 多道程序设计是指( ) A.
在实时系统中并发运行多个程序 B. 在分布系统中同一时刻运行多个程序 C.
在一台处理机上同一时刻运行多个程序 D. 在一台处理机上并发运行多个程序
256. 文件系统采用多级目录结构后，对于不同用户的文件，其文件名( ) A.
应该相同 B. 应该不同 C. 可以相同，也可以不同 D. 受系统约束 257.
在可变式分区分配方案中，某一作业完成后，系统收回其主存空间，并与相邻空闲区合并，为此需修改空闲区表，造成空闲区数减1的情况是(
) A. 无上邻空闲区，也无下邻空闲区 B. 有上邻空闲区，但无下邻空闲区 C.
有下邻空闲区，但无上邻空闲区 D. 有上邻空闲区，也有下邻空闲区 258.
引入多道程序设计技术的主要目的在于\_\_\_\_\_ 。 A. 减少存储器碎片 B.
充分利用处理机，减少处理机空闲时间 C. 有利于代码共享 D. 充分利用外围设备
259. 所谓设备独立性是指，用户在编程时要给出\_\_\_\_\_ 。 A. 设备逻辑名 B.
设备物理名 C. 设备启动地址 D. 设备卡地址 260.
临界区是指并发进程中访问共享变量的\_\_\_\_\_ 段。 A. 管理信息 B.
信息存储 C. 数据 D. 程序 261.
对记录式文件，操作系统为用户存取文件信息的最小单位是\_\_\_\_\_ 。 A. 字符
B. 数据项 C. 记录 D. 文件 262. 进程和程序的一个最本质的区别是\_\_\_\_\_
。 A. 分时使用或独占使用计算机 B. 顺序或非顺序执行机器指令 C.
全部或部分拥有计算机系统资源 D. 动态或静态 263.
在分时系统中，当用户程序要在显示器上输出一行字符时，使用操作系统提供的\_\_\_\_\_
接口。 A. 作业控制语言 B. 系统调用 C. 原语 D. 键盘命令 264.
当出现\_\_\_\_\_ 情况时，系统可能产生死锁。 A. 进程释放资源 B.
一个进程进入死循环 C. 多个进程竞争，资源出现了循环等待 D.
多个进程竞争共享型设备 265.
现代操作系统中，文件系统都有效地解决了重名（即允许不同用户的文件可以具有相同的文件名）问题。系统是通过\_\_\_\_\_
来实现这一功能的。 A. 重名翻译机构 B. 建立索引表 C. 建立指针 D.
多级目录结构 266. 按照操作系统提供的服务进行分类，\_\_\_\_\_
是基本的操作系统。 A. 批处理操作系统、分时操作系统、网络操作系统 B.
批处理操作系统、分时操作系统、实时操作系统 C.
批处理操作系统、分时操作系统、分布式操作系统 D.
分时操作系统、网络操作系统、分布式操作系统 267. 在\_\_\_\_\_
操作系统的控制下，计算机能及时处理过程控制装置反馈的信息，并作出响应。 A.
网络 B. 分时 C. 实时 D. 批处理 268.
在计算机系统中，通常把财务管理程序看作是\_\_\_\_\_ A. 系统软件 B.
支援软件 C. 接口软件 D. 应用软件 269.
对计算机系统起着控制和管理作用的是\_\_\_\_\_ 。 A. 硬件 B. 操作系统 C.
编译系统 D. 应用程序 270.
进程在执行中状态会发生变化，不可能出现的状态变化情况是\_\_\_\_\_ 。 A.
运行变为就绪 B. 运行变为等待 C. 等待变为就绪 D. 等待变为运行 271.
若在一个单处理器的计算机系统中同时存在5个并发进程，则任何时刻允许占用处理器的进程数为\_\_\_\_\_
。 A. 至少1个 B. 最多1个 C. 至少5个 D. 最多5个 272.
实存的存储分配算法用来决定输入的程序和数据放到主存中的位置，采用“总是把程序装入主存中最大的空闲区域”的算法称为\_\_\_\_\_
。 A. 最优适应算法 B. 最坏适应算法 C. 最先适应算法 D. 循环最先适应算法
273. 虚拟存储系统中，完成地址转换工作的是\_\_\_\_\_ 。 A. 硬件 B.
地址转换程序 C. 装入程序和地址转换程序 D. 装入程序 274. 通过\_\_\_\_\_
表示磁盘上每一磁盘块的唯一地址。 A. 柱面号、扇区号 B. 磁头号、扇区号 C.
柱面号、磁头号 D. 柱面号、磁头号、扇区号 275.
UNIX中对可分配磁盘存储空间采用\_\_\_\_\_ 方法管理。 A. 位示图 B.
空闲块成组链 C. 空闲块单向链 D. 空闲块表 276. 属共享型设备的是\_\_\_\_\_
。 A. 打印机 B. 磁带机 C. 磁盘机 D. 输入机 277.
等待当前磁道上的某指定扇区旋转到磁头下所需的时间称为\_\_\_\_\_ 。 A.
寻找时间 B. 启动时间 C. 延迟时间 D. 传送时间 278.
作业调度选中一个作业并把它装入主存，就为该作业创建一个进程，这个进程的初始状态为\_\_\_\_\_
。 A. 收容状态 B. 就绪状态 C. 执行状态 D. 等待状态 279.
能使平均周转时间最小的作业调度算法是\_\_\_\_\_ 。 A.
计算时间短的作业优先算法 B. 响应比最高者优先算法 C. 优先数调度算法 D.
均衡调度算法 280.
引起一个进程从运行状态变为等待状态的原因可能是由于\_\_\_\_\_ 。 A.
有更高优先级的进程就绪 B. 某外围设备完成了指定的操作 C. 进程调用了P操作
D. 进程调用了V操作 281.
在实现进程通信时会导致调用Send原语的进程被设置成“等信箱”状态的原因是\_\_\_\_\_
。 A. 指定的信箱不存在 B. 调用时没有设置参数 C. 指定的信箱中无信件 D.
指定的信箱中存满了信件 282.
对资源采用按序分配的策略可以使产生死锁的\_\_\_\_\_ 条件不成立。 A.
互斥使用资源 B. 占有并等待资源 C. 不可抢夺资源 D. 循环等待资源 283.
在下列解决死锁的方法中，属于死锁预防策略的是\_\_\_\_\_ 。 A. 银行家算法
B. 资源有序分配法 C. 定时运行死锁检测程序法 D. 资源分配图化简法 284.
关于UNIX系统中设备的说明，正确的是\_\_\_\_\_ 。 A.
UNIX系统是按设备和内存间交换的物理单位对设备进行分类的，有流设备、字符设备和块设备
B. 常把块设备称为存储设备，把字符设备称为输入输出设备 C.
UNIX对每一个设备赋予一个编号，称为“绝对号”，驱动程序按绝对号控制设备 D.
UNIX为每一类设备赋予一个编号，称为“设备号”，驱动程序按设备号控制设备 285.
（ ）不是批处理多道程序的性质。 A. “多道作业并发工作” B. “未采用 spooling
技术” C. “作业成批输入” D. “作业调度可合理选择作业投入运行” 286.
网络操作系统和分布式操作系统的主要区别是（ ） A. 是否连接多台计算机 B.
各台计算机有没有主次之分 C. 计算机之间能否通信 D. 网上资源能否共享 287.
用户程序中的I／O操作实际是由（ ）完成。 A. 程序设计语言 B. 标准库程序 C.
编译系统 D. 操作系统 288. 采用多道程序设计后，可能（ ） A.
缩短对用户请求的响应时间 B. 降低了系统资源的利用率 C.
缩短了每道程序执行时间 D. 延长了每道程序执行时间 289.
操作系统中同时存在着多个进程，它们（ ） A. 不能共享系统资源 B.
不能调用同一段程序代码 C. 可以共享所有的系统资源 D.
可以共享允许共享的系统资源 290.
存储管理中地址重定位必须在CPU中设置专门寄存器，而（ ）不是此类寄存器。 A.
基址寄存器 B. 界限寄存器 C. 页表控制寄存器 D. 程序计数器 291.
在段式分配的存储管理中，最坏适应算法要求对空闲区表项按（ ）进行排列。 A.
尺寸从小到大 B. 尺寸从大到小 C. 地址从小到大 D. 地址从大到小 292.
段式存储管理中的地址格式是（ ）地址。 A. 线性 B. 一维 C. 二维 D. 三维 293.
记录的成组与分解操作不仅提高（ ）的利用率，而且可减少对存储设备的启动次数。
A. 主存空间 B. 存储介质 C. 处理器 D. 共享文件 294.
用户要求把一个新文件存放到存储介质上时，首先要使用（
）文件操作，目的是让系统做好存储文件前的准备工作。 A. 打开 B. 建立 C. 关闭
D. 删除 295.
磁盘上的每一个物理块要用三个参数来定位，首先要把移动臂移动并定位到不同盘面上具有相同编号的磁道位置，表示该位置的参数称（
）号。 A. 柱面 B. 盘面 C. 扇区 D. 磁头 296. 下列程序中（
）程序不是spool系统的组成部分。 A. 预输入 B. 缓输出 C. 通道 D. 井管理
297. 用户可以使用（ ）编写控制作业执行步骤的作业说明书。 A. 操作控制命令
B. 作业控制语言 C. 作业启动命令 D. 窗口或菜单 298.
计算时间短的作业优先的调度算法会使（ ） A. 每个作业等待时间较短 B.
平均周转时间最短 C. 系统效率最高 D. 长作业等待时间较短 299.
涉及某一资源造成与时间有关的错误的原因，正确的是（ ） A.
一个进程多次申请，释放该资源 B. 若干并发进程互斥使用该资源 C.
若干并发进程同时使用该资源 D. 以上说法均不对 300. PV操作是在（
）上的操作。 A. 临界区 B. 进程 C. 缓冲区 D. 信号量 301.
有关资源分配图中存在环路和死锁关系正确的说法是（ ） A.
图中无环路则系统可能存在死锁 B. 图中有环路则系统肯定存在死锁 C.
图中有环路则系统可能存在死锁，也可能不存在死锁 D. 以上说法都不对 302.
有关抢夺资源预防死锁说法中不正确的是（ ） A.
若进程P申请资源R被进程Q占用，当进程Q等待另一资源时，可抢夺资源R，否则进程P等待
B.
一个等待资源的进程只有得到新申请的资源和所有被抢夺的资源后才能继续运行
C. 打印机是可抢夺的资源 D. 主存空间是可抢夺的资源 303.
用VI产生的shell文件的性质是（ ） A. 可立即运行 B. 可用chown 使之能运行 C.
可用chgrp 使之能运行 D. 可用chmod 使之能运行 304.
关于Unix的用户接口处理的说明不正确的提法是（ ） A.
用户注册成功后，即处于shell控制下 B. shell 以交互方式为用户服务 C. shell
以某个提示符（如$）表示等待用户输入命令 D.
用户打入shell命令行后，当这个命令行执行完以后，才再次显示提示符，等待用户输入下一命令
305. 操作系统核心部分的主要特点是\_\_\_\_\_ 。 A. 一个程序模块 B.
主机不断电时常驻内存 C. 有头有尾的程序 D. 串行顺序执行 306.
操作系统中用得最多的数据结构是\_\_\_\_\_ 。 A. 堆栈 B. 队列 C. 表格 D.
树 307. 索引式(随机)文件组织的一个主要优点是\_\_\_\_\_ 。 A.
不需要链接指针 B. 能实现物理块的动态分配 C. 回收实现比较简单 D.
用户存取方便 308. 文件目录的主要作用是\_\_\_\_\_ 。 A. 按名存取 B.
提高速度 C. 节省空间 D. 提高外存利用率 309.
在操作系统管理中，面向用户的管理组织机构称为\_\_\_\_\_ 。 A. 用户结构 B.
实际结构 C. 物理结构 D. 逻辑结构 310.
单机操作系统的共享资源主要是指\_\_\_\_\_ 。 A. 内存、CPU和基本软件 B.
键盘、鼠标、显示器 C. 打印机、扫描仪 D. 软盘、硬盘、光盘 311.
为方便用户，操作系统负责管理和控制计算机系统的\_\_\_\_\_ 。 A. 软件资源
B. 硬件和软件资源 C. 用户有用资源 D. 硬件资源 312.
从下面关于并发性的论述中选出一条正确的论述。 A.
并发性是指若干事件在同一时刻发生。 B. 并发性是指若干事件在不同时刻发生。
C. 并发性是指若干事件在同一时间间隔发生。 D.
并发性是指若干事件在不同时间间隔发生。 313.
从下面关于程序执行的论述中，选出一条正确的论述。 A.
一个程序（含数据），在将其划分成若干个模块后，方能执行。 B.
一个程序（含数据），在为其加上适当的控制命令后，方能执行。 C.
一个程序（含数据），在为其加上作业说明书后，方能执行。 D.
一个程序（含数据），在为其建立进程控制块后，方能执行。 314.
分页系统的页长为1KB，虚拟地址0x3C8F对应的页号为\_\_\_\_\_\_\_\_\_\_\_\_
，页内地址为\_\_\_\_\_\_\_\_\_\_\_\_ 。 315.
在一个分页存储管理的系统中，页长为4KB，某一作业的页表如右所示，虚拟地址3000对应物理地址\_\_\_\_\_\_\_\_\_\_\_\_
，12000对应\_\_\_\_\_\_\_\_\_\_\_\_ 。 页号 页帧号 ==== ===== 0 3 1 4 2 6
316.
假设一个系统中的就绪进程情况如右表所示（按照到达顺序），分别计算不同调度策略下的平均周转时间。FCFS：\_\_\_\_\_\_\_\_\_
；HPF（优先级大者优先）：\_\_\_\_\_\_\_\_\_ ；SCBF：\_\_\_\_\_\_\_\_\_ 。 进程
执行期 优先级 === ===== ===== P1 10 2 P2 5 5 P3 3 4 P4 4 1 317.
系统中有一组如右表所示（按照到达顺序）的磁盘I/O请求等待服务，假设当前磁道为100，刚完成对88道的操作，分别计算不同调度方法下的磁头移动总道数。先来先服
务：\_\_\_\_\_\_\_\_\_\_ ；最短寻找时间优先：\_\_\_\_\_\_\_\_\_\_
；电梯式查找：\_\_\_\_\_\_\_\_\_\_ 。 进程 磁道 ==== === 2 12 3 180 1 120
6 72 5 54 318.
Sa、Sb、Sc是已定义信号量，初值分别为1、0、0；x、y、z是公共变量。下面三个并发程序段执行结束后，x=\_\_\_\_\_
，y=\_\_\_\_\_ ，z=\_\_\_\_\_ 。 prA() { P(Sc); z=x+y; V(Sb); } prB() {
y=18; P(Sb); V(Sc); P(Sb); y=z-y; V(Sa); } prC() { P(Sa); x=10; V(Sb);
P(Sa); x=z-9; } 319.
MS-DOS中，假设读目录文件前要先获得其FAT链，而获得FAT链只需访问磁盘一次。若不考虑磁盘缓冲，为定位
\\DIR11\\DIR22\\DIR33\\F0的首簇，至少需要访问磁盘\_\_\_\_\_\_
次；通过相对路径名
..\\DIR33\\F0定位同一文件的首簇，至少需要访问磁盘\_\_\_\_\_\_ 次。 320.
系统中有4MB内存，最大有效物理地址为\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
，如果采用分页管理，页长1KB，全部内存可分为\_\_\_\_\_\_\_\_\_\_\_\_ 页帧。
321. 在一个分段存储管理的系统中，某一作业的段表如右所示，虚拟地址1 |
300对应物理地址\_\_\_\_\_\_\_\_\_\_\_\_ ，2 |
120对应\_\_\_\_\_\_\_\_\_\_\_\_ 。 段号 段长 始址 === === ==== 0 2K 2K 1
4K 6K 2 12K 20K 322.
假设一个系统中的就绪进程情况如右表所示（按照到达顺序），分别计算不同调度策略下的平均周转时间。FCFS：\_\_\_\_\_\_\_\_\_
；HPF（优先级大者优先）：\_\_\_\_\_\_\_\_\_ ；SCBF：\_\_\_\_\_\_\_\_\_ 。 进程
执行期 优先级 === ==== ===== P1 5 2 P2 6 5 P3 3 4 P4 2 3 323.
系统中有一组如右表所示（按照到达顺序）的磁盘I/O请求等待服务，假设当前磁道为88，刚完成对100道的操作，分别计算不同调度方法下的磁头移动总道数。先来先服
务：\_\_\_\_\_\_\_\_\_\_ ；最短寻找时间优先：\_\_\_\_\_\_\_\_\_\_
；电梯式查找：\_\_\_\_\_\_\_\_\_\_ 。 进程 磁道 ==== === 2 90 3 189 1 130
6 16 5 45 324.
Sa、Sb、Sc是已定义信号量，初值分别为1、0、0；x、y、z是公共变量。下面三个并发程序段执行结束后，x=\_\_\_\_\_
，y=\_\_\_\_\_ ，z=\_\_\_\_\_ 。 prA() { P(Sc); z=x+y; V(Sb); } prB() {
P(Sa); x=8; V(Sb); P(Sa); x=z-9; } prC() { y=20; P(Sb); V(Sc); P(Sb);
y=z-y; V(Sa); } 325.
MS-DOS中，假设读目录文件前要先获得其FAT链，而获得FAT链只需访问磁盘一次。若不考虑磁盘缓冲，为定位文件
\\D1\\D2\\D3\\D4\\F0的首簇，至少需要访问磁盘\_\_\_\_\_\_
次；通过相对路径名 ..\\ F0定位同一文件的首簇，至少需要访问磁盘\_\_\_\_\_\_
次。 326.
在手工操作阶段，操作员在进行装卸卡和磁带等手工操作时，ＣＰＵ处于空闲等待，我们称这种现象为\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ 。 327. 多道批处理系统的特征为
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
；
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
；
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 328. 批量处理系统的缺点为
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
；
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 329.
一段时间内仅允许一个进程访问的资源称为\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 330.
在操作系统控制下的多个程序的执行顺序和每个程序的执行时间是不确定的，这种现象称为操作系统的\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 331.
作业管理的基本功能包括\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 332. 一个用户的作业从开始进入系统到结束在计算机系统中经过的阶段为
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 333. 作业调度的时机有
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 334. 常用的多道处理系统的作业调度算法有
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 335.
从结构上看每个进程由\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
组成。 336.
系统感知进程存在的唯一标识为\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 337. 存储管理应实现的功能为
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 338.
所谓静态重定位是指\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 339.
解决小内存大作业的方法有\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 340.
解决外零头的办法有\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 341.
虚空间的大小取决于\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 342.
所谓时间的局部性是指\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 343.
按资源分配的方式可将外设分为\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 344.
一次输入输出操作所花费的时间由\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
组成。 345.
文件存储空间的管理常用的技术有\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 346.
管程的三个组成部分为\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 347.
产生死锁的原因\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 348.
解决死锁的方法\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 349.
所谓中心同步实体是指\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 350.
XENIX为系统管理员提供的两条听机命令为\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 351.
XENIX中用户的注销命令为\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ 。
352. UNIX/XENIX中将使用文件的人分为\_\_\_\_\_\_ ，\_\_\_\_\_\_\_\_
，\_\_\_\_\_\_\_\_ 三个等级。 353.
UNIX/XENIX中改变某一文件的存取权限的命令为\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 354.
UNIX/XENIX中增添一用户的命令为\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 355.
UNIX/XENIX中在软盘上建立文件系统中命令为\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 356. \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
系统的出现，标志着操作系统的形成。 357.
操作系统的基本类型有\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 358.
分时系统的特征为\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 359.
分时系统的特征为\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 360.
操作系统的特征为\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 361.
计算机系统按用户指定的步骤，为用户一次上机解题所完成的工作的总和称为\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 362.
常用的单道批处理作业调度有\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 363.
进程的动态特征是指\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 364.
存储分配的三种方式\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 365.
覆盖是用于解决\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
的问题。 366.
在存储分配时，产生外零头的主要原因为\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 367.
在请求式分页系统中，块的极小数取决于\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 368. 页面置换算法分为\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
，\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ 两大类。 369.
按输入输出特性可将设备分为\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 370. 通道程序的首地址放于\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 371.
段页式存储管理中访问主存中的一条指令或存取数据，则至少需访问内存\_\_\_\_\_\_
次 372.
任何一个对磁盘的访问请求，应给出访问磁盘的存储空间地址，其地址由\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
组成。 373.
文件的逻辑结构的基本形式有\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 374.
与同一个临界资源相联系的临界区称为\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 375. 从物理意义上讲，信号量的值大于\>0
时，其值表示\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ 。 376.
设有n个进程共享一个临界区，若最多允许m个进程（m0时，其值表示\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
。 399. 设有n个进程共享一个临界区，若最多允许m个进程（m ---------- Prog1
\\ / Prog3 Prog6 \\ \\ / \\ +--------------------------\> ----------\> /
\\ Prog4 / Prog8 / \\ / ----------- ----------\> ---------- Prog2 Prog5
Prog7 635.
把学生和监考老师都看做进程，学生有N个人，教师1人，考场门口每次只能进出一个人，进
考场原则是先来先进，当N个学生都进入考场后，教师才能发试卷。学生交卷后可以离开考
场，教师要等收上来全部试卷并封装试卷后才能离开考场。问共需设置几个进程？使用P，V
操作解决上述问题中的同步和互斥关系。 636.
我们将只读数据的进程称为“读者”进程，而写或者修改数据的进程称为“写者”进程，允许多
个“读者”同时读数据，但不运行写者与其它读者或者写者进程同时访问数据。另外，要保证：
一旦有写者等待，新到达的读者必须等待，直到该写者完成数据访问为止，用P,V
操作实现 读者，写者同步。 637.
三个吸烟者在一间房间内，还有一个香烟供应者。为了制造并抽掉香烟，每个吸烟者需要三
样东西：烟草、纸和火柴。供应者有丰富的货物提供。三个吸烟者中，第一个有自己的烟草，
第二个有自己的纸，第三个有自己的火柴。供应者将两样东西放在桌子上，允许一个吸烟者
进行对健康不利的吸烟。当吸烟者完成吸烟后唤醒供应者，供应者再放两样东西（随机地）
在桌面上，然后唤醒另一个吸烟者。试为吸烟者和供应者编写程序解决问题。 638.
有n+1个进程A1，A2，... ,An和B： \* A1,A2,...
,An通过同一个缓冲池各自不断地向B发送消息，B不断地取消息，它必须取走
发来的每个消息，刚开始时缓冲区为空，使用P,V操作实现之。 \*
若缓冲区个数增至M个，试用P,V实现正确通讯。 639. 阅览室问题
有一个阅览室，共有100个座位，读者进入时必须先在一张登记表上登记，该表为每一个座位列一表目，包括座号和读者姓名等，读者离开时要消掉登记的信息，试问；
(1)为描述读者的动作，应编写几个程序，设置几个进程？
(2)试用PV操作描述各个进程之间的同步互斥关系。 640. P,V改错(2001)
设有两个优先级相同的进程P1，P2如下。令信号S1，S2的初值为0，已知z=2，试问P1，P2并发运行结束后x=？y=？z=？
进程P1 | 进程P2 ---|--- y:=1; | x:=1; y:=y+2; | x:=x+1; V(S1); | P(S1);
z:=y+1; | x:=x+y; P(S2); | V(S2); y:=z+y; | z:=x+z; 641. 面包店(2001)
面包师有很多面包，由n个销售人员推销。每人顾客进店后先取一个号，并且等待叫号。当一个销售人员空闲下来时，就叫下一个号。试设计一个使销售人员和顾客同步的算法。
642. 公交车问题(2002)
在一辆公共汽车上，司机和售票员各行其职，司机负责开车和到站停车；售票员负责售票和开、关门，当售票员关好车门后，司机才能继续开车行驶。试用P、V操作实现司机与
售票员之间的同步。 643. 打印机问题
设系统中有5台类型相同的打印机，依次编号为1～5。又设系统中有n个使用打印机的进程，使用前申请，使用后释放。每个进程有一个进程标识，用于区别不同的进程。每个
进程还有一个优先数，不同进程的优先数各异。当有多个进程同时申请时，按照进程优先数由高到低的次序实施分配。试用信号灯和PV操作实现对于打印机资源的管理，即要求
编写如下函数和过程: (1)函数require(pid，pri):
申请一台打印机。参数pid为进程标识，其值为1到n的整数;
pri为进程优先数，其值为正整数;
函数返回值为所申请到打印机的编号，其值为1到5的整数; (2)过程return(prnt):
释放一台打印机。参数prnt为所释放打印机的编号，其值为1到5的整数。 644.
批处理系统问题
设某个批处理系统中，有三个进程：卡片输入进程、作业调度进程、作业控制进程。他们之间的合作关系是：
只要卡片输入机上有作业信息输入，进程把作业逐个输入至输出井并为每个作业建立一个JCB块并把它插入至后备作业队列(JCB链表)中。
当内存中无作业运行时，作业调度进程从JCB中选一个作业，把该作业装入内存。
作业控制进程负责处理已调入内存的作业。 (1)P,V写出输入和调度进程的同步。
(2)用消息缓冲痛惜，写出调度进程与作业控制进程间的同步算法。 645.
桔子汁生产线问题 现有三个生产者P1 、P2
、P3，他们都要生产水，每个生产者都已分别购得两种不同原料，待购得第三种原料后就可配制成桔子水，装瓶出售。有一供应商能源源不断地
供应糖、水、桔子精，但每次只拿出一种原料放入容器中供给生产者。当容器中有原料时需要该原料的生产者可取走，当容器空时供应商又可放入一种原料。假定：生产者P1已
购得糖和水；生产者P2
已购得水和桔子精；生产者P3已购得糖和桔子精；试用：信号量与P、V操作，写出供应商和三个生产者之间能正确同步的程序。
646. 保管员问题 有一材料保管员，他保管纸和笔若干。有A 、B 两组学生，A
组学生每人都备有 纸，B
组学生每人都备有笔．任一学生只要能得到其他一种材料就可以写信。有一个可
以放一张纸或一支笔的小盒，当小盒中无物品时，保管员就可任意放一张纸或一支笔
供学生取用，每次允许一个学生从中取出自己所需的材料，当学生从盒中取走材料后
允许保管员再存放一件材料，请用信号量与P 、v 操作 647. 招聘问题
现有100名毕业生去甲、乙两公司求职，两公司合用一间接待室，其中甲公司招 收10
人，乙公司准备招收10人，招完为止。两公司各有一位人事主管在接待毕业生，
每位人事主管每次只可接待一人，其他毕业生在接待室外排成一个队伍等待。试用信
号量和P 、v 操作实现人员招聘过程。 648. 博物馆-公园问题
Jurassic公园有一个恐龙博物馆和一个花园，有m 个旅客租卫辆车，每辆车仅能乘
一个一旅客。旅客在博物馆逛了一会，然后，排队乘坐旅行车，挡一辆车可用喊飞它载
入一个旅客，再绕花园行驶任意长的时间。若n
辆车都己被旅客乘坐游玩，则想坐车的
旅客需要等待。如果一辆车己经空闲，但没有游玩的旅客了，那么，车辆要等待。试用
信号量和P 、V 操作同步m 个旅客和n 辆车子。 649. \*\* 生产流水线问题\*\*
设自行车生产线上有一只箱子，其中有N 个位置( N
≥3)，每个位置可存放一个车架或一个车轮; 又设有三个工人，其活动分别为:
工人1活动: do{ 加工一个车架; 车架放入箱中; }while(1) | 工人2活动： do{
加工一个车轮; 车轮放入箱中; }while(1) | 工人1活动： do{ 箱中取一个车架;
箱中取两个车轮; 组装为一台车; }while(1) ---|---|--- 试分别用信号灯与PV
操作实现三个工人的合作，要求解中不含死锁。 650. 知错能改
进程p0,p1共享变量flag,turn;他们进入临界区的算法如下: var
flag:array[0..1] of boolean;//初值为false turn:01 process i (0或1) while
true do begin flag[i] =true; while turn!=i do begin while flag[j]==false
do skip;//skip为空语句 turn = i end 临界区; flag[i] = false; 出临界区;
end
该算法能否正确地实现互斥?若不能,应该如何修改(假设flag,turn单元内容的修改和访问
是互斥的). 651.
在虚拟存储系统中，当由虚拟地址找不到对应的物理地址时，会产生缺页故障。请完成如下任务。
1）描述缺页故障（page\_fault）的处理流程； 2）补全下面缺页处理中所缺代码。
kern/trap/trap.c --------------------------------- ... static int
pgfault\_handler(struct trapframe \*tf) { extern struct mm\_struct
\*check\_mm\_struct; if(check\_mm\_struct !=NULL) { //used for test
check\_swap print\_pgfault(tf); } struct mm\_struct \*mm; if
(check\_mm\_struct != NULL) { assert(current == idleproc); mm =
check\_mm\_struct; } else { if (current == NULL) { print\_trapframe(tf);
print\_pgfault(tf); panic("unhandled page fault.\\n"); } mm =
current-\>mm; } return do\_pgfault(mm, tf-\>tf\_err, rcr2());
\_\_\_\_(1)\_\_\_\_ } ... static void trap\_dispatch(struct trapframe
\*tf) { char c; int ret=0; switch (tf-\>tf\_trapno) { case T\_DEBUG:
case T\_BRKPT: debug\_monitor(tf); break; case T\_PGFLT: if ((ret =
pgfault\_handler(tf)) != 0) { \_\_\_(2)\_\_\_ print\_trapframe(tf); if
(current == NULL) { panic("handle pgfault failed. ret=%d\\n", ret); }
else { if (trap\_in\_kernel(tf)) { panic("handle pgfault failed in
kernel mode. ret=%d\\n", ret); } cprintf("killed by kernel.\\n");
panic("handle user mode pgfault failed. ret=%d\\n", ret);
do\_exit(-E\_KILLED); } } break; case T\_SYSCALL: syscall(); break; case
IRQ\_OFFSET + IRQ\_TIMER: // LAB3 : If some page replacement algorithm
need tick to change the priority of pages, // then you can add code
here. ticks ++; assert(current != NULL); run\_timer\_list(); break; case
IRQ\_OFFSET + IRQ\_COM1: case IRQ\_OFFSET + IRQ\_KBD: if ((c =
cons\_getc()) == 13) { debug\_monitor(tf); } else { cprintf("%s [%03d]
%c\\n", (tf-\>tf\_trapno != IRQ\_OFFSET + IRQ\_KBD) ? "serial" : "kbd",
c, c); } break; case IRQ\_OFFSET + IRQ\_IDE1: case IRQ\_OFFSET +
IRQ\_IDE2: /\* do nothing \*/ break; default: print\_trapframe(tf); if
(current != NULL) { cprintf("unhandled trap.\\n"); do\_exit(-E\_KILLED);
} // in kernel, it must be a mistake panic("unexpected trap in
kernel.\\n"); } } kern/mm/vmm.c --------------------------------- //
do\_pgfault - interrupt handler to process the page fault execption int
do\_pgfault(struct mm\_struct \*mm, uint32\_t error\_code, uintptr\_t
addr) { int ret = -E\_INVAL; struct vma\_struct \*vma = find\_vma(mm,
addr); pgfault\_num++; if (vma == NULL ) { cprintf("not valid addr %x,
and can not find it vma %x\\n", addr, vma); goto failed; } else if
(vma-\>vm\_start \> addr) { cprintf("not valid addr %x, and can not find
it vma range[%x, %x]\\n", addr, vma-\>vm\_start, vma-\>vm\_end); goto
failed; } cprintf("valid addr %x, and find it in vma range[%x, %x]\\n",
addr, vma-\>vm\_start, vma-\>vm\_end); switch (error\_code & 3) {
default: /\* default is 3: write, present \*/ case 2: /\* write, not
present \*/ if (!(vma-\>vm\_flags & VM\_WRITE)) { cprintf("write, not
present in do\_pgfault failed\\n"); goto failed; } break; case 1: /\*
read, present \*/ cprintf("read, present in do\_pgfault failed\\n");
goto failed; case 0: /\* read, not present \*/ if (!(vma-\>vm\_flags &
(VM\_READ | VM\_EXEC))) { cprintf("read, not present in do\_pgfault
failed\\n"); goto failed; } } uint32\_t perm = PTE\_U; if
(vma-\>vm\_flags & VM\_WRITE) { perm |= PTE\_W; } addr = ROUNDDOWN(addr,
PGSIZE); ret = -E\_NO\_MEM; pte\_t \*ptep; // try to find a pte, if
pte's PT(Page Table) isn't existed, then create a PT. // (notice the 3th
parameter '1') if ((ptep = get\_pte(mm-\>pgdir, addr, 1)) == NULL) {
cprintf("get\_pte in do\_pgfault failed\\n"); goto failed; } if (\*ptep
== 0) { // if the phy addr isn't exist, then alloc a page & map the phy
addr with logical addr if (pgdir\_alloc\_page(mm-\>pgdir, addr, perm) ==
NULL) { \_\_\_(3)\_\_\_ cprintf("pgdir\_alloc\_page in do\_pgfault
failed\\n"); goto failed; } } else { struct Page \*page=NULL;
cprintf("do pgfault: ptep %x, pte %x\\n",ptep, \*ptep); if (\*ptep &
PTE\_P) { page = pte2page(\*ptep); \_\_\_(4)\_\_\_ } else{ // if this
pte is a swap entry, then load data from disk to a page with phy addr //
and call page\_insert to map the phy addr with logical addr
if(swap\_init\_ok) { if ((ret = swap\_in(mm, addr, &page;)) != 0) {
\_\_\_(5)\_\_\_ cprintf("swap\_in in do\_pgfault failed\\n"); goto
failed; } } else { cprintf("no swap\_init\_ok but ptep is %x,
failed\\n",\*ptep); goto failed; } } page\_insert(mm-\>pgdir, page,
addr, perm); swap\_map\_swappable(mm, addr, page, 1); } ret = 0; failed:
return ret; } kern/mm/swap.c --------------------------------- ... int
swap\_out(struct mm\_struct \*mm, int n, int in\_tick) { int i; for (i =
0; i != n; ++ i) { uintptr\_t v; //struct Page \*\*ptr\_page=NULL;
struct Page \*page; // cprintf("i %d, SWAP: call
swap\_out\_victim\\n",i); int r = sm-\>swap\_out\_victim(mm, &page;,
in\_tick); if (r != 0) { cprintf("i %d, swap\_out: call
swap\_out\_victim failed\\n",i); break; } //assert(!PageReserved(page));
//cprintf("SWAP: choose victim page 0x%08x\\n", page);
v=page-\>pra\_vaddr; pte\_t \*ptep = get\_pte(mm-\>pgdir, v, 0);
assert((\*ptep & PTE\_P) != 0); if (swapfs\_write(
(page-\>pra\_vaddr/PGSIZE+1)<<8, page) != 0) { \_\_\_(6)\_\_\_
cprintf("SWAP: failed to save\\n"); sm-\>map\_swappable(mm, v, page, 0);
continue; } else { cprintf("swap\_out: i %d, store page in vaddr 0x%x to
disk swap entry %d\\n", i, v, page-\>pra\_vaddr/PGSIZE+1); \*ptep =
(page-\>pra\_vaddr/PGSIZE+1)<<8; free\_page(page); }
tlb\_invalidate(mm-\>pgdir, v); } return i; } int swap\_in(struct
mm\_struct \*mm, uintptr\_t addr, struct Page \*\*ptr\_result) { struct
Page \*result = alloc\_page(); assert(result!=NULL); pte\_t \*ptep =
get\_pte(mm-\>pgdir, addr, 0); // cprintf("SWAP: load ptep %x swap entry
%d to vaddr 0x%08x, page %x, No %d\\n", ptep, (\*ptep)\>\>8, addr,
result, (result-pages)); int r; if ((r = swapfs\_read((\*ptep), result))
!= 0) \_\_\_(7)\_\_\_ { assert(r!=0); } cprintf("swap\_in: load disk
swap entry %d with swap\_page in vadr 0x%x free\_area.nr\_free %d\\n",
(\*ptep)\>\>8, addr, free\_area.nr\_free); \*ptr\_result=result; return
0; } kern/mm/pmm.h --------------------------------- ... \#define
alloc\_page() alloc\_pages(1) \#define free\_page(page)
free\_pages(page, 1) kern/mm/pmm.c --------------------------------- ...
// pgdir\_alloc\_page - call alloc\_page & page\_insert functions to //
- allocate a page size memory & setup an addr map // - pa<-\>la with
linear address la and the PDT pgdir struct Page \*
pgdir\_alloc\_page(pde\_t \*pgdir, uintptr\_t la, uint32\_t perm) {
struct Page \*page = alloc\_page(); if (page != NULL) { if
(page\_insert(pgdir, page, la, perm) != 0) { free\_page(page); return
NULL; } if (swap\_init\_ok){ if(check\_mm\_struct!=NULL) {
swap\_map\_swappable(check\_mm\_struct, la, page, 0);
page-\>pra\_vaddr=la; assert(page\_ref(page) == 1); //cprintf("get No.
%d page: pra\_vaddr %x, pra\_link.prev %x, pra\_link\_next %x in
pgdir\_alloc\_page\\n", (page-pages),
page-\>pra\_vaddr,page-\>pra\_page\_link.prev,
page-\>pra\_page\_link.next); } else { //now current is existed, should
fix it in the future //swap\_map\_swappable(current-\>mm, la, page, 0);
//page-\>pra\_vaddr=la; //assert(page\_ref(page) == 1);
//panic("pgdir\_alloc\_page: no pages. now current is existed, should
fix it in the future\\n"); } } } return page; } kern/fs/swapfs.c
--------------------------------- ... int swapfs\_read(swap\_entry\_t
entry, struct Page \*page) { return ide\_read\_secs(SWAP\_DEV\_NO,
swap\_offset(entry) \* PAGE\_NSECT, page2kva(page), PAGE\_NSECT); } int
swapfs\_write(swap\_entry\_t entry, struct Page \*page) { return
ide\_write\_secs(SWAP\_DEV\_NO, swap\_offset(entry) \* PAGE\_NSECT,
page2kva(page), PAGE\_NSECT); } kern/mm/swap\_fifo.c
--------------------------------- ... struct swap\_manager
swap\_manager\_fifo = { .name = "fifo swap manager", .init =
&\_fifo\_init, .init\_mm = &\_fifo\_init\_mm, .tick\_event =
&\_fifo\_tick\_event, .map\_swappable = &\_fifo\_map\_swappable,
.set\_unswappable = &\_fifo\_set\_unswappable, .swap\_out\_victim =
&\_fifo\_swap\_out\_victim, .check\_swap = &\_fifo\_check\_swap, }; 652.
调度器是操作系统内核中依据调度算法进行进程切换选择的模块。请完成如下任务。
1）试描述步进调度算法(Stride Scheduling)的基本原理。
2）请给出下面测试程序（user/priority.c）执行时的进程调度顺序。建议说明每次进程切换后当前执行进程的ID、lab6\_priority、lab6
\_stride和已切换次数。 kern/process/proc.h
--------------------------------- ... struct proc\_struct { enum
proc\_state state; // Process state int pid; // Process ID int runs; //
the running times of Proces uintptr\_t kstack; // Process kernel stack
volatile bool need\_resched; // bool value: need to be rescheduled to
release CPU? struct proc\_struct \*parent; // the parent process struct
mm\_struct \*mm; // Process's memory management field struct context
context; // Switch here to run process struct trapframe \*tf; // Trap
frame for current interrupt uintptr\_t cr3; // CR3 register: the base
addr of Page Directroy Table(PDT) uint32\_t flags; // Process flag char
name[PROC\_NAME\_LEN + 1]; // Process name list\_entry\_t list\_link; //
Process link list list\_entry\_t hash\_link; // Process hash list int
exit\_code; // exit code (be sent to parent proc) uint32\_t wait\_state;
// waiting state struct proc\_struct \*cptr, \*yptr, \*optr; //
relations between processes struct run\_queue \*rq; // running queue
contains Process list\_entry\_t run\_link; // the entry linked in run
queue int time\_slice; // time slice for occupying the CPU
skew\_heap\_entry\_t lab6\_run\_pool; // FOR LAB6 ONLY: the entry in the
run pool uint32\_t lab6\_stride; // FOR LAB6 ONLY: the current stride of
the process uint32\_t lab6\_priority; // FOR LAB6 ONLY: the priority of
process, set by lab6\_set\_priority(uint32\_t) }; user/priority.c
--------------------------------- \#include \#include \#include
\#include \#define TOTAL 6 /\* to get enough accuracy, MAX\_TIME (the
running time of each process) should \>1000 mseconds. \*/ \#define
MAX\_TIME 2000 unsigned int acc[TOTAL]; int status[TOTAL]; int
pids[TOTAL]; static void spin\_delay(void) { int i; volatile int j; for
(i = 0; i != 200; ++ i) { j = !j; } } int main(void) { int i,time;
memset(pids, 0, sizeof(pids)); lab6\_set\_priority(TOTAL + 1); for (i =
0; i < TOTAL; i ++) { acc[i]=0; if ((pids[i] = fork()) == 0) {
lab6\_set\_priority(i + 1); acc[i] = 0; while (1) { spin\_delay(); ++
acc[i]; if(acc[i]%4000==0) { if((time=gettime\_msec())\>MAX\_TIME) {
cprintf("child pid %d, acc %d, time %d\\n",getpid(),acc[i],time);
exit(acc[i]); } } } } if (pids[i] < 0) { goto failed; } } cprintf("main:
fork ok,now need to wait pids.\\n"); for (i = 0; i < TOTAL; i ++) {
status[i]=0; waitpid(pids[i],&status;[i]); cprintf("main: pid %d, acc
%d, time %d\\n",pids[i],status[i],gettime\_msec()); } cprintf("main:
wait pids over\\n"); cprintf("stride sched correct result:"); for (i =
0; i < TOTAL; i ++) { cprintf(" %d", (status[i] \* 2 / status[0] + 1) /
2); } cprintf("\\n"); return 0; failed: for (i = 0; i < TOTAL; i ++) {
if (pids[i] \> 0) { kill(pids[i]); } } panic("FAIL: T.T\\n"); } 653.
一个从键盘输入到打印机输出的数据处理流程图如下所示。其中键盘输入进程
（input\_process）通过缓冲区Buffer1把数据传送给计算进程（calculation\_process），
计算进程把处理结果通过Buffer2传送给打印进程（output\_process）。键盘输入进程、计
算进程及打印进程对缓冲区Buffer1和Buffer2的访问满足下列条件。 Input ===\>
[ Buffer1 ] ===\> Calculation ===\> [ Buffer2 ] ===\> Output 1.
任何时刻只有一个进程在对缓冲区Buffer1进行数据读写操作；只有一个进程在对缓冲区
Buffer2进行数据读写操作；允许进程对Buffer1和Buffer2的同时读写操作。 2.
两个缓冲区的大小是无限大。
请用信号量（semaphore）机制实现键盘输入进程input\_process()、计算进程
calculation\_process()和打印进程output\_process()。要求：用信号量方法（不允许使用
信号量集），并给出信号量定义和初始值；在代码中要有适当的注释，以说明信号量定义的
作用和代码的含义；用类C语言描述共享变量和函数。 654. Bakery算法(Lamport
1979)是一种解决n个线程访问临界区（Critical
Section）问题的软件同步算法。该算法定义了两个共享数组如下： boolean
choosing[n]; int number[n]; //ticket
所有choosing[i]的初始值为false，而number[i]的初始值为0。进程i访问临界区的伪代码如下。
do { choosing[i] = true; number[i] = max(number[0], number[1], …, number
[n – 1])+1; choosing[i] = false; for (j = 0; j < n; j++) { while
(choosing[j]) ; //（A） while ((number[j] != 0) && ( (number[j],j) <
(number[i],i) ) ) ; } critical section number[i] = 0; remainder section
} while (1); 请完成如下任务。
1）删除（A）行的代码，算法还能正确控制对临界区的访问吗？
2）如果能，请说明理由；如果不能，请给出一个出现错误的情形，并解释原因。 655.
在ucore中采用的文件系统是UNIX文件系统UFS的简化版本SFS。请完成如下任务。
1）描述UFS的多级间接索引文件（Multi-level Indexed Allocation）的存储结构；
2）补全下面文件系统代码。 kern/fs/sfs/sfs.h
--------------------------------- \#ifndef \_\_KERN\_FS\_SFS\_SFS\_H\_\_
\#define \_\_KERN\_FS\_SFS\_SFS\_H\_\_ \#include \#include \#include
\#include \#include \#define SFS\_MAGIC 0x2f8dbe2a /\* magic number for
sfs \*/ \#define SFS\_BLKSIZE PGSIZE /\* size of block \*/ \#define
SFS\_NDIRECT 12 /\* \# of direct blocks in inode \*/ \#define
SFS\_MAX\_INFO\_LEN 31 /\* max length of infomation \*/ \#define
SFS\_MAX\_FNAME\_LEN FS\_MAX\_FNAME\_LEN /\* max length of filename \*/
\#define SFS\_MAX\_FILE\_SIZE (1024UL \* 1024 \* 128) /\* max file size
(128M) \*/ \#define SFS\_BLKN\_SUPER 0 /\* block the superblock lives in
\*/ \#define SFS\_BLKN\_ROOT 1 /\* location of the root dir inode \*/
\#define SFS\_BLKN\_FREEMAP 2 /\* 1st block of the freemap \*/ /\* \# of
bits in a block \*/ \#define SFS\_BLKBITS (SFS\_BLKSIZE \* CHAR\_BIT)
/\* \# of entries in a block \*/ \#define SFS\_BLK\_NENTRY (SFS\_BLKSIZE
/ sizeof(uint32\_t)) /\* file types \*/ \#define SFS\_TYPE\_INVAL 0 /\*
Should not appear on disk \*/ \#define SFS\_TYPE\_FILE 1 \#define
SFS\_TYPE\_DIR 2 \#define SFS\_TYPE\_LINK 3 /\* \* On-disk superblock
\*/ struct sfs\_super { uint32\_t magic; /\* magic number, should be
SFS\_MAGIC \*/ uint32\_t blocks; /\* \# of blocks in fs \*/ uint32\_t
unused\_blocks; /\* \# of unused blocks in fs \*/ char
info[SFS\_MAX\_INFO\_LEN + 1]; /\* infomation for sfs \*/ }; /\* inode
(on disk) \*/ struct sfs\_disk\_inode { uint32\_t size; /\* size of the
file (in bytes) \*/ uint16\_t type; /\* one of SYS\_TYPE\_\* above \*/
uint16\_t nlinks; /\* \# of hard links to this file \*/ uint32\_t
blocks; /\* \# of blocks \*/ uint32\_t direct[SFS\_NDIRECT]; /\* direct
blocks \*/ uint32\_t indirect; /\* indirect blocks \*/ // uint32\_t
db\_indirect; /\* double indirect blocks \*/ // unused }; /\* file entry
(on disk) \*/ struct sfs\_disk\_entry { uint32\_t ino; /\* inode number
\*/ char name[SFS\_MAX\_FNAME\_LEN + 1]; /\* file name \*/ }; \#define
sfs\_dentry\_size \\ sizeof(((struct sfs\_disk\_entry \*)0)-\>name) /\*
inode for sfs \*/ struct sfs\_inode { struct sfs\_disk\_inode \*din; /\*
on-disk inode \*/ uint32\_t ino; /\* inode number \*/ bool dirty; /\*
true if inode modified \*/ int reclaim\_count; /\* kill inode if it hits
zero \*/ semaphore\_t sem; /\* semaphore for din \*/ list\_entry\_t
inode\_link; /\* entry for linked-list in sfs\_fs \*/ list\_entry\_t
hash\_link; /\* entry for hash linked-list in sfs\_fs \*/ }; \#define
le2sin(le, member) \\ to\_struct((le), struct sfs\_inode, member) /\*
filesystem for sfs \*/ struct sfs\_fs { struct sfs\_super super; /\*
on-disk superblock \*/ struct device \*dev; /\* device mounted on \*/
struct bitmap \*freemap; /\* blocks in use are mared 0 \*/ bool
super\_dirty; /\* true if super/freemap modified \*/ void \*sfs\_buffer;
/\* buffer for non-block aligned io \*/ semaphore\_t fs\_sem; /\*
semaphore for fs \*/ semaphore\_t io\_sem; /\* semaphore for io \*/
semaphore\_t mutex\_sem; /\* semaphore for link/unlink and rename \*/
list\_entry\_t inode\_list; /\* inode linked-list \*/ list\_entry\_t
\*hash\_list; /\* inode hash linked-list \*/ }; /\* hash for sfs \*/
\#define SFS\_HLIST\_SHIFT 10 \#define SFS\_HLIST\_SIZE (1 <<
SFS\_HLIST\_SHIFT) \#define sin\_hashfn(x) (hash32(x,
SFS\_HLIST\_SHIFT)) /\* size of freemap (in bits) \*/ \#define
sfs\_freemap\_bits(super) ROUNDUP((super)-\>blocks, SFS\_BLKBITS) /\*
size of freemap (in blocks) \*/ \#define sfs\_freemap\_blocks(super)
ROUNDUP\_DIV((super)-\>blocks, SFS\_BLKBITS) struct fs; struct inode;
void sfs\_init(void); int sfs\_mount(const char \*devname); void
lock\_sfs\_fs(struct sfs\_fs \*sfs); void lock\_sfs\_io(struct sfs\_fs
\*sfs); void lock\_sfs\_mutex(struct sfs\_fs \*sfs); void
unlock\_sfs\_fs(struct sfs\_fs \*sfs); void unlock\_sfs\_io(struct
sfs\_fs \*sfs); void unlock\_sfs\_mutex(struct sfs\_fs \*sfs); int
sfs\_rblock(struct sfs\_fs \*sfs, void \*buf, uint32\_t blkno, uint32\_t
nblks); int sfs\_wblock(struct sfs\_fs \*sfs, void \*buf, uint32\_t
blkno, uint32\_t nblks); int sfs\_rbuf(struct sfs\_fs \*sfs, void \*buf,
size\_t len, uint32\_t blkno, off\_t offset); int sfs\_wbuf(struct
sfs\_fs \*sfs, void \*buf, size\_t len, uint32\_t blkno, off\_t offset);
int sfs\_sync\_super(struct sfs\_fs \*sfs); int
sfs\_sync\_freemap(struct sfs\_fs \*sfs); int sfs\_clear\_block(struct
sfs\_fs \*sfs, uint32\_t blkno, uint32\_t nblks); int
sfs\_load\_inode(struct sfs\_fs \*sfs, struct inode \*\*node\_store,
uint32\_t ino); \#endif /\* !\_\_KERN\_FS\_SFS\_SFS\_H\_\_ \*/
kern/fs/sfs/sfs\_inode.c --------------------------------- static int
sfs\_bmap\_get\_sub\_nolock(struct sfs\_fs \*sfs, uint32\_t \*entp,
uint32\_t index, bool create, uint32\_t \*ino\_store) { assert(index <
SFS\_BLK\_NENTRY); int ret; uint32\_t ent, ino = 0; off\_t offset =
index \* sizeof(uint32\_t); if ((ent = \*entp) != 0) { if ((ret =
sfs\_rbuf(sfs, &ino;, sizeof(uint32\_t), ent, offset)) != 0) {
\_\_\_(1)\_\_\_ return ret; } if (ino != 0 || !create) { goto out; } }
else { if (!create) { goto out; } if ((ret = sfs\_block\_alloc(sfs,
&ent;)) != 0) { return ret; } } if ((ret = sfs\_block\_alloc(sfs,
&ino;)) != 0) { goto failed\_cleanup; } if ((ret = sfs\_wbuf(sfs, &ino;,
sizeof(uint32\_t), ent, offset)) != 0) { \_\_\_(2)\_\_\_
sfs\_block\_free(sfs, ino); goto failed\_cleanup; } out: if (ent !=
\*entp) { \*entp = ent; } \*ino\_store = ino; return 0; failed\_cleanup:
if (ent != \*entp) { sfs\_block\_free(sfs, ent); } return ret; } static
int sfs\_bmap\_get\_nolock(struct sfs\_fs \*sfs, struct sfs\_inode
\*sin, uint32\_t index, bool create, uint32\_t \*ino\_store) { struct
sfs\_disk\_inode \*din = sin-\>din; int ret; uint32\_t ent, ino; if
(index < SFS\_NDIRECT) { \_\_\_(3)\_\_\_ if ((ino = din-\>direct[index])
== 0 && create) { if ((ret = sfs\_block\_alloc(sfs, &ino;)) != 0) {
return ret; } din-\>direct[index] = ino; sin-\>dirty = 1; } goto out; }
index -= SFS\_NDIRECT; \_\_\_(4)\_\_\_ if (index < SFS\_BLK\_NENTRY) {
ent = din-\>indirect; if ((ret = sfs\_bmap\_get\_sub\_nolock(sfs, &ent;,
index, create, &ino;)) != 0) { \_\_\_(5)\_\_\_ return ret; } if (ent !=
din-\>indirect) { assert(din-\>indirect == 0); din-\>indirect = ent;
sin-\>dirty = 1; } goto out; } index -= SFS\_BLK\_NENTRY;
\_\_\_(6)\_\_\_ if ((ent = ino) != 0) { if ((ret =
sfs\_bmap\_get\_sub\_nolock(sfs, &ent;, index % SFS\_BLK\_NENTRY,
create, &ino;)) != 0) { return ret; } } out: assert(ino == 0 ||
sfs\_block\_inuse(sfs, ino)); \*ino\_store = ino; return 0; } static int
sfs\_io\_nolock(struct sfs\_fs \*sfs, struct sfs\_inode \*sin, void
\*buf, off\_t offset, size\_t \*alenp, bool write) { struct
sfs\_disk\_inode \*din = sin-\>din; assert(din-\>type !=
SFS\_TYPE\_DIR); off\_t endpos = offset + \*alenp, blkoff; \*alenp = 0;
if (offset < 0 || offset \>= SFS\_MAX\_FILE\_SIZE || offset \> endpos) {
return -E\_INVAL; } if (offset == endpos) { return 0; } if (endpos \>
SFS\_MAX\_FILE\_SIZE) { endpos = SFS\_MAX\_FILE\_SIZE; } if (!write) {
if (offset \>= din-\>size) { return 0; } if (endpos \> din-\>size) {
endpos = din-\>size; } } int (\*sfs\_buf\_op)(struct sfs\_fs \*sfs, void
\*buf, size\_t len, uint32\_t blkno, off\_t offset); int
(\*sfs\_block\_op)(struct sfs\_fs \*sfs, void \*buf, uint32\_t blkno,
uint32\_t nblks); if (write) { sfs\_buf\_op = sfs\_wbuf, sfs\_block\_op
= sfs\_wblock; \_\_\_(7)\_\_\_ } else { sfs\_buf\_op = sfs\_rbuf,
sfs\_block\_op = sfs\_rblock; } int ret = 0; size\_t size, alen = 0;
uint32\_t ino; uint32\_t blkno = offset / SFS\_BLKSIZE; uint32\_t nblks
= endpos / SFS\_BLKSIZE - blkno; if ((blkoff = offset % SFS\_BLKSIZE) !=
0) { size = (nblks != 0) ? (SFS\_BLKSIZE - blkoff) : (endpos - offset);
if ((ret = sfs\_bmap\_load\_nolock(sfs, sin, blkno, &ino;)) != 0) { goto
out; } if ((ret = sfs\_buf\_op(sfs, buf, size, ino, blkoff)) != 0) {
\_\_\_(8)\_\_\_ goto out; } alen += size; if (nblks == 0) { goto out; }
buf += size, blkno ++, nblks --; } size = SFS\_BLKSIZE; while (nblks !=
0) { if ((ret = sfs\_bmap\_load\_nolock(sfs, sin, blkno, &ino;)) != 0) {
goto out; } if ((ret = sfs\_block\_op(sfs, buf, ino, 1)) != 0) { goto
out; } alen += size, buf += size, blkno ++, nblks --; } if ((size =
endpos % SFS\_BLKSIZE) != 0) { if ((ret = sfs\_bmap\_load\_nolock(sfs,
sin, blkno, &ino;)) != 0) { goto out; } if ((ret = sfs\_buf\_op(sfs,
buf, size, ino, 0)) != 0) { goto out; } alen += size; } out: \*alenp =
alen; if (offset + alen \> sin-\>din-\>size) { sin-\>din-\>size = offset
+ alen; sin-\>dirty = 1; } return ret; } static int sfs\_read(struct
inode \*node, struct iobuf \*iob) { return sfs\_io(node, iob, 0);
\_\_\_(9)\_\_\_ } static int sfs\_write(struct inode \*node, struct
iobuf \*iob) { return sfs\_io(node, iob, 1); \_\_\_(10)\_\_\_ } static
inline int sfs\_io(struct inode \*node, struct iobuf \*iob, bool write)
{ struct sfs\_fs \*sfs = fsop\_info(vop\_fs(node), sfs); struct
sfs\_inode \*sin = vop\_info(node, sfs\_inode); int ret; lock\_sin(sin);
{ size\_t alen = iob-\>io\_resid; ret = sfs\_io\_nolock(sfs, sin,
iob-\>io\_base, iob-\>io\_offset, &alen;, write); \_\_\_(11)\_\_\_ if
(alen != 0) { iobuf\_skip(iob, alen); } } unlock\_sin(sin); return ret;
} static const struct inode\_ops sfs\_node\_dirops = { .vop\_magic =
VOP\_MAGIC, .vop\_open = sfs\_opendir, .vop\_close = sfs\_close,
.vop\_read = NULL\_VOP\_ISDIR, .vop\_write = NULL\_VOP\_ISDIR,
.vop\_fstat = sfs\_fstat, .vop\_fsync = sfs\_fsync, .vop\_mkdir =
NULL\_VOP\_UNIMP, .vop\_link = NULL\_VOP\_UNIMP, .vop\_rename =
NULL\_VOP\_UNIMP, .vop\_readlink = NULL\_VOP\_ISDIR, .vop\_symlink =
NULL\_VOP\_UNIMP, .vop\_namefile = sfs\_namefile, .vop\_getdirentry =
sfs\_getdirentry, .vop\_reclaim = sfs\_reclaim, .vop\_ioctl =
NULL\_VOP\_INVAL, .vop\_gettype = sfs\_gettype, .vop\_tryseek =
NULL\_VOP\_ISDIR, .vop\_truncate = NULL\_VOP\_UNIMP, .vop\_create =
NULL\_VOP\_UNIMP, .vop\_unlink = NULL\_VOP\_UNIMP, .vop\_lookup =
sfs\_lookup, .vop\_lookup\_parent = NULL\_VOP\_UNIMP, }; static const
struct inode\_ops sfs\_node\_fileops = { .vop\_magic = VOP\_MAGIC,
.vop\_open = sfs\_openfile, .vop\_close = sfs\_close, .vop\_read =
sfs\_read, .vop\_write = sfs\_write, .vop\_fstat = sfs\_fstat,
.vop\_fsync = sfs\_fsync, .vop\_mkdir = NULL\_VOP\_NOTDIR, .vop\_link =
NULL\_VOP\_NOTDIR, .vop\_rename = NULL\_VOP\_NOTDIR, .vop\_readlink =
NULL\_VOP\_NOTDIR, .vop\_symlink = NULL\_VOP\_NOTDIR, .vop\_namefile =
NULL\_VOP\_NOTDIR, .vop\_getdirentry = NULL\_VOP\_NOTDIR, .vop\_reclaim
= sfs\_reclaim, .vop\_ioctl = NULL\_VOP\_INVAL, .vop\_gettype =
sfs\_gettype, .vop\_tryseek = sfs\_tryseek, .vop\_truncate =
sfs\_truncfile, .vop\_create = NULL\_VOP\_NOTDIR, .vop\_unlink =
NULL\_VOP\_NOTDIR, .vop\_lookup = NULL\_VOP\_NOTDIR,
.vop\_lookup\_parent = NULL\_VOP\_NOTDIR, }; 656.
某计算机系统中有M个同类型共享资源，有N个进程竞争使用，每个进程最多需要K个共享资源。该系统不会发生死锁的K的最大值是多少？要求给出计算过程，并说明理由。
657. 请求分页管理系统中，假设某进程的页表内容如下表所示。 页号| 页框号|
有效位 （存在位） | 0| 101H| 1 ---|---|--- 1| \\--| 0 2| 254H| 1
页面大小为4KB，一次内存的访问时间是100ns，一次快表（TLB）的访问时间是10ns，处理一次缺页的平均时间为108ns（已含更新TLB和页表的时间），
进程的驻留集大小固定为2，采用最近最少使用置换算法（LRU）和局部淘汰策略。假设
①TLB初始为空；
②地址转换时先访问TLB，若TLB未命中，再访问页表（忽略访问页表之后的TLB更新时间）；
③有效位为0表示页面不在内存，产生缺页中断，缺页中断处理后，返回到产生缺页中断的指令处重新执行。设有虚地址访问序列2362H、1565H、25A5H
请问： 1) 依次访问上述三个虚地址，各需多少时间？给出计算过程。 2)
基于上述访问序列，虚地址1565H的物理地址是多少？请说明理由。 658.
三个进程P1、P2、P3互斥使用一个包含N（N\>0）个单元的缓冲区。
P1每次用produce()生成一个正整数并用put)送入缓冲区某一空单元中；
P2每次用getodd()从该缓冲区中取出一个奇数并用countodd()统计奇数个数；
P3每次用geteven()从该缓冲区中取出一个偶数并用counteven()统计偶数个数。
请用信号量机制实现这三个进程的同步与互斥活动，并说明所定义的信号量的含义。要求用伪代码描述。
659.
设某计算机的逻辑地址空间和物理地址空间均为64KB，按字节编址.某进程最多需要6页数据存储空间，页的大小为1KB，操作系统采用固定分配局部置换策略为此进程分
配4个页框. 页号| 页框号| 装入时间| 访问位 | 0| 7| 130| 1 ---|---|---|---
1| 4| 230| 1 2| 2| 200| 1 3| 9| 160| 1
当该进程执行到时刻260时，要访问逻辑地址为17CAH的数据.请回答下列问题:
(1)该逻辑地址对应的页号时多少?
(2)若采用先进先出(FIFO)置换算法，该逻辑地址对应的物理地址?要求给出计算过程.
(3)采用时钟(Clock)置换算法，该逻辑地址对应的物理地址是多少?要求给出计算过程.
(设搜索下一页的指针按顺时针方向移动，且指向当前2号页框，示意图如下) TODO
660. 单级中断系统中，中断服务程序执行顺序是 I.保护现场 II.开中断
III.关中断 IV.保存断点 V.中断事件处理 VI.恢复现场 VII.中断返回 A.
I-\>V-\>VI-\>II-\>VII B. III-\>I-\>V-\>VII C. III-\>IV-\>V-\>VI-\>VII D.
IV-\>I-\>V-\>VI-\>VII 661. 下列选项中，操作系统提供给应用程序的接口是 A.
系统调用 B. 中断 C. 库函数 D. 原语 662.
下列选项中，导制创建新进程的操作是 I.用户登陆成功 II.设备分配
III.启动程序执行 A. 仅I和II B. 仅II和III C. 仅I和III D. I、II、III 663.
设与某资源相关联的信号量初值为3，当前值为1，若M表示该资源的可用个数，N表
示等待该资源的进程数，则M，N分别是 A. 0，1 B. 1，0 C. 1，2 D. 2，0 664.
下列选项中，降低进程优先权级的合理时机是 A. 进程的时间片用完 B.
进程刚完成 I/O，进入就绪列队 C. 进程长期处于就绪列队 D.
进程从就绪状态转为运行状态 665.
假定用若干个2K×4位芯片组成一个8K×8为存储器，则0B1FH所在芯片的最小地址是
A. 0000H B. 0600H C. 0700H D. 0800H 666.
进程pO和p1的共享变量定义及其初值为: boolean flag[2]; int turn = 0;
flag[0] = false; flag[1] = false;
若进程p0和p1访问临界资源的类C代码实现如下: void p0() // 进程 p0 { while
(TRUE) { flag[0] = TRUE; turn = 1; while (flag[1] && (turn == 1))
临界区; flag[0] = FALSE; } } void p1() // 进程 p1 { while (TRUE) {
flag[0] = TRUE; turn = 0; while (flag[0] && (turn == 0)); 临界区;
flag[1] = FALSE; } } 则并发执行进程pO和p1时产生的情况是 A.
不能保证进程互斥进入临界区，会出现”饥饿”现象 B.
不能保证进程互斥进入临界区，不会出现”饥饿”现象 C.
能保证进程互斥进入临界区，会出现”饥饿”现象 D.
能保证进程互斥进入临界区，不会出现”饥饿”现象 667.
某基于动态分区存储管理的计算机，其主存容量为55Mb(初始为空)，采用最佳适配(Best
Fit)算法，分配和释放的顺序为:分配15Mb，分配30Mb，释放15Mb，分配6Mb，此时主存中最大空闲分区的大小是
A. 7Mb B. 9Mb C. 10Mb D. 15Mb 668.
某计算机采用二级页表的分页存储管理方式，按字节编制，页大小为2\^10字节，页表项大小为2字节，逻辑地址结构为
|页目录号|页号|页内偏移量|
逻辑地址空间大小为2\^10页，则表示整个逻辑地址空间的页目录表中包含表项的个数至少是
A. 64 B. 128 C. 256 D. 512 669.
设文件索引节点中有7个地址项，其中4个地址为直接地址索引，1个地址项是二级间接地址索引，每个地址项的大小为4字节，若磁盘索引块和磁盘数据块大小均为256字节
，则可表示的单个文件最大长度是 A. 33KB B. 519KB C. 1057KB D. 16513KB 670.
设当前工作目录的主要目的是 A. 节省外存空间 B. 节约内存空间 C.
加快文件的检索速度 D. 加快文件读写速度 671.
本地用户通过键盘登陆系统是，首先获得键盘输入信息的程序时 A. 命令解释程序
B. 中断处理程序 C. 系统调用程序 D. 用户登录程序 672.
下列选项中，能引起外部中断的事件是 A. 键盘输入 B. 除数为0 C. 浮点运算下溢
D. 访存缺页 673. 单处理机系统中，可并行的是 I 进程与进程 II 处理机与设备
III 处理机与通道 IV 设备与设备 A. I、II和III B. I、II和IV C. I、III和IV
D. II、III和IV 674.
下列进程调度算法中，综合考虑进程等待时间和执行时间的是 A.
时间片轮转调度算法 B. 短进程优先调度算法 C. 先来先服务调度算法 D.
高响应比优先调度算法 675.
某计算机系统中有8台打印机，有K个进程竞争使用，每个进程最多需要3台打印机。该系统可能会发生死锁的K的最小值是（）
A. 2 B. 3 C. 4 D. 5 676. 分区分配内存管理方式的主要保护措施是 A.
界地址保护 B. 程序代码保护 C. 数据保护 D. 栈保护 677.
一个分段存储管理系统中，地址长度为32位，其中段号占8位，则段长最大 A.
2的8次方字节 B. 2的16次方字节 C. 2的24次方字节 D. 2的32次方字节 678.
下列文件物理结构中，适合随机访问且易于文件扩展的是 A. 连续结构 B.
索引结构 C. 链式结构且磁盘块定长 D. 链式结构且磁盘块变长 679.
假设磁头当前位于第105道，正在向磁道序号增加的方向移动。现有一个磁道访问请求序列为35，45，12，68，110，180，170，195，采用SCAN调度
（电梯调度）算法得到的磁道访问序列是 A. 110，170，180，195，68，45，35，12 B.
110，68，45，35，12，170，180，195 C. 110，170，180，195，12，35，45，68 D.
12，35，45，68，110，170，180，195 680.
文件系统中，文件访问控制信息存储的合理位置是 A. 文件控制块 B. 文件分配表
C. 用户口令表 D. 系统注册表 681.
设文件F1的当前引用计数值为1，先建立F1的符号链接（软链接）文件F2，再建立F1的硬链接文件F3，然后删除F1。此时，F2和F3的引用计数值分别是
A. 0、1 B. 1、1 C. 1、2 D. 2、1 682.
程序员利用系统调用打开I/O设备时，通常使用的设备标识是 A. 逻辑设备名 B.
物理设备名 C. 主设备号 D. 从设备号 683.
(20150309\_操作系统试题\_doc)操作系统中采用多道程序设计技术提高CPU和外设的【
】。 A.可靠性 B.兼容性 C.利用率 D.稳定性 684.
(20150309\_操作系统试题\_doc)若把操作系统看作系统资源的管理者，下列的【
】不属于操作系统所管理的资源。 A.程序 B.CPU C.中断 D.内存 685.
(20150309\_操作系统试题\_doc)在进程管理中，当【
】时，进程从阻塞状态变为就绪状态。 A.进程调度 B.等待的事件发生
C.等待某一事件 D.时间片用完 686.
(20150309\_操作系统试题\_doc)一个执行的进程时间片用完后，它的状态变为【
】。 A.就绪 B.等待 C.挂起 D.不确定 687.
(20150309\_操作系统试题\_doc)若P、V原语的信号量S的初值为5，当前值为-3，则表示有【
】个等待进程。 A.0个 B.3个 C.5个 D.8个 688.
(20150309\_操作系统试题\_doc)多道程序环境下，操作系统分配资源以【
】为基本单位。 A.程序 B.指令 C.作业 D.进程 689.
(20150309\_操作系统试题\_doc)通常，用户进程被创建后，【 】。
A.便一直存在于系统中，直到被操作员撤消 B.随着进程的阻塞与唤醒而撤消与建立
C.随着时间片轮转而撤消与建立 D.随着作业运行正常或不正常结束而撤消 690.
(20150309\_操作系统试题\_doc)资源的有序分配策略可以破坏【 】条件。
A.互斥使用 B.不剥夺 C.请求和保持 D.环路等待 691.
(20150309\_操作系统试题\_doc)不可行的死锁预防策略是【 】。
A.破坏互斥条件 B.破坏不可剥夺条件 C.破坏请求和保持条件
D.破坏环路等待条件 692.
(20150309\_操作系统试题\_doc)某系统中有5个并发进程，都需要同类资源3个，请问该系统不会发生死锁的最少资源数是【
】。 A.10 B.11 C.12 D.15 693.
(20150309\_操作系统试题\_doc)在分时操作系统中，进程调度经常采用【
】算法。 A.先来先服务 B.最高优先权 C.时间片轮转 D.短进程优先 694.
(20150309\_操作系统试题\_doc)在存储管理中，采用覆盖与交换技术的目的是【
】。 A.逻辑扩充内存容量 B.物理扩充内存容量 C.提高CPU效率 D.实现内存共享
695.
(20150309\_操作系统试题\_doc)分区存储管理中的最佳适应算法，要求把空闲区按照【
】的次序登记在空闲区表中。 A.大小递减 B.大小递增 C.地址递减 D.地址递增
696.
(20150309\_操作系统试题\_doc)在分页存储管理系统中，若逻辑地址用24位表示，其中8位表示页号，则页面大小为【
】。 A.28 B.216 C.224 D.232 697.
(20150309\_操作系统试题\_doc)实现虚拟存储器的目的是【 】。
A.实现存储保护 B.实现内存共享 C.逻辑扩充内存 D.物理扩充内存 698.
(20150309\_操作系统试题\_doc)系统“抖动”现象的发生是由【 】引起的。
A.置换算法选择不当 B.请求页式方案 C.交换的信息量过大 D.内存容量不足 699.
(20150309\_操作系统试题\_doc)CPU输出数据的速度远远高于打印机的打印速度，为解决这一矛盾，可采用【
】。 A.并行技术 B.通道技术 C.虚存技术 D.缓冲技术 700.
(20150309\_操作系统试题\_doc)设备管理程序借助一些数据结构实现对设备的管理，下面的【
】不属于设备管理数据结构。 A.DCT B.COCT C.CHCT D.JCB 701.
(20150309\_操作系统试题\_doc)SPOOLing技术的实质是将【
】转化为共享设备的技术。 A.独占设备 B.虚拟设备 C.脱机设备 D.块设备 702.
(20150309\_操作系统试题\_doc)按【 】分类可将设备分为块设备和字符设备。
A.从属关系 B.共享属性 C.信息交换单位 D.操作特性 703.
(20150309\_操作系统试题\_doc)操作系统的五大主要功能：\_\_\_\_\_\_\_\_、\_\_\_\_\_\_\_、\_\_\_\_\_\_\_\_\_\_、文件管理以及用户接口管理。
704.
(20150309\_操作系统试题\_doc)从系统的角度看，作业由程序、\_\_\_\_\_和\_\_\_\_\_组成。
705.
(20150309\_操作系统试题\_doc)在系统中为控制系统调用服务的机构称为\_\_\_\_\_处理机构。
706.
(20150309\_操作系统试题\_doc)现代操作系统的特点是程序的\_\_\_\_\_执行、系统所拥有的资源被\_\_\_\_\_和系统的用户\_\_\_\_\_的使用。
707.
(20150309\_操作系统试题\_doc)\_\_\_\_\_执行是为了增强计算机系统的处理能力和提高资源利用率所采取的一种同时操作技术。
708.
(20150309\_操作系统试题\_doc)\_\_\_\_\_\_\_\_\_是系统感知进程的唯一实体。
709.
(20150309\_操作系统试题\_doc)进程三种基本状态：执行状态、\_\_\_\_\_、\_\_\_\_\_。
710.
(20150309\_操作系统试题\_doc)一段时间内只允许一个进程访问的资源称为\_\_\_\_\_。
711.
(20150309\_操作系统试题\_doc)不允许两个以上的共享该资源的并发进程同时进入临界区称为\_\_\_\_\_。
712.
(20150309\_操作系统试题\_doc)死锁的排除方法有\_\_\_\_\_、\_\_\_\_\_和死锁的检测和恢复。
713.
(20150309\_操作系统试题\_doc)存储管理的方式主要有：分区存储管理、\_\_\_\_\_管理、段式管理和\_\_\_\_\_管理。
714.
(20150309\_操作系统试题\_doc)可以实现内存和设备之间直接交换数据的数据传送控制方有：\_\_\_\_\_方式和DMA方式。
715.
(20150309\_操作系统试题\_doc)死锁的产生有四个必要条件，只要其中之一满足，就会发生死锁。【
】 A.对 B.错 716.
(20150309\_操作系统试题\_doc)在计算机系统运行过程中，系统开销越大，系统运行效率越高。【
】 A.对 B.错 717.
(20150309\_操作系统试题\_doc)实时系统的主要特点式提供即时响应和高可靠性。【
】 A.对 B.错 718.
(20150309\_操作系统试题\_doc)最高响应比优先法是FCFS方式和SJF方式的一种综合平衡。【
】 A.对 B.错 719.
(20150309\_操作系统试题\_doc)进程空间的大小取决于物理内存的大小。【 】
A.对 B.错 720.
(20150309\_操作系统试题\_doc)指令级的原语的执行过程不允许中断。【 】
A.对 B.错 721.
(20150309\_操作系统试题\_doc)一个处于阻塞状态的进程不可能自己唤醒自己。【
】 A.对 B.错 722.
(20150309\_操作系统试题\_doc)同步和互斥是两个不同的概念，不会在同一进程中同时出现同步问题和互斥问题。【
】 A.对 B.错 723.
(20150309\_操作系统试题\_doc)实时调度算法中的频率单调调度算法的基本原理是频率越低的任务的优先级越低。【
】 A.对 B.错 724.
(20150309\_操作系统试题\_doc)内存的分配算法中，最佳适应算法具有最佳的搜索速度。【
】 A.对 B.错 725. (20150309\_操作系统试题\_doc)名词解释：抖动 726.
(20150309\_操作系统试题\_doc)名词解释：中断 727.
(20150309\_操作系统试题\_doc)DMA方式与中断方式相比，其主要优点是什么？
728. (20150309\_操作系统试题\_doc)进程调度的功能有那些？ 729.
(20150309\_操作系统试题\_doc)什么是页式管理？静态页式管理可以实现虚存吗？
730.
(20150309\_操作系统试题\_doc)假设有四个作业的单道系统，它们的提交、运行时间如下表所示（时间单位：小时，以十进制进行计算）。若采用响应比高者优先
调度的非抢占式调度算法，试回答： （1）作业应以怎样的顺序调度？给出分析过程。
（2）计算平均周转时间。 |作业号|到达时间|运行时间| | A | 8.0 | 2 | | B |
8.5 | 0.5 | | C | 9.0 | 1.0 | | D | 9.5 | 0.2 | 731.
(20150309\_操作系统试题\_doc)假如某银行的营业大厅内只有10个座位，唯一的管理员发现有空位时按流水号通知门外等候的顾客进入大厅，顾客没有被通知时
不得擅自进入大厅。如果把管理员看作进程Supervisor，把顾客看作进程Client，用P、V原语描述管理员和顾客之间合作关系，回答以下问题：
（1）设置信号量empty，用于查看是否有空座位，其初值应为多少？设置信号量enter，用于通知门外等候的顾客，其初值应为多少？
（2）根据定义的信号量，将适当的P、V原语填入以下程序使并发进程能够正确执行。
COBEGIN Supervisor：Repeat Begin 查看座位情况； ① ； 走出大厅； 通知顾客； ②
； 返回大厅； End Until False； Client：Repeat Begin ③ ； 进入大厅； 办理业务；
④ ； 离开大厅； End Until False； COEND 732.
(20150309\_操作系统试题\_doc)设进程A（30K）、B（70K）和C（50K）依次请求内存分配，内存采用可变分区管理。现有两个空闲分区F1（150
K）和F2（90K），如下图所示。若采用最佳适应算法，画出内存分配情况示意图。 |
已用 | |F1(150K)| | 已用 | |F2( 90K)| | 已用 | 733.
(20150309\_操作系统试题\_doc)在一个分页存储管理系统中，已知页面大小L=1024KB。现有一进程，其页表如下：
|页号|块号| | 0 | 5 | | 1 | 7 | | 2 | 3 | | 3 | 2 | | 4 | 8 |
计算与给定逻辑地址LA对应的物理地址PA，给出计算过程： （1）逻辑地址LA=2548；
（2）逻辑地址LA=6000。 734.
(20150309\_操作系统试题\_doc)在一个请求分页存储管理系统中，某进程的页面走向为4、3、2、1、4、3、5、4、3、2，当分配给该进程的物理块数为
3 时（假设开始执行时内存中没有页面），试回答以下问题：
（1）计算采用先进先出FIFO置换算法的缺页率；
（2）FIFO置换算法选择什么样的页面淘汰？ 735.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)操作系统是计算机系统的一种﹎﹎﹎﹎。
A.应用软件 B.系统软件 C.通用软件 D.工具软件 736.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)操作系统是一种系统软件，它﹎﹎﹎﹎。
A.控制程序的执行 B.管理计算机系统的资源 C.方便用户使用计算机
D.管理计算机系统的资源和控制程序的执行 737.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)下列选择中，﹎﹎﹎﹎不是操作系统关心的主要问题，
A.管理计算机裸机 B.设计、提供用户程序与计算机硬件系统的界面
C.管理计算机系统资源 D.高级程序设计语言的编译器 738.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)操作系统的主要功能是管理计算机系统中的资源，其中包括﹎﹎﹎﹎管理和存储器管理，以及设备管理
和文件管理。这里的﹎﹎﹎﹎管理主要是对进程进行管理。 A.存储器
B.虚拟存储器 C.运算器 D.处理机 E.控制器 739.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)实现不同的作业处理方式（如：批处理、分时处理、实时处理等），主要是基于操作系统对
管理采用了不同的策略。 A.处理机 B.存储器 C.设备 D.文件 740.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在操作系统中采用多道程序设计方式能提高CPU和外部设备的﹎﹎﹎﹎。
A.利用效率 B.可靠性 C.稳定性 D.兼容性 741.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)为了实现多道程序设计，计算机需要有﹎﹎﹎﹎。
A.更大的内存 B.更快的外部设备 C.更快的CPU D.更先进的终端 742.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)多道程序设计系统中，让多个计算问题同时装入计算机系统的主存储器﹎﹎﹎﹎。
A.并发执行 B.顺序执行 C.并行执行 D.同时执行 743.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)从总体上说，多道程序设计技术可﹎﹎﹎﹎单位时间的算题量。
A.增加 B.减少 C.维持 744.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)为了提高计算机的处理机和外部设备的利用率，把多个程序同时放入主存储器，在宏观上并行运行是﹎
﹎﹎﹎。 A.分时操作系统 B.实时操作系统 C.批处理系统 D.多道程序设计
E.并发程序设计 745.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)有一类操作系统的系统响应时间的重要性超过系统资源的利用率，它被广泛地应用于卫星控制、导弹发
射、飞机飞行控制、飞机订票业务等领域是﹎﹎﹎﹎。 A.分时操作系统
B.实时操作系统 C.批处理系统 D.网络操作系统 746.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)操作系统有多种类型：允许多用户将若干个作业提交给计算机系统集中处理的操作系统称为﹎﹎﹎﹎。
A.批处理操作系统 B.分时操作系统 C.实时操作系统 D.网络操作系统 747.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)操作系统有多种类型：允许多个用户以交互方式使用计算机的操作系统，称为﹎﹎﹎﹎。
A.批处理操作系统 B.分时操作系统 C.实时操作系统 D.网络操作系统 748.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)UNIX操作系统是著名的﹎﹎﹎﹎。
A.多道批处理系统 B.分时系统 C.实时系统 D.分布式系统 749.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在设计批处理系统时，首先要考虑的是﹎﹎﹎﹎。
A.灵活性和可适应性 B.交互性和响应时间 C.周转时间和系统吞吐量
D.实时性和可靠性 750.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在设计分时操作系统时，首先要考虑的是﹎﹎﹎﹎。
A.灵活性和可适应性 B.交互性和响应时间 C.周转时间和系统吞吐量
D.实时性和可靠性 751.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在设计实时操作系统时，首先要考虑的是﹎﹎﹎﹎。
A.灵活性和可适应性 B.交互性和响应时间 C.周转时间和系统吞吐量
D.实时性和可靠性 752.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)分时操作系统的主要特征之一是提高﹎﹎﹎﹎。
A.计算机系统的可靠性 B.计算机系统的交互性 C.计算机系统的实时性
D.计算机系统的安全性 753.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)批处理系统的主要缺点是﹎﹎﹎﹎。
A.CPU的利用率不高 B.失去了交互性 C.不具备并行性 D.以上都不是 754.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)分时系统中，为使多个用户能够同时与系统交互，最关键的问题是﹎﹎﹎﹎。
A.计算机具有足够的运行速度 B.内存容量应足够大
C.系统能及时地接收多个用户输入 D.能在一短的时间内，使所有用户程序都能运行
E.能快速进行内外存对换 755.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)实时操作系统对可靠性和安全性要求极高，它﹎﹎﹎﹎。
A.十分注重系统资源的利用率 B.不强调响应速度 C.不强求系统资源的利用率
D.不必向用户反馈信息 756.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)分时系统的响应时间（及时性）主要是根据﹎﹎﹎﹎确定的。
A.时间片大小 B.用户数目 C.计算机运行速度 D.用户所能接受的等待时间
E.控制对象所能接受的时延 757.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)实时系统的响应时间则是由﹎﹎﹎﹎确定的。
A.时间片大小 B.用户数目 C.计算机运行速度 D.用户所能接受的等待时间
E.控制对象所能接受的时延 758.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)分时系统中，当用户数目为100时，为保证响应不超过2秒；此时的时间片最大应为﹎﹎﹎﹎。
A.10ms B.20ms C.50ms D.100ms E.200ms 759.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)假设就绪队列中有10个进程，系统将时间片设为200ms，CPU进行进程切换要花费10ms。
则系统开销所占的比率约为﹎﹎﹎﹎ A.0.5％ B.1％ C.5％ D.10％ 760.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在操作系统中进程是一个具有一定独立功能程序在某个数据集合上的一次﹎﹎﹎﹎。
A.并发活动 B.运行活动 C.单独操作 D.关联操作 761.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在操作系统中，进程是一个﹎﹎﹎﹎概念，而程序是一个静态的概念。
A.组合态 B.关联态 C.运行态 D.等待态 E.静态 F.动态 762.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)操作系统中，进程与程序的重要区别之一是﹎﹎﹎﹎。
A.程序有状态而进程没有 B.进程有状态而程序没有 C.程序可占有资源而进程不可
D. 进程能占有资源而程序不能 763.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)从静态角度看，进程由程序、数据和﹎﹎﹎﹎三部分组成。
A.JCB B.DCB C.PCB D.PMT 764.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在一单处理机系统中，若有5个用户进程，在非管态的某一时刻，处于就绪态的用户进程最多有﹎﹎﹎
﹎个。 A.1 B.2 C.3 D.4 E.5 F.0 765.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在一单处理机系统中，若有5个用户进程，在非管态的某一时刻，处于阻塞态的用户进程最多有﹎﹎﹎
﹎个。 A.1 B.2 C.3 D.4 E.5 F.0 766.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)用户可通过系统调用建立和撤消进程，通常用户进程被建立后，﹎﹎﹎﹎。
A.便一直存在于系统中，直到被操作人员撤消
B.随着作业运行正常或不正常结束而撤消 C.随着时间片轮转而撤消与建立
D.随着进程的阻塞或唤醒而撤消与建立 767.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)一个进程释放一种资源将有可能导致一个或几个进程﹎﹎﹎﹎。
A.由就绪变运行 B.由运行变就绪 C.由阻塞变运行 D.由阻塞变就绪 768.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)正在执行的进程由于其时间片完而被暂停执行，此时进程应从运行态变为﹎﹎﹎﹎状态。
A.静止阻塞 B.活动阻塞 C.静止就绪 D.活动就绪 E.执行 769.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)处于静止阻塞状态的进程，在进程等待的事件出现后，应转变为﹎﹎﹎﹎状态。
A.静止阻塞 B.活动阻塞 C.静止就绪 D.活动就绪 E.执行 770.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)若进程正处于运行态时，应终端的请求而暂停下来以便研究其运行情况(执行挂起进程原语)，这时进
程应转变为﹎﹎﹎﹎状态。 A.静止阻塞 B.活动阻塞 C.静止就绪 D.活动就绪
E.执行 771.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)执行解除挂起进程原语后，如挂起进程处于阻塞状态，则应转变为﹎﹎﹎﹎态。
A.静止阻塞 B.活动阻塞 C.静止就绪 D.活动就绪 E.执行 772.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)对于记录型信号量，在执行一次P操作(wait操作)时，信号量的值应当为减1；当其值为﹎﹎﹎
﹎时，进程应阻塞。 A.大于0 B.小于0 C.大于等于0 D.小于等于0 773.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)对于记录型信号量，在执行V操作(signal操作)时，信号量的值应当加1；当其值为﹎﹎﹎﹎
时，应唤醒阻塞队列中的进程。 A.大于0 B.小于0 C.大于等于0 D.小于等于0 774.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)设两个进程共用一个临界段的互斥信号量mutex，当mutex=-1时表示：﹎﹎﹎﹎。
A.一个进程入了临界段，另一个进程等待 B.没有一个进程进入了临界段
C.只有一个进程进入了临界段 D.两个进程都在等待 775.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)设两个进程共用一个临界段的互斥信号量mutex，当mutex=0时表示：﹎﹎﹎﹎。
A.一个进程入了临界段，另一个进程等待 B.没有一个进程进入了临界段
C.只有一个进程进入了临界段 D.两个进程都在等待 776.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)计算机操作系统中有3个用户进程，若P、V操作的信号量S初值为2，当前值为-1，则表示当前有
﹎﹎﹎﹎进程在等待。 A.1个 B.2个 C.3个 D.0个 777.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)若信号量S的初值为2，且有三个进程共享此信号量，则S的取值范围是﹎﹎﹎﹎。
A.[-3,2] B.[-2,2] C.[-1,2] D.[0,2] E.[-2,1] 778.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)如果有四个进程共享同一程序段，每次允许3个进程进入该程序段，若用PV操作作为同步机制则信号
量S的取值范围是﹎﹎﹎﹎。 A.4，3，2，1，0 B.3，2，1，0，-1 C.2，1，0，-1，-2
D.1，0，-1，-2，-3 779.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)进程从阻塞状态进入就绪状态可能是由于﹎﹎﹎﹎.
A.现运行进程运行结束 B.现运行进程执行了P操作 C.现运行进程执行了V操作
D.现运行进程时间片用完 780.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)进程从运行态进入阻塞态可能是由于﹎﹎﹎﹎.
A.现运行进程运行结束 B.现运行进程执行了P操作 C.现运行进程执行了V操作
D.现运行进程时间片用完 781.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)实现进程互斥时，用﹎﹎﹎﹎对应，对同一个信号量调用PV操作实现互斥。
A.一个信号量与一个临界区 B.一个信号量与一个相关临界区
C.一个信号量与一组相关临界区 D.一个信号量与一个消息 782.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)实现进程同步时，每一个（类）消息与一个信号量对应，进程﹎﹎﹎﹎可把不同的消息发送出去。
A.在同一信号量上调用P操作 B.在不同信号量上调用P操作
C.在同一信号量上调用V操作 D.在不同信号量上调用V操作 783.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在直接通信时，用send(N,M)原语发送信件，其中N表示﹎﹎﹎﹎。
A.发送信件的进程名 B.接收信件的进程名 C.信箱名 D.信件内容 784.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)操作系统的主要性能参数：﹎﹎﹎﹎指的是单位时间内系统处理的作业量。
A.周转时间 B.处理时间 C.消逝时间 D.利用率 E.生产率 F.吞吐量 785.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)操作系统的主要性能参数：﹎﹎﹎﹎指的是从作业或命令的输入到其结束的间隔时间，在分析性能时常
用其倒数。 A.周转时间 B.处理时间 C.消逝时间 D.利用率 E.生产率 F.吞吐量
786.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)操作系统主要性能参数:
﹎﹎﹎﹎指的是在一个给定的时间内，系统的一个指定成份被使用的时间比例。
A.周转时间 B.处理时间 C.消逝时间 D.利用率 E.生产率 F.吞吐量 787.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在所学的调度算法中，能兼顾作业等待时间和作业执行时间调度算法是﹎﹎﹎﹎。
A.FCFS调度算法 B.短作业优先调度算法 C.时间片轮转法
D.多级反馈队列调度算法 E.高响应比优先算法 F.基于优先权的剥夺调度算法
788.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在所学的调度算法中，最有利于提高资源的使用率、能使短作业、长作业及交互作业用户都比较满意的
调度算法是﹎﹎﹎﹎。 A.FCFS调度算法 B.短作业优先调度算法 C.时间片轮转法
D.多级反馈队列调度算法 E.高响应比优先算法 F.基于优先权的剥夺调度算法
789.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在所学的调度算法中，对所有进程和作业都是公平合理的调度算法是﹎﹎﹎﹎。
A.FCFS调度算法 B.短作业优先调度算法 C.时间片轮转法
D.多级反馈队列调度算法 E.高响应比优先算法 F.基于优先权的剥夺调度算法
790.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在所学的调度算法中，最有利于提高系统吞吐量的作业调度算法是﹎﹎﹎﹎。
A.FCFS调度算法 B.短作业优先调度算法 C.时间片轮转法
D.多级反馈队列调度算法 E.高响应比优先算法 F.基于优先权的剥夺调度算法
791.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在所学的调度算法中，为实现人机交互作用应采用调度算法是﹎﹎﹎﹎。
A.FCFS调度算法 B.短作业优先调度算法 C.时间片轮转法
D.多级反馈队列调度算法 E.高响应比优先算法 F.基于优先权的剥夺调度算法
792.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在所学的调度算法中，能对紧急作业进行及时处理的调度算法是﹎﹎﹎﹎。
A.FCFS调度算法 B.短作业优先调度算法 C.时间片轮转法
D.多级反馈队列调度算法 E.高响应比优先算法 F.基于优先权的剥夺调度算法
793.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在调度算法中，有二种调度算法是照顾短作业用户，其中﹎﹎﹎﹎调度算法中采用作业估计运行时间。
A.FCFS调度算法 B.短作业优先调度算法 C.时间片轮转法
D.多级反馈队列调度算法 E.高响应比优先算法 F.基于优先权的剥夺调度算法
794.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)关于优先权大小的论述中，第﹎﹎﹎﹎条是正确的论述。
A.计算型作业的优先权，应高于I/O型作业的优先权。
B.用户进程的优先权，应高于系统进程的优先权。
C.长作业的优先权，应高于短作业的优先权。
D.资源要求多的作业，其优先权应高于资源要求少的作业。
E.在动态优先权中，随着作业等待时间的增加，其优先权将随之下降。
F.在动态优先权中，随着进程执行时间的增加，其优先权降低。 795.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在采用抢占式优先权进程调度算法的系统中，正在运行进程的优先权是﹎﹎﹎﹎。
A.系统中优先权最高的进程 B.比就绪队列中进程优先权高的进程
C.比就绪队列中进程优先权不一定高的进程 796.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)操作系统中,死锁"的概念是指﹎﹎﹎﹎。"
A.程序死循环 B.硬件发生故障
C.两个或多个并发进程各自占有某种资源而又都等待别的进程释放它们所占有的资源
D.系统停止运行 797.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)产生死锁的基本原因是系统资源不足和﹎﹎﹎﹎。
A.进程推进顺序非法 B.进程调度不当 C.系统中进程太多 D.CPU运行太快 798.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)预防死锁的论述中，﹎﹎﹎﹎条是正确的论述。
A.由于产生死锁的基本原因是系统资源不足，因而预防死锁的有效方法，是根据系统规模，配置足够的系统资源。
B.由于产生死锁的另一种基本原因是进程推进顺序不当，因而预防死锁的有效方法，是使进程的推进顺序合法。
C.因为只要系统不进入不安全状态，便不会产生死锁，故预防死锁的有效方法，是防止系统进入不安全状态。
D.可以通过破坏产生死锁的四个必要条件之一或其中几个的方法，来预防发生死锁。
799.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)对资源采用按序分配策略能达到﹎﹎﹎﹎的目的。
A.防止死锁 B.避免死锁 C.检测死锁 D.解除死锁 800.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)把逻辑地址转变为内存的物理地址的过程称作﹎﹎﹎﹎。
A.编译 B.连接 C.运行 D.重定位 801.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)动态重定位是在作业的﹎﹎﹎﹎中进行的。
A.编译过程 B.装入过程 C.修改过程 D.执行过程 802.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在可变分区存储管理方案中需要一对界地址寄存器，其中﹎﹎﹎﹎作为重定位（地址映射）使用。
A.逻辑地址寄存器 B.长度寄存器 C.物理地址寄存器 D.基址寄存器 803.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)分页系统中信息的逻辑地址到物理地址的变换是由﹎﹎﹎﹎决定。
A.段表 B.页表 C.物理结构 D.重定位寄存器 804.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)分段系统中信息的逻辑地址到物理地址的变换是由﹎﹎﹎﹎决定。
A.段表 B.页表 C.物理结构 D.重定位寄存器 805.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在最佳适应算法中是按﹎﹎﹎﹎顺序形成空闲分区链。
A.空闲区首址递增 B.空闲区首址递减 C.空闲区大小递增 D.空闲区大小递减 806.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在首次适应算法中，要求空闲分区按﹎﹎﹎﹎顺序链接成空闲分区链。
A.空闲区首址递增 B.空闲区首址递减 C.空闲区大小递增 D.空闲区大小递减 807.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在可变分区式内存管理中，倾向于优先使用低址部分空闲区的算法是﹎﹎﹎﹎。
A.最佳适应算法 B.最坏适应算法 C.首次适应算法 D.循环适应算法 808.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在可变分区式内存管理中，能使内存空间中空闲区分布较均匀的算法是﹎﹎﹎﹎。
A.最佳适应算法 B.最坏适应算法 C.首次适应算法 D.循环适应算法 809.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在可变式分区分配方案中，某一作业完成后，系统收回其主存空间，并与相邻空闲区合并，为此需修改
空闲区表，造成空闲区表项数减1的情况是﹎﹎﹎﹎。
A.无上邻（前邻、低址）空闲区，也无下邻（后邻、高址）空闲区
B.有上邻（前邻、低址）空闲区，但无下邻（后邻、高址）空闲区
C.有下邻（后邻、高址）空闲区，但无上邻（前邻、低址）空闲区
D.有上邻（前邻、低址）空闲区，也有下邻（后邻、高址）空闲区 E.不可能的 810.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在可变式分区分配方案中，某一作业完成后，系统收回其主存空间，并与相邻空闲区合并，为此需修改
空闲区表，造成空闲区表项数不变、某项的始址改变、长度增加的情况是﹎﹎﹎﹎。
A.无上邻（前邻、低址）空闲区，也无下邻（后邻、高址）空闲区
B.有上邻（前邻、低址）空闲区，但无下邻（后邻、高址）空闲区
C.有下邻（后邻、高址）空闲区，但无上邻（前邻、低址）空闲区
D.有上邻（前邻、低址）空闲区，也有下邻（后邻、高址）空闲区 E.不可能的 811.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在可变式分区分配方案中，某一作业完成后，系统收回其主存空间，并与相邻空闲区合并，为此需修改
空闲区表，造成空闲区表项数增1的情况是﹎﹎﹎﹎。
A.无上邻（前邻、低址）空闲区，也无下邻（后邻、高址）空闲区
B.有上邻（前邻、低址）空闲区，但无下邻（后邻、高址）空闲区
C.有下邻（后邻、高址）空闲区，但无上邻（前邻、低址）空闲区
D.有上邻（前邻、低址）空闲区，也有下邻（后邻、高址）空闲区 E.不可能的 812.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在可变式分区分配方案中，某一作业完成后，系统收回其主存空间，并与相邻空闲区合并，为此需修改
空闲区表，造成空闲区表项数不变、某项的始址不变、长度增加的情况是﹎﹎﹎﹎。
A.无上邻（前邻、低址）空闲区，也无下邻（后邻、高址）空闲区
B.有上邻（前邻、低址）空闲区，但无下邻（后邻、高址）空闲区
C.有下邻（后邻、高址）空闲区，但无上邻（前邻、低址）空闲区
D.有上邻（前邻、低址）空闲区，也有下邻（后邻、高址）空闲区 E.不可能的 813.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)当存储器采用段页式管理时，主存被划分为定长的﹎﹎﹎﹎。
A.段 B.页 C.区域 D.块 814.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)当存储器采用段页式管理时，程序按逻辑被划分成﹎﹎﹎﹎。
A.段 B.页 C.区域 D.块 815.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在存储器采用段页式管理的多道程序环境下，每道程序都有对应的﹎﹎﹎﹎。
A.一个段表和一个页表 B.一个段表和一组页表 C.一组段表和一个页表
D.一组段表和一组页表 816.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在分页式存储管理系统中时，每次从主存中取指令或取操作数，至少要访问﹎﹎﹎﹎主存。
A.1次 B.2次 C.3次 D.4次 E.0次 817.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在分段式存储管理系统中时，每次从主存中取指令或取操作数，至少要访问﹎﹎﹎﹎主存。
A.1次 B.2次 C.3次 D.4次 E.0次 818.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在段页式存储管理系统中时，每次从主存中取指令或取操作数，至少要访问﹎﹎﹎﹎主存。
A.1次 B.2次 C.3次 D.4次 E.0次 819.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)使每道程序能在不受干扰的环境下运行，主要是通过﹎﹎﹎﹎功能实现的。
A.内存分配 B.内存保护 C.地址映射 D.对换 E.内存扩充 820.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在可变分区存储管理方案中需要一对界地址寄存器，其中﹎﹎﹎﹎是作为存贮保护使用。
A.逻辑地址寄存器 B.长度寄存器 C.物理地址寄存器 D.基址寄存器 821.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在分页式存储管理中用作存贮保护的是﹎﹎﹎﹎。
A.页表长度 B.页表始址 C.页长(大小) D.重定位寄存器 822.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在分段式存储管理中用作存贮保护的首先是﹎﹎﹎﹎。
A.段表长度 B.段表始址 C.段长 D.重定位寄存器 823.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)用外存换内存是以牺牲程序运行时间为代价的。为提高CPU有效利用率，避免内外存的频繁交换，虚
拟存储技术常用某种页面淘汰策略来选择换出内存的页面，它的基础是程序的﹎﹎﹎﹎。
A.完整性 B.局部性 C.递归性 D.正确性 824.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在下面关于虚拟存储器的叙述中，正确的是：﹎﹎﹎﹎。
A.要求程序运行前必须全部装入内存且在运行过程中一直驻留在内存
B.要求程序运行前不必全部装入内存且在运行过程中不必一直驻留在内存
C.要求程序运行前不必全部装入内存但是在运行过程中必须一直驻留在内存
D.要求程序运行前必须全部装入内存但在运行过程中不必一直驻留在内存 825.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)虚拟存储器的作用是允许﹎﹎﹎﹎。
A.直接使用外存代替内存 B.添加比地址字长允许的更多内存容量
C.程序直接访问比内存更大的地址空间 D.提高内存的访问速度 826.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)由于内存大小有限，为使得一个或多个作业能在系统中运行，常需要用外存来换取内存。其中在作业内
部对内外进行交换的技术称为 ﹎﹎﹎﹎技术。 A.SPOOLING B.SWAPPING
C.虚拟存储 D.虚拟机 E.进程管理 F.设备管理 827.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在请求分页内存管理的页表表项中，其中访问位供﹎﹎﹎﹎时参考。
A.分配页面 B.置换算法 C.程序访问 D.换出页面 E.调入页面 828.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在请求分页内存管理的页表表项中，其中修改位供﹎﹎﹎﹎时参考。
A.分配页面 B.置换算法 C.程序访问 D.换出页面 E.调入页面 829.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在请求分页内存管理的页表表项中，其中状态位供﹎﹎﹎﹎时参考。
A.分配页面 B.置换算法 C.程序访问 D.换出页面 E.调入页面 830.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在请求分页内存管理的页表表项中，其中外存始址供﹎﹎﹎﹎时参考。
A.分配页面 B.置换算法 C.程序访问 D.换出页面 E.调入页面 831.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在请求调页系统中有着多种置换算法：选择在以后不再使用的页面予以淘汰的算法称为﹎﹎﹎﹎。
A.FIFO算法 B.OPT算法 C.LRU算法 D.NRU算法 E.LFU算法 832.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在请求调页系统中有着多种置换算法：选择自上次访问以来所经历时间最长的页面予以淘汰的算法称为
﹎﹎﹎﹎。 A.FIFO算法 B.OPT算法 C.LRU算法 D.NRU算法 E.LFU算法 833.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在请求调页系统中有着多种置换算法：选择最先进入内存的页面予以淘汰的算法称为
﹎﹎﹎﹎。 A.FIFO算法 B.OPT算法 C.LRU算法 D.NRU算法 E.LFU算法 834.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在请求调页系统中有着多种置换算法：选择自某时刻开始以来，访问次数最少的页面予以淘汰的算法称
为﹎﹎﹎﹎。 A.FIFO算法 B.OPT算法 C.LRU算法 D.NRU算法 E.LFU算法 835.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)下面﹎﹎﹎﹎种页面置换算法会产生Belady异常现象？
A.先进先出页面置换算法（FIFO） B.最近最久未使用页面置换算法（LRU）
C.最不经常使用页面置换算法（LFU） D.最佳页面置换算法（OPT）
E.最近未用页面置换算法（NRU）(Clock) 836.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在请求分页管理中，若采用先进先出（FIFO）页面置换算法，可能会产生“Belady异常”，
“Belady异常”指的是﹎﹎﹎﹎。 A.频繁地出页入页的现象
B.分配的页面数增加，缺页中断的次数也可能增加
C.进程交换的信息量过大，导致系统工作区不足
D.分配给进程的内存空间不足使进程无法正常工作 837.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在虚拟存储器系统中常使用联想存储器进行管理，它是﹎﹎﹎﹎寻址的。
A.按地址 B.按内容 C.寄存器 D.计算 838.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)下列关于虚拟存储器的论述中，正确的论述﹎﹎﹎﹎。
A.在请求段页式系统中，以页为单位管理用户的虚空间，以段为单位管理内存空间。
B.在请求段页式系统中，以段为单位管理用户的虚空间，以页为单位管理内存空间。
C.为提高请求分页系统中内存的利用率，允许用户使用不同大小的页面。
D.实现虚拟存储器的最常用的算法是最佳适应算法OPT。 839.
(20150309\_操作系统原理习题集及答案\_笔试必需品\_doc)在虚拟分页存贮管理系统中，若进程访问的页面不在主存，且主存中没有可用的空闲块时，系统正确的
处理顺序为﹎﹎﹎﹎。 A.决定淘汰页/页面调出/缺页中断/页面凋入
B.决定淘汰页/页面调入/缺页中断/页面凋出
C.缺页中断/决定淘汰页/页面调出/页面凋入
D.缺页中断/决定淘汰页/页面调入/页面凋出 840.
(20140606-期末考试试题&参考答案.docx)信号
(12分)在Linux/Unix中，一个用户从shell中执行了一个运行时间较长且不知何时能够结束的程序，Linux
/UNIX可以让用户根据个人需求随时通过敲击Ctrl-
C组合键来终止这个程序的执行。请回答如下问题。要求设计应该具有通用性，列出的设计实现不超过6点，每点不超过4行。问题的执行流程描述不超过8行。
1）如果要在ucore中实现Linux/UNIX同样的功能，请问应该如何修改ucore来支持此功能？
2）uCore的shell也是一个程序，我们希望避免这个shell在执行中被用户敲入的Ctrl-
C所终止，请问在保证1）的要求请看下，如何修改ucore和shell来支持此功能？
3）说明在你的设计下，shell和某一可被终止程序在执行过程中，用户敲击Ctrl-C后，uCore
和shell的执行流程。 841. (20140606-期末考试试题&参考答案.docx)IPC
(15分)在具备了执行用户态进程的能力之后，uCore要为这些进程提供的一个重要服务，是用户进程之间的消息传递机制（Inter-Process
Communication，简写为IPC）。现在，我们要为uCore实现以下两个系统调用，以实现一种同步的IPC机制（暂不考虑超时等功能）：
int sys\_send\_event(int pid, int event); 参数：pid -
该消息的目标进程的进程号； event – 消息内容，用一个整型表示。
返回值：消息成功发送时，返回0；否则，返回相应的错误代码。 int
sys\_recv\_event(int \*pid, int \*event); 参数：pid -
函数返回时，\*pid保存发出消息的进程的进程号，可以为NULL； event –
函数返回时，\*event保存消息内容，可以为NULL。
返回值：消息成功接收时，返回0；否则，返回相应的错误代码。
1）以下是一个基于上述IPC机制求质数的用户程序： \#include \#include
\#include \#include const int total = 1000; void primeproc(void) { int
index = 0, this, num, pid = 0; top: recv\_event(NULL, &this;);
cprintf("%d is a primer.\\n", this); while (recv\_event(NULL, &num;) ==
0) { if ((num % this) == 0) { continue; } if (pid == 0) { if (index + 1
== total) { goto out; } if ((pid = fork()) == 0) { index++; goto top; }
if (pid < 0) { goto out; } } if (send\_event(pid, num) != 0) { goto out;
} } out: cprintf("[%04d] %d quit.\\n", getpid(), index); } int
main(void) { int i, pid; unsigned int time = gettime\_msec(); if ((pid =
fork()) == 0) { primeproc(); exit(0); } assert(pid \> 0); for (i = 2;;
i++) { if (send\_event(pid, i) != 0) { break; } } cprintf("use %d
msecs.\\n", gettime\_msec() - time); cprintf("primer3 pass.\\n"); return
0; } 简述这个程序是如何判断并输出前五个质数的。
2）给出一种基于等待队列的上述IPC机制的实现方案。 842.
(20140606-期末考试试题&参考答案.docx)信号量实现
(10分)在uCore中，信号量的定义如下 typedef struct { int value;
wait\_queue\_t wait\_queue; } semaphore\_t;
\_\_up函数是信号量V操作的具体实现函数 static \_\_noinline void
\_\_up(semaphore\_t \*sem, uint32\_t wait\_state) { bool intr\_flag;
local\_intr\_save(intr\_flag); { wait\_t \*wait;
if((wait=wait\_queue\_first(&(sem-\>wait\_queue)))==NULL){
\_\_\_\_\_\_\_\_; } else { wakeup\_wait(&(sem-\>wait\_queue), wait,
wait\_state, 1); } } local\_intr\_restore(intr\_flag); }
1）补全程序中的空行\_\_\_\_\_\_\_\_。
2）信号量的value值\>0时，表示\_\_\_\_\_\_\_\_的数量;value值<0时，表示\_\_\_\_\_\_\_\_的数量。
3）local\_intr\_save和local\_intr\_restore这两个函数的功能分别是什么？为什么要调用这两个函数？
843. (20140606-期末考试试题&参考答案.docx)信号量应用
(15分)假设一个MOOC网站有1、2、3三种不同的课程视频可由学生选择学习，网站播放课程视频的规则为：
1）任一时刻最多只能播放一种课程视频，正在播放的课程视频是自动循环播放的，最后一个学生主动离开时结束当前课程视频的播放；
2）选择当前正在播放的课程视频的学生可立即进入播放页面，允许同时有多位选择同一种课程视频的学生观看，同时观看的学生数量不受限制；
3）等待观看其它课程视频的学生按到达顺序排队，当一种新的课程视频开始放映时，所有等待观看该课程视频的学生可依次序进入播放页面同时观看。
用一个进程代表一个学生，要求：用信号量的P、V操作实现上述规则，并给出信号量的定义和初始值。
844. (20140606-期末考试试题&参考答案.docx)调度算法
(12分)在lab6中，我们实现了Stride
Scheduling调度算法，并声称它对“进程的调度次数正比于其优先级”。对于优先级为2、3、5、7的4个进程，选取210为MAX\_STRIDE，则：
1）简要描述Stride Scheduling调度算法。
2）四个进程的步长分别为：\_\_\_\_\_\_\_\_、\_\_\_\_\_\_\_\_、\_\_\_\_\_\_\_\_、\_\_\_\_\_\_\_\_。
3）假设四个进程的初始stride值均为0，证明：总有一个时刻，四个进程的stride值都是210，且此时四个进程被调度的次数正比于其优先级。
845. (20140606-期末考试试题&参考答案.docx)死锁
(12分)死锁是操作系统中资源共享时面临的一个难题。请回答下列与死锁相关的问题。
1）设系统中有下述解决死锁的方法： a)银行家算法；
b)检测死锁，终止处于死锁状态的进程，释放该进程占有的资源； c)资源预分配。
简述哪种办法允许最大的并发性，即哪种办法允许更多的进程无等待地向前推进？请按“并发性”从大到小对上述三种办法进行排序。
2）假设一个使用银行家算法的系统，当前有5个进程P0, P1, P2, P3,
P4，系统中有三类资源A、B、C，假设在某时刻有如下状态： | |Allocation| Max
|Available| | | A | B | C|A|B|C| A | B| C| |P0| 0 | 0 | 3|0|0|4| 1 | 4|
0| |P1| 1 | 0 | 0|1|7|5| | | | |P2| 1 | 3 | 5|2|3|5| | | | |P3| 0 | 0 |
2|0|6|4| | | | |P4| 0 | 0 | 1|0|6|5| | | |
请问当前系统是否出于安全状态？如果系统中的可利用资源为（0, 6,
2），系统是否安全？如果系统处在安全状态，请给出安全序列；如果系统处在非安全状态，请简要说明原因。
846. (20140606-期末考试试题&参考答案.docx)文件系统
(12分)uCore实现了一个简单的文件系统Simple
FS，假设该文件系统现已经装载到一个硬盘中（disk0）, 该硬盘的大小为20M,
目前有三个文件A.txt,B.txt和C.txt存放在该硬盘中，三个文件的大小分别是48K,
1M和4M。
1）简要描述SFS文件系统中文件数据的组织结构（即：SFS文件的数据的存放位置组织方式）。
2）请根据Simple
FS的设计实现情况，画出该文件系统当前在disk0上的布局情况，需要给出相应结构的名称和起始块号。
847. (20140606-期末考试试题&参考答案.docx)VFS
(12分)uCore的文件管理主要由以下四个部分组成：通用文件系统访问接口层,
文件系统抽象层(VFS), 具体文件系统层以及外设接口层，其中VFS层的作用
是用来管理不同的文件系统并向上提供一致的接口给内核其他部分访问，在ucore中我们已经实现了一个具体的文件系统：Simple
FS，并将该文件系统装载到了disk0上，假设ucore又实现了一个文件系统FAT32，并将这个新的文件系统装载到了disk1上。
1）请简单描述一下如何修改VFS层的数据结构使其可以有效的管理上述已安装的具体文件系统。
涉及VFS层的数据结构如下： struct file { enum { FD\_NONE, FD\_INIT,
FD\_OPENED, FD\_CLOSED, } status; bool readable; bool writable; int fd;
off\_t pos; struct inode \*node; atomic\_t open\_count; }; struct inode
{ union { struct device \_\_device\_info; struct sfs\_inode
\_\_sfs\_inode\_info; } in\_info; enum { inode\_type\_device\_info =
0x1234, inode\_type\_sfs\_inode\_info, } in\_type; atomic\_t ref\_count;
atomic\_t open\_count; struct fs \*in\_fs; const struct inode\_ops
\*in\_ops; }; struct fs { union { struct sfs\_fs \_\_sfs\_info; }
fs\_info; enum { fs\_type\_sfs\_info, } fs\_type; int
(\*fs\_sync)(struct fs \*fs); struct inode \*(\*fs\_get\_root)(struct fs
\*fs); int (\*fs\_unmount)(struct fs \*fs); void (\*fs\_cleanup)(struct
fs \*fs); }; struct inode\_ops { unsigned long vop\_magic; int
(\*vop\_open)(struct inode \*node, uint32\_t open\_flags); int
(\*vop\_close)(struct inode \*node); int (\*vop\_read)(struct inode
\*node, struct iobuf \*iob); int (\*vop\_write)(struct inode \*node,
struct iobuf \*iob); int (\*vop\_getdirentry)(struct inode \*node,
struct iobuf \*iob); int (\*vop\_create)(struct inode \*node, const char
\*name, bool excl, struct inode \*\*node\_store); int
(\*vop\_lookup)(struct inode \*node, char \*path, struct inode
\*\*node\_store); …… };
2）两个具体文件系统均已实现了对数据文件的4种基本操作。现在有某个用户态进程执行了一个copy（source\_path,
dest\_path,...）函数，
该函数是把disk1根目录下的一个文件A.txt拷贝到了disk0的根目录下（不用考虑文件的大小），请结合ucore中对数据文件的操作流程描述一下这个函数的
执行过程。 848. (20140410-2-期中考试试题v4a答案.docx)页表
（20分）内存管理（Memory
Management）是操作系统的重要职能之一，现代操作系统基于硬件所提供的内存管理单元（Memory
Management
Unit），可以为应用程序提供相互隔离的虚拟地址空间，同时对物理内存进行高效的管理。在32位x86架构提供的MMU中，除了传统的段模式
以外，也同时包括页管理机制。页管理所需要的硬件支持包括两个部分：一是完成虚拟地址到物理地址映射的页表，二是页异常（Page
Fault）。 1)
在32位的x86系统中，一般使用二级页表，分别用虚拟地址的31-22位和21-12位作为页表内相应页表项的偏移，此时一个物理页的大小为\_\_\_(1a)\_
\_\_\_K；实际上，x86系统同样允许只使用一级页表，页表项偏移仍然取虚拟地址的31-22位，此时一个物理页的大小为\_\_(1b)\_\_K。
2)
发生页异常时，硬件会保存执行时的上下文并关闭中断，然后跳转到操作系统设置好的页错误处理例程，这里的“上下文”应该包括（在你认为需要保存的寄存器前打勾，
并简述如果不保存会产生什么问题）： (2a)（ ）指令计数器（CS, EIP）
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
(2b)（ ）堆栈指针（SS, ESP）
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
(2c)（ ）通用寄存器（EAX、EBX、……）
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
(2d)（ ）执行时标志位寄存器（EFLAGS）
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
(2e)（ ）控制寄存器（CR0、CR3、……）
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
3) 页异常处理完毕后，返回用户程序继续执行，此时执行的第一条用户指令为（ ）
A. 触发页异常指令的上一条指令 B. 触发页异常的指令 C.
触发页异常指令的下一条指令 4)
除了维护基本的地址映射关系外，x86页表的每一个页表项还包括一些其它配置和信息位，例如该页是否可写（W），是否可以在Ring
3访问（U），是否曾被访
问过（A），以及是否曾被写过（D）。请根据x86页表对这些位的定义，在下表中填写在页表项的几种情况下进行各种操作时，页表项的内容会如何变化。（只需写出会变化
的位和/或会产生的事件，如缺页异常，形式可参考表中已填入的部分内容） | |W=0
U=0 A=0 D=0|W=1 U=0 A=0 D=0|W=0 U=1 A=1 D=0|W=1 U=1 A=1 D=1| |在ring0读|
| | |无变化 | |在ring0写| |A→1，D→1 | | | |在ring3读| | | | | |在ring3写|
| |缺页异常 | | 849. (20140410-2-期中考试试题v4a答案.docx)进程管理
（20分）进程/线程管理（Process/Thread
Management）是操作系统的重要职能之一，现代操作系统基于硬件所提供的内存管理单元（Memory
Management
Unit），可以为进程提供相互隔离的虚拟地址空间，为线程提供共享的虚拟地址空间。以下我们对32位x86架构的uCore所实现的进程管理机制进行讨论。
1)
在ucore中，管理一个用户进程的进程控制块数据结构为proc\_struct，管理一个内核线程的线程控制块数据结构为\_\_(1a)\_\_。在proc\_st
ruct中，为了有效管理用户进程，请问可唯一标识一个进程的field是\_\_(1b)\_\_；用户进程控制块与内核线程控制块相比，数据内容肯定不同的field包括
\_\_(1c)\_\_、\_\_(1d)\_\_、\_\_(1e)\_\_。 2)
在ucore中，一个用户进程具有“自己”的用户栈，当用户进程通过系统调用进入到内核态开始继续执行ucore指令时，进程的页表起始地址是否会改变？\_\_(
2a)\_\_。当用户进程在用户态执行时，硬件产生了一个中断，打断了用户进程的执行，这时CPU将开始执行中断服务例程，，这个时候的页表起始地址是否已经不是被打断
的用户进程的页表起始地址了？\_\_(2b)\_。 3)
在ucore中，当用户进程访问的某个虚拟地址的映射关系不在TLB中时，是否一定会产生异常？\_\_(3a)\_\_。当用户进程访问的某个虚拟地址在其页表中没有
valid的页表项，是否一定回产生异常？\_\_(3b)\_\_。 4)
在ucore中，当用户进程A与用户进程B进行进程上下文切换时，需要保存相关的寄存器内容，请问是否需要保存CS？\_\_(4a)\_\_。是否需要保存EIP？\_
\_(4b)\_。是否需要保存SS？\_\_(4c)\_\_。是否需要保存ESP？\_\_(4d)\_\_。 5)
在ucore中，如果当父进程创建子进程时，如果没有COW机制，则fork系统调用会创建新的子进程的进程控制块，创建新的子进程的页表，并把父进程的代码段
和数据段所占的物理内存空间复制一份到新的物理内存空间，并更新子进程页表。如果采用了COW机制，则fork系统调用的处理过程是？（用不超过6行文字进行描述）
850. (20140410-2-期中考试试题v4a答案.docx)系统启动
（15分）Bootloader是ucore操作系统启动中的很重要的一部分，Bootloader是由BIOS代码读入内存，然后跳转到它开始执行的。请参考boo
tasm.S和bootmain.c的源代码，回答下列问题： 1)
Bootloader包含在硬盘主引导扇区中，硬盘主引导扇区的主要特征有哪些？ 2)
Bootloader执行的第一条指令是哪一行？Bootloader从实模式进入保护模式后执行的第一条指令是哪一行？为什么要转换到保护模式？
3)
Bootloader在完成从硬盘扇区读入ucore内核映像后是如何跳转到ucore内核代码的？
// =========/libs/elf.h========= \#ifndef \_\_LIBS\_ELF\_H\_\_ \#define
\_\_LIBS\_ELF\_H\_\_ \#include \#define ELF\_MAGIC 0x464C457FU //
"\\x7FELF" in little endian /\* file header \*/ struct elfhdr {
uint32\_t e\_magic; // must equal ELF\_MAGIC uint8\_t e\_elf[12];
uint16\_t e\_type; // 1=relocatable, 2=executable, 3=shared object,
4=core image uint16\_t e\_machine; // 3=x86, 4=68K, etc. uint32\_t
e\_version; // file version, always 1 uint32\_t e\_entry; // entry point
if executable uint32\_t e\_phoff; // file position of program header or
0 uint32\_t e\_shoff; // file position of section header or 0 uint32\_t
e\_flags; // architecture-specific flags, usually 0 uint16\_t e\_ehsize;
// size of this elf header uint16\_t e\_phentsize; // size of an entry
in program header uint16\_t e\_phnum; // number of entries in program
header or 0 uint16\_t e\_shentsize; // size of an entry in section
header uint16\_t e\_shnum; // number of entries in section header or 0
uint16\_t e\_shstrndx; // section number that contains section name
strings }; /\* program section header \*/ struct proghdr { uint32\_t
p\_type; // loadable code or data, dynamic linking info,etc. uint32\_t
p\_offset; // file offset of segment uint32\_t p\_va; // virtual address
to map segment uint32\_t p\_pa; // physical address, not used uint32\_t
p\_filesz; // size of segment in file uint32\_t p\_memsz; // size of
segment in memory (bigger if contains bss） uint32\_t p\_flags; //
read/write/execute bits uint32\_t p\_align; // required alignment,
invariably hardware page size }; \#endif /\* !\_\_LIBS\_ELF\_H\_\_ \*/
//=========/boot/bootasm.S========= \#include \# Start the CPU: switch
to 32-bit protected mode, jump into C. \# The BIOS loads this code from
the first sector of the hard disk into \# memory at physical address
0x7c00 and starts executing in real mode \# with %cs=0 %ip=7c00. .set
PROT\_MODE\_CSEG, 0x8 \# kernel code segment selector .set
PROT\_MODE\_DSEG, 0x10 \# kernel data segment selector .set CR0\_PE\_ON,
0x1 \# protected mode enable flag \# start address should be 0:7c00, in
real mode, the beginning address of the running bootloader .globl start
start: .code16 \# Assemble for 16-bit mode cli \# Disable interrupts cld
\# String operations increment \# Set up the important data segment
registers (DS, ES, SS). xorw %ax, %ax \# Segment number zero movw %ax,
%ds \# -\> Data Segment movw %ax, %es \# -\> Extra Segment movw %ax, %ss
\# -\> Stack Segment \# Enable A20: \# For backwards compatibility with
the earliest PCs, physical \# address line 20 is tied low, so that
addresses higher than \# 1MB wrap around to zero by default. This code
undoes this. seta20.1: inb $0x64, %al \# Wait for not busy testb $0x2,
%al jnz seta20.1 movb $0xd1, %al \# 0xd1 -\> port 0x64 outb %al, $0x64
seta20.2: inb $0x64, %al \# Wait for not busy testb $0x2, %al jnz
seta20.2 movb $0xdf, %al \# 0xdf -\> port 0x60 outb %al, $0x60 \# Switch
from real to protected mode, using a bootstrap GDT \# and segment
translation that makes virtual addresses \# identical to physical
addresses, so that the \# effective memory map does not change during
the switch. lgdt gdtdesc movl %cr0, %eax orl $CR0\_PE\_ON, %eax movl
%eax, %cr0 \# Jump to next instruction, but in 32-bit code segment. \#
Switches processor into 32-bit mode. ljmp $PROT\_MODE\_CSEG, $protcseg
.code32 \# Assemble for 32-bit mode protcseg: \# Set up the
protected-mode data segment registers movw $PROT\_MODE\_DSEG, %ax \# Our
data segment selector movw %ax, %ds \# -\> DS: Data Segment movw %ax,
%es \# -\> ES: Extra Segment movw %ax, %fs \# -\> FS movw %ax, %gs \#
-\> GS movw %ax, %ss \# -\> SS: Stack Segment \# Set up the stack
pointer and call into C. The stack region is from 0--start(0x7c00) movl
$0x0, %ebp movl $start, %esp call bootmain \# If bootmain returns (it
shouldn't), loop. spin: jmp spin \# Bootstrap GDT .p2align 2 \# force 4
byte alignment gdt: SEG\_NULLASM \# null seg SEG\_ASM(STA\_X|STA\_R,
0x0, 0xffffffff) \# code seg for bootloader and kernel SEG\_ASM(STA\_W,
0x0, 0xffffffff) \# data seg for bootloader and kernel gdtdesc: .word
0x17 \# sizeof(gdt) - 1 .long gdt \# address gdt
//=========/boot/bootmain.c========= \#include \#include \#include /\*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\* This a dirt simple boot loader, whose sole job is to boot \* an ELF
kernel image from the first IDE hard disk. \* \* DISK LAYOUT \* \* This
program(bootasm.S and bootmain.c) is the bootloader. \* It should be
stored in the first sector of the disk. \* \* \* The 2nd sector onward
holds the kernel image. \* \* \* The kernel image must be in ELF format.
\* \* BOOT UP STEPS \* \* when the CPU boots it loads the BIOS into
memory and executes it \* \* \* the BIOS intializes devices, sets of the
interrupt routines, and \* reads the first sector of the boot
device(e.g., hard-drive) \* into memory and jumps to it. \* \* \*
Assuming this boot loader is stored in the first sector of the \*
hard-drive, this code takes over... \* \* \* control starts in bootasm.S
-- which sets up protected mode, \* and a stack so C code then run, then
calls bootmain() \* \* \* bootmain() in this file takes over, reads in
the kernel and jumps to it. \* \*/ \#define SECTSIZE 512 \#define ELFHDR
((struct elfhdr \*)0x10000) // scratch space /\* waitdisk - wait for
disk ready \*/ static void waitdisk(void) { while ((inb(0x1F7) & 0xC0)
!= 0x40) /\* do nothing \*/; } /\* readsect - read a single sector at
@secno into @dst \*/ static void readsect(void \*dst, uint32\_t secno) {
// wait for disk to be ready waitdisk(); outb(0x1F2, 1); // count = 1
outb(0x1F3, secno & 0xFF); outb(0x1F4, (secno \>\> 8) & 0xFF);
outb(0x1F5, (secno \>\> 16) & 0xFF); outb(0x1F6, ((secno \>\> 24) & 0xF)
| 0xE0); outb(0x1F7, 0x20); // cmd 0x20 - read sectors // wait for disk
to be ready waitdisk(); // read a sector insl(0x1F0, dst, SECTSIZE / 4);
} /\* \* \* readseg - read @count bytes at @offset from kernel into
virtual address @va, \* might copy more than asked. \* \*/ static void
readseg(uintptr\_t va, uint32\_t count, uint32\_t offset) { uintptr\_t
end\_va = va + count; // round down to sector boundary va -= offset %
SECTSIZE; // translate from bytes to sectors; kernel starts at sector 1
uint32\_t secno = (offset / SECTSIZE) + 1; // If this is too slow, we
could read lots of sectors at a time. // We'd write more to memory than
asked, but it doesn't matter -- // we load in increasing order. for (;
va < end\_va; va += SECTSIZE, secno ++) { readsect((void \*)va, secno);
} } /\* bootmain - the entry of bootloader \*/ void bootmain(void) { //
read the 1st page off disk readseg((uintptr\_t)ELFHDR, SECTSIZE \* 8,
0); // is this a valid ELF? if (ELFHDR-\>e\_magic != ELF\_MAGIC) { goto
bad; } struct proghdr \*ph, \*eph; // load each program segment (ignores
ph flags) ph = (struct proghdr \*)((uintptr\_t)ELFHDR +
ELFHDR-\>e\_phoff); eph = ph + ELFHDR-\>e\_phnum; for (; ph < eph; ph
++) { readseg(ph-\>p\_va & 0xFFFFFF, ph-\>p\_memsz, ph-\>p\_offset); }
// call the entry point from the ELF header // note: does not return
((void (\*)(void))(ELFHDR-\>e\_entry & 0xFFFFFF))(); bad: outw(0x8A00,
0x8A00); outw(0x8A00, 0x8E00); /\* do nothing \*/ while (1); } 851.
(20140410-2-期中考试试题v4a答案.docx)Fork
（15分）进程管理是操作系统提供给应用程序的一种用于进程控制的服务。下面是一个用fork系统调用完成进程创建的程序。试回答下面问题：
1) 描述fork系统调用的功能、调用接口。 2) 补全程序的输出信息。
//=========fork.c========= \#include \#include \#include \#include
\#include \#define DEFAULT\_TIME 5 \#define DEFAULT\_STATUS 0 int main
(int argc, char \*\*argv) { int child\_id; int seconds; int status;
pid\_t whodied; status = DEFAULT\_STATUS; if (argc == 1) seconds =
DEFAULT\_TIME; else seconds = atoi (argv[1]); printf ("Here I am in the
program! Time to wait = %d\\n", seconds); system ("ps -l"); child\_id =
fork(); if (child\_id) { printf ("I'm the parent at Line 33. My parent's
process ID is %d, My process ID is %d, status = %d.\\n", getpid(),
getppid(), status); whodied = wait (&status;); printf ("Child %d exited
", whodied); /\* WIFEXITED evaluates to true when the process exited by
using an exit(2V) call. If WIFEXITED(status) is non-zero, WEXITSTATUS
evaluates to the low-order byte of the argument that the child process
passed to \_exit() (see exit(2V)) or exit(3), or the value the child
process returned from main() (see execve(2V)). \*/ if (!
WIFEXITED(status)) { printf ("abnormally!\\n"); } else { printf ("with
status %d.\\n", WEXITSTATUS(status)); } printf ("I'm the parent at Line
43. My parent's process ID is %d, My process ID is %d, status = %d.\\n",
getpid(), getppid(), WEXITSTATUS(status)); return status; } else {
status = 17; sleep(seconds); printf ("I'm the child. My parent's process
ID is %d, My process ID is %d, status = %d.\\n", getpid(), getppid(),
status); printf ("Bye now!\\n"); return status; } }
fork程序的两次执行时的输出信息 xyong@portal:\~/work$ ./a.out Here I am
in the program! Time to wait = \_\_(1)\_\_ F S UID PID PPID C PRI NI
ADDR SZ WCHAN TTY TIME CMD 0 S 1000 11739 11738 0 80 0 - 6926 wait pts/0
00:00:00 bash 0 S 1000 11862 11739 0 80 0 - 1041 wait pts/0 00:00:00
a.out 0 S 1000 11863 11862 0 80 0 - 1101 wait pts/0 00:00:00 sh 0 R 1000
11864 11863 0 80 0 - 2433 - pts/0 00:00:00 ps I'm the parent at Line 33.
My parent's process ID is \_\_(2)\_\_, My process ID is \_\_(3)\_\_,
status = \_\_(4)\_\_. I'm the child. My parent's process ID is
\_\_(5)\_\_, My process ID is \_\_(6)\_\_, status = \_\_(7)\_\_. Bye
now! Child 11865 exited with status \_\_(8)\_\_. I'm the parent at Line
43. My parent's process ID is \_\_(9)\_\_, My process ID is
\_\_(10)\_\_, status = \_\_(11)\_\_. xyong@portal:\~/work$ ./a.out 3
Here I am in the program! Time to wait = \_\_(12)\_\_ F S UID PID PPID C
PRI NI ADDR SZ WCHAN TTY TIME CMD 0 S 1000 11739 11738 0 80 0 - 6926
wait pts/0 00:00:00 bash 0 S 1000 11866 11739 0 80 0 - 1041 wait pts/0
00:00:00 a.out 0 S 1000 11867 11866 0 80 0 - 1101 wait pts/0 00:00:00 sh
0 R 1000 11868 11867 0 80 0 - 2433 - pts/0 00:00:00 ps I'm the parent at
Line 33. My parent's process ID is \_\_(13)\_\_, My process ID is
\_\_(14)\_\_, status = \_\_(15)\_\_. I'm the child. My parent's process
ID is \_\_(16)\_\_, My process ID is \_\_(17)\_\_, status =
\_\_(18)\_\_. Bye now! Child \_\_(19)\_\_ exited with status
\_\_(20)\_\_. I'm the parent at Line 43. My parent's process ID is
11866, My process ID is \_\_(21)\_\_, status = \_\_(22)\_\_.
xyong@portal:\~/work$ 852. (20140410-2-期中考试试题v4a答案.docx)函数调用
（15分）为实现函数的调用和返回功能，X86指令集中提供了call和ret两条指令。为在操作系统内核执行过程中分析了解函数函数的嵌套调用关系，ucore中实
现了函数print\_stackframe，用于跟踪函数调用堆栈中记录的返回地址。如果能够正确实现此函数，它将在qemu模拟器中得到类似如下的输出：
…… ebp:0x00007b28 eip:0x00100992 args:0x00010094 0x00010094 0x00007b58
0x00100096 kern/debug/kdebug.c:305: print\_stackframe+22 ebp:0x00007b38
eip:0x00100c79 args:0x00000000 0x00000000 0x00000000 0x00007ba8
kern/debug/kmonitor.c:125: mon\_backtrace+10 ebp:0x00007b58
eip:0x00100096 args:0x00000000 0x00007b80 0xffff0000 0x00007b84
kern/init/init.c:48: grade\_backtrace2+33 ebp:0x00007b78 eip:0x001000bf
args:0x00000000 0xffff0000 0x00007ba4 0x00000029 kern/init/init.c:53:
grade\_backtrace1+38 ebp:0x00007b98 eip:0x001000dd args:0x00000000
0x00100000 0xffff0000 0x0000001d kern/init/init.c:58:
grade\_backtrace0+23 ebp:0x00007bb8 eip:0x00100102 args:0x0010353c
0x00103520 0x00001308 0x00000000 kern/init/init.c:63:
grade\_backtrace+34 ebp:0x00007be8 eip:0x00100059 args:0x00000000
0x00000000 0x00000000 0x00007c53 kern/init/init.c:28: kern\_init+88
ebp:0x00007bf8 eip:0x00007d73 args:0xc031fcfa 0xc08ed88e 0x64e4d08e
0xfa7502a8 : -- 0x00007d72 – …… 请回答如下问题。 1)
描述函数调用和返回指令的执行过程。 2)
ucore中的函数调用参数是如何从调用函数（caller）传递给被调用函数（callee）的。
3) 补全函数调用堆栈跟踪函数print\_stackframe。
//=========/kern/debug/kdebug.c========= \#include \#include \#include
\#include \#include \#include \#define STACKFRAME\_DEPTH 20 extern const
struct stab \_\_STAB\_BEGIN\_\_[]; // beginning of stabs table extern
const struct stab \_\_STAB\_END\_\_[]; // end of stabs table extern
const char \_\_STABSTR\_BEGIN\_\_[]; // beginning of string table extern
const char \_\_STABSTR\_END\_\_[]; // end of string table /\* debug
information about a particular instruction pointer \*/ struct
eipdebuginfo { const char \*eip\_file; // source code filename for eip
int eip\_line; // source code line number for eip const char
\*eip\_fn\_name; // name of function containing eip int
eip\_fn\_namelen; // length of function's name uintptr\_t eip\_fn\_addr;
// start address of function int eip\_fn\_narg; // number of function
arguments }; /\* \* \* stab\_binsearch - according to the input, the
initial value of \* range [\*@region\_left, \*@region\_right], find a
single stab entry \* that includes the address @addr and matches the
type @type, \* and then save its boundary to the locations that pointed
\* by @region\_left and @region\_right. \* \* Some stab types are
arranged in increasing order by instruction address. \* For example,
N\_FUN stabs (stab entries with n\_type == N\_FUN), which \* mark
functions, and N\_SO stabs, which mark source files. \* \* Given an
instruction address, this function finds the single stab entry \* of
type @type that contains that address. \* \* The search takes place
within the range [\*@region\_left, \*@region\_right]. \* Thus, to search
an entire set of N stabs, you might do: \* \* left = 0; \* right = N -
1; (rightmost stab) \* stab\_binsearch(stabs, &left;, &right;, type,
addr); \* \* The search modifies \*region\_left and \*region\_right to
bracket the @addr. \* \*@region\_left points to the matching stab that
contains @addr, \* and \*@region\_right points just before the next
stab. \* If \*@region\_left \> \*region\_right, then @addr is not
contained in any \* matching stab. \* \* For example, given these N\_SO
stabs: \* Index Type Address \* 0 SO f0100000 \* 13 SO f0100040 \* 117
SO f0100176 \* 118 SO f0100178 \* 555 SO f0100652 \* 556 SO f0100654 \*
657 SO f0100849 \* this code: \* left = 0, right = 657; \*
stab\_binsearch(stabs, &left;, &right;, N\_SO, 0xf0100184); \* will exit
setting left = 118, right = 554. \* \*/ static void
stab\_binsearch(const struct stab \*stabs, int \*region\_left, int
\*region\_right, int type, uintptr\_t addr) { …… } /\* \* \*
debuginfo\_eip - Fill in the @info structure with information about \*
the specified instruction address, @addr. Returns 0 if information \*
was found, and negative if not. But even if it returns negative it \*
has stored some information into '\*info'. \* \*/ int
debuginfo\_eip(uintptr\_t addr, struct eipdebuginfo \*info) { ….. } /\*
\* \* print\_kerninfo - print the information about kernel, including
the location \* of kernel entry, the start addresses of data and text
segements, the start \* address of free memory and how many memory that
kernel has used. \* \*/ void print\_kerninfo(void) { extern char
etext[], edata[], end[], kern\_init[]; cprintf("Special kernel
symbols:\\n"); cprintf(" entry 0x%08x (phys)\\n", kern\_init); cprintf("
etext 0x%08x (phys)\\n", etext); cprintf(" edata 0x%08x (phys)\\n",
edata); cprintf(" end 0x%08x (phys)\\n", end); cprintf("Kernel
executable memory footprint: %dKB\\n", (end - kern\_init + 1023)/1024);
} /\* \* \* print\_debuginfo - read and print the stat information for
the address @eip, \* and info.eip\_fn\_addr should be the first address
of the related function. \* \*/ void print\_debuginfo(uintptr\_t eip) {
struct eipdebuginfo info; if (debuginfo\_eip(eip, &info;) != 0) {
cprintf(" : -- 0x%08x --\\n", eip); } else { char fnname[256]; int j;
for (j = 0; j < info.eip\_fn\_namelen; j ++) { fnname[j] =
info.eip\_fn\_name[j]; } fnname[j] = '\\0'; cprintf(" %s:%d: %s+%d\\n",
info.eip\_file, info.eip\_line, fnname, eip - info.eip\_fn\_addr); } }
static \_\_noinline uint32\_t read\_eip(void) { uint32\_t eip; asm
volatile("movl 4(%%ebp), %0" : "=r" (eip)); return eip; } /\* \* \*
print\_stackframe - print a list of the saved eip values from the nested
'call' \* instructions that led to the current point of execution \* \*
The x86 stack pointer, namely esp, points to the lowest location on the
stack \* that is currently in use. Everything below that location in
stack is free. Pushing \* a value onto the stack will invole decreasing
the stack pointer and then writing \* the value to the place that stack
pointer pointes to. And popping a value do the \* opposite. \* \* The
ebp (base pointer) register, in contrast, is associated with the stack
\* primarily by software convention. On entry to a C function, the
function's \* prologue code normally saves the previous function's base
pointer by pushing \* it onto the stack, and then copies the current esp
value into ebp for the duration \* of the function. If all the functions
in a program obey this convention, \* then at any given point during the
program's execution, it is possible to trace \* back through the stack
by following the chain of saved ebp pointers and determining \* exactly
what nested sequence of function calls caused this particular point in
the \* program to be reached. This capability can be particularly
useful, for example, \* when a particular function causes an assert
failure or panic because bad arguments \* were passed to it, but you
aren't sure who passed the bad arguments. A stack \* backtrace lets you
find the offending function. \* \* The inline function read\_ebp() can
tell us the value of current ebp. And the \* non-inline function
read\_eip() is useful, it can read the value of current eip, \* since
while calling this function, read\_eip() can read the caller's eip from
\* stack easily. \* \* In print\_debuginfo(), the function
debuginfo\_eip() can get enough information about \* calling-chain.
Finally print\_stackframe() will trace and print them for debugging. \*
\* Note that, the length of ebp-chain is limited. In boot/bootasm.S,
before jumping \* to the kernel entry, the value of ebp has been set to
zero, that's the boundary. \* \*/ void print\_stackframe(void) { /\*
LAB1 YOUR CODE : STEP 1 \*/ /\* (1) call read\_ebp() to get the value of
ebp. the type is (uint32\_t); \* (2) call read\_eip() to get the value
of eip. the type is (uint32\_t); \* (3) from 0 .. STACKFRAME\_DEPTH \*
(3.1) printf value of ebp, eip \* (3.2) (uint32\_t)calling arguments
[0..4] = the contents in address (unit32\_t)ebp +2 [0..4] \* (3.3)
cprintf("\\n"); \* (3.4) call print\_debuginfo(eip-1)to print the C
calling function name and line number, etc. \* (3.5) popup a calling
stackframe \* NOTICE: the calling funciton's return addr eip =
ss:[ebp+4] \* the calling funciton's ebp = ss:[ebp] \*/ } 853.
(20140410-2-期中考试试题v4a答案.docx)中断
（15分）中断（Interrupt）是操作系统为处理意外事件而提供的一种响应机制，中断可分为硬件中断（Hardware
interrupt）和软件中断（software
interrupt）。中断响应需要硬件和软件的协调合作来完成。在虚拟机中的中断响应需要宿主机（Host
OS）、虚拟机（Guest OS）和硬件的协调合作来完成。试回答下面问题。 1)
描述硬件中断、软件中断和系统调用（system call）的区别。 2)
简要描述外部中断的响应处理过程，并说明各处理操作的执行者。 3)
简要描述虚拟机中客户操作系统对硬件中断的响应处理过程。 854.
(操作系统之PV金典)生产者一消费者问题 (producer-consumer
problem)，也称有限缓冲问题 (Bounded-buffer
problem)，是指若干进程通过有限的共享缓冲区交换数据时的缓冲区资源使用问题。
假设“生产者”进程不断向共享缓冲区写人数据(即生产数据)，而“消费者”进程不断从共享缓冲区读出数据(即消费数据)；共享缓冲区共有n个；任何时刻
只能有一个进程可对共享缓冲区进行操作。所有生产者和消费者之间要协调，以完成对共享缓冲区的操作。
855.
(操作系统之PV金典)有一个许多进程共享的数据区，有一些只读这个数据区的进程(reader)和一些只往数据区中写数据的进程(writer)；此外还必须满足以
下条件 \* 任意多的读进程可以同时读这个文件 \*
一次只有一个写进程可以往文件中写 \*
如果一个写进程正在往文件中写时，则禁止任何读进程和其他写进程。
读者写者问题又分为“读者优先”和“写者优先” \*
读者优先：要求指一个读者试图进行读操作时，如果这时正有其他读者在进行操作，他可以直接开始读操作，直到某个时刻没有任何读者。读者之间不互斥，写者之间互斥，只能一个写，可以多个读；读者写者之间互斥，有写者则不能有读者。所以只需要当前第一个读者和写者竞争，竞争成功则后面的读者因为已经有读者在读，可以直接读。
\*
写者优先：一个读者试图进行读操作时，如果有其他写者在等待进行写操作或者正在进行写操作，他要等待写者完成写操作后才开始读操作
856.
(操作系统之PV金典)5个哲学家围绕一张圆桌而坐，桌子上放着5支筷子，每两个哲学家之间放一支；哲学家的动作包括思考和进餐，进餐时需要同时拿起他左边和右边的筷
子，思考时则同时将两支筷子放回原处。如何保证哲学家们的动作有序进行？ 857.
(操作系统之PV金典)理发店理有一位理发师、一把理发椅和n把供等候理发的顾客坐的椅子。如果没有顾客，理发师便在理发椅上睡觉一个顾客到来时，它必须叫醒理发师，
如果理发师正在理发时又有顾客来到，则如果有空椅子可坐，就坐下来等待，否则就离开。
要求： 1\\. 每个顾客进入理发室后，即时显示“Entered”
及其线程标识，还同时显示理发室共有几名顾客及其所坐的位置； 2\\.
至少有10个顾客，每人理发至少3秒钟； 3\\. 多个顾客须共享操作函数代码 858.
(操作系统之PV金典)三个吸烟者在一间房间内，还有一个香烟供应者。为了制造并抽掉香烟，每个吸烟者需要三样东西：烟草、纸和火柴。供应者有丰富的货物提供。三个吸
烟者中，第一个有自己的烟草，第二个有自己的纸，第三个有自己的火柴。供应者将两样东西放在桌子上，允许一个吸烟者进行对健康不利的吸烟。当吸烟者完成吸烟后唤醒供应
者，供应者再放两样东西（随机地）在桌面上，然后唤醒另一个吸烟者。试为吸烟者和供应者编写程序解决问题。
859.
(操作系统之PV金典)设有一个可以装A、B两种物品的仓库，其容量无限大，但要求仓库中A、B两种物品的数量满足下述不等式：
-M≤A物品数量-B物品数量≤N
其中M和N为正整数。试用信号量和PV操作描述A、B两种物品的入库过程。 860.
(操作系统之PV金典)设有一个可以装A、B两种物品的仓库,其容量有限(分别为N),但要求仓库中A、B两种物品的数量满足下述不等式:
-M≤A物品数量- B物品数量≤N
其中M和N为正整数。另外,还有一个进程消费A,B,一次取一个A,B组装成C。
试用信号量和PV操作描述A、B两种物品的入库过程。 861.
"1）试说明硬中断（hardware interrupt）、异常（exception）和系统调用（system
call）的相同点和不同点。
2）下面代码完成在进入trap()函数前的准备工作。其中pushal完成包括esp在内的CPU寄存器压栈。试说明“pushl
%esp”的作用是什么？ =============trapentry.S (kern\\trap)=============
\#include \# vectors.S sends all traps here. .text .globl \_\_alltraps
\_\_alltraps: \# push registers to build a trap frame \# therefore make
the stack look like a struct trapframe pushl %ds pushl %es pushl %fs
pushl %gs pushal \# load GD\_KDATA into %ds and %es to set up data
segments for kernel movl $GD\_KDATA, %eax movw %ax, %ds movw %ax, %es
pushl %esp call trap \# pop the pushed stack pointer popl %esp \# return
falls through to trapret... .globl \_\_trapret \_\_trapret: \# restore
registers from stack popal \# restore %ds, %es, %fs and %gs popl %gs
popl %fs popl %es popl %ds \# get rid of the trap number and error code
addl $0x8, %esp iret =============Trap.c (kern\\trap)=============
...... /\* \* \* trap - handles or dispatches an exception/interrupt. if
and when trap() returns, \* the code in kern/trap/trapentry.S restores
the old CPU state saved in the \* trapframe and then uses the iret
instruction to return from the exception. \* \*/ void trap(struct
trapframe \*tf) { // dispatch based on what type of trap occurred
trap\_dispatch(tf); } ......" 862.
"1）系统调用的参数传递有几种方式？各有什么特点？
2）sys\_exec是一个加载和执行指定可执行文件的系统调用。请说明在下面的ucore实现中，它的三个参数分别是以什么方式传递的。
=============Proc.c (kern\\process)============= ...... // do\_execve -
call exit\_mmap(mm)&pug;\_pgdir(mm) to reclaim memory space of current
process // - call load\_icode to setup new memory space accroding binary
prog. int do\_execve(const char \*name, int argc, const char \*\*argv) {
static\_assert(EXEC\_MAX\_ARG\_LEN \>= FS\_MAX\_FPATH\_LEN); struct
mm\_struct \*mm = current-\>mm; if (!(argc \>= 1 && argc <=
EXEC\_MAX\_ARG\_NUM)) { return -E\_INVAL; } char
local\_name[PROC\_NAME\_LEN + 1]; memset(local\_name, 0,
sizeof(local\_name)); char \*kargv[EXEC\_MAX\_ARG\_NUM]; const char
\*path; int ret = -E\_INVAL; lock\_mm(mm); if (name == NULL) {
snprintf(local\_name, sizeof(local\_name), " %d", current-\>pid); } else
{ if (!copy\_string(mm, local\_name, name, sizeof(local\_name))) {
unlock\_mm(mm); return ret; } } if ((ret = copy\_kargv(mm, argc, kargv,
argv)) != 0) { unlock\_mm(mm); return ret; } path = argv[0];
unlock\_mm(mm); files\_closeall(current-\>filesp); /\* sysfile\_open
will check the first argument path, thus we have to use a user- space
pointer, and argv[0] may be incorrect \*/ int fd; if ((ret = fd =
sysfile\_open(path, O\_RDONLY)) < 0) { goto execve\_exit; } if (mm !=
NULL) { lcr3(boot\_cr3); if (mm\_count\_dec(mm) == 0) { exit\_mmap(mm);
put\_pgdir(mm); mm\_destroy(mm); } current-\>mm = NULL; } ret=
-E\_NO\_MEM;; if ((ret = load\_icode(fd, argc, kargv)) != 0) { goto
execve\_exit; } put\_kargv(argc, kargv); set\_proc\_name(current,
local\_name); return 0; execve\_exit: put\_kargv(argc, kargv);
do\_exit(ret); panic("already exit: %e.\\n", ret); } ......
=============Syscall.c (kern\\syscall)============= ...... static int
sys\_exec(uint32\_t arg[]) { const char \*name = (const char \*)arg[0];
int argc = (int)arg[1]; const char \*\*argv = (const char \*\*)arg[2];
return do\_execve(name, argc, argv); } ...... static int
(\*syscalls[])(uint32\_t arg[]) = { [SYS\_exit] sys\_exit, [SYS\_fork]
sys\_fork, [SYS\_wait] sys\_wait, [SYS\_exec] sys\_exec, [SYS\_yield]
sys\_yield, [SYS\_kill] sys\_kill, [SYS\_getpid] sys\_getpid,
[SYS\_putc] sys\_putc, [SYS\_pgdir] sys\_pgdir, }; \#define
NUM\_SYSCALLS ((sizeof(syscalls)) / (sizeof(syscalls[0]))) void
syscall(void) { struct trapframe \*tf = current-\>tf; uint32\_t arg[5];
int num = tf-\>tf\_regs.reg\_eax; if (num \>= 0 && num < NUM\_SYSCALLS)
{ if (syscalls[num] != NULL) { arg[0] = tf-\>tf\_regs.reg\_edx; arg[1] =
tf-\>tf\_regs.reg\_ecx; arg[2] = tf-\>tf\_regs.reg\_ebx; arg[3] =
tf-\>tf\_regs.reg\_edi; arg[4] = tf-\>tf\_regs.reg\_esi;
tf-\>tf\_regs.reg\_eax = syscalls[num](arg); return ; } }
print\_trapframe(tf); panic("undefined syscall %d, pid = %d, name =
%s.\\n", num, current-\>pid, current-\>name); } ......
=============libs-user- ucore/syscall.c============= ...... int
sys\_exec(const char \*filename, const char \*\*argv, const char
\*\*envp) { return syscall(SYS\_exec, filename, argv, envp); } ......
=============libs-user-ucore/arch/i386/syscall.c============= ......
uint32\_t syscall(int num, ...) { va\_list ap; va\_start(ap, num);
uint32\_t a[MAX\_ARGS]; int i; for (i = 0; i < MAX\_ARGS; i++) { a[i] =
va\_arg(ap, uint32\_t); } va\_end(ap); uint32\_t ret; asm volatile ("int
%1;":"=a" (ret) :"i"(T\_SYSCALL), "a"(num), "d"(a[0]), "c"(a[1]),
"b"(a[2]), "D"(a[3]), "S"(a[4]) :"cc", "memory"); return ret; }" 863.
"1）描述伙伴系统（Buddy
System）中对物理内存的分配和回收过程。2）假定一个操作系统内核中由伙伴系统管理的物理内存有1MB，试描述按下面顺序进行
物理内存分配和回收过程中，每次分配完成后的分配区域的首地址和大小，或每次回收完成后的空闲区域队列（要求说明，每个空闲块的首地址和大小）。建议给出分配和回收的
中间过程。 a) 进程A申请50KB； b) 进程B申请100KB； c) 进程C申请40KB； d)
进程D申请70KB； e) 进程B释放100KB； f) 进程E申请127KB； g) 进程D释放70KB；
h) 进程A释放50KB； i) 进程E释放127KB； j) 进程C释放40KB；" 864.
"1）试用图示描述32位X86系统在采用4KB页面大小时的虚拟地址结构和地址转换过程。2）在采用4KB页面大小的32位X86的ucore虚拟存储系统中，进程
页面的起始地址由宏VPT确定。 \#define VPT 0x0D000000
请计算：2a)试给出页目录中自映射页表项的虚拟地址；2b)虚拟地址0X87654321对应的页目录项和页表项的虚拟地址。"
865.
"试描述FIFO页面替换算法的基本原理，并swap\_fifo.c中未完成FIFA页面替换算法实验函数map\_swappable()和swap\_out\_vic
tim() 。 =============Defs.h (libs)============= /\* \* \* to\_struct -
get the struct from a ptr \* @ptr: a struct pointer of member \* @type:
the type of the struct this is embedded in \* @member: the name of the
member within the struct \* \*/ \#define to\_struct(ptr, type, member)
\\ ((type \*)((char \*)(ptr) - offsetof(type, member)))
=============Memlayout.h (kern\\mm)============= // convert list entry
to page \#define le2page(le, member) \\ to\_struct((le), struct Page,
member) =============List.h (libs)============= \#ifndef
\_\_LIBS\_LIST\_H\_\_ \#define \_\_LIBS\_LIST\_H\_\_ \#ifndef
\_\_ASSEMBLER\_\_ \#include /\* \* \* Simple doubly linked list
implementation. \* \* Some of the internal functions ("\_\_xxx") are
useful when manipulating \* whole lists rather than single entries, as
sometimes we already know \* the next/prev entries and we can generate
better code by using them \* directly rather than using the generic
single-entry routines. \* \*/ struct list\_entry { struct list\_entry
\*prev, \*next; }; typedef struct list\_entry list\_entry\_t; static
inline void list\_init(list\_entry\_t \*elm)
\_\_attribute\_\_((always\_inline)); static inline void
list\_add(list\_entry\_t \*listelm, list\_entry\_t \*elm)
\_\_attribute\_\_((always\_inline)); static inline void
list\_add\_before(list\_entry\_t \*listelm, list\_entry\_t \*elm)
\_\_attribute\_\_((always\_inline)); static inline void
list\_add\_after(list\_entry\_t \*listelm, list\_entry\_t \*elm)
\_\_attribute\_\_((always\_inline)); static inline void
list\_del(list\_entry\_t \*listelm) \_\_attribute\_\_((always\_inline));
static inline void list\_del\_init(list\_entry\_t \*listelm)
\_\_attribute\_\_((always\_inline)); static inline bool
list\_empty(list\_entry\_t \*list) \_\_attribute\_\_((always\_inline));
static inline list\_entry\_t \*list\_next(list\_entry\_t \*listelm)
\_\_attribute\_\_((always\_inline)); static inline list\_entry\_t
\*list\_prev(list\_entry\_t \*listelm)
\_\_attribute\_\_((always\_inline)); static inline void
\_\_list\_add(list\_entry\_t \*elm, list\_entry\_t \*prev,
list\_entry\_t \*next) \_\_attribute\_\_((always\_inline)); static
inline void \_\_list\_del(list\_entry\_t \*prev, list\_entry\_t \*next)
\_\_attribute\_\_((always\_inline)); /\* \* \* list\_init - initialize a
new entry \* @elm: new entry to be initialized \* \*/ static inline void
list\_init(list\_entry\_t \*elm) { elm-\>prev = elm-\>next = elm; } /\*
\* \* list\_add - add a new entry \* @listelm: list head to add after \*
@elm: new entry to be added \* \* Insert the new element @elm \*after\*
the element @listelm which \* is already in the list. \* \*/ static
inline void list\_add(list\_entry\_t \*listelm, list\_entry\_t \*elm) {
list\_add\_after(listelm, elm); } /\* \* \* list\_add\_before - add a
new entry \* @listelm: list head to add before \* @elm: new entry to be
added \* \* Insert the new element @elm \*before\* the element @listelm
which \* is already in the list. \* \*/ static inline void
list\_add\_before(list\_entry\_t \*listelm, list\_entry\_t \*elm) {
\_\_list\_add(elm, listelm-\>prev, listelm); } /\* \* \*
list\_add\_after - add a new entry \* @listelm: list head to add after
\* @elm: new entry to be added \* \* Insert the new element @elm
\*after\* the element @listelm which \* is already in the list. \* \*/
static inline void list\_add\_after(list\_entry\_t \*listelm,
list\_entry\_t \*elm) { \_\_list\_add(elm, listelm, listelm-\>next); }
/\* \* \* list\_del - deletes entry from list \* @listelm: the element
to delete from the list \* \* Note: list\_empty() on @listelm does not
return true after this, the entry is \* in an undefined state. \* \*/
static inline void list\_del(list\_entry\_t \*listelm) {
\_\_list\_del(listelm-\>prev, listelm-\>next); } /\* \* \*
list\_del\_init - deletes entry from list and reinitialize it. \*
@listelm: the element to delete from the list. \* \* Note: list\_empty()
on @listelm returns true after this. \* \*/ static inline void
list\_del\_init(list\_entry\_t \*listelm) { list\_del(listelm);
list\_init(listelm); } /\* \* \* list\_empty - tests whether a list is
empty \* @list: the list to test. \* \*/ static inline bool
list\_empty(list\_entry\_t \*list) { return list-\>next == list; } /\*
\* \* list\_next - get the next entry \* @listelm: the list head \*\*/
static inline list\_entry\_t \* list\_next(list\_entry\_t \*listelm) {
return listelm-\>next; } /\* \* \* list\_prev - get the previous entry
\* @listelm: the list head \*\*/ static inline list\_entry\_t \*
list\_prev(list\_entry\_t \*listelm) { return listelm-\>prev; } /\* \*
\* Insert a new entry between two known consecutive entries. \* \* This
is only for internal list manipulation where we know \* the prev/next
entries already! \* \*/ static inline void \_\_list\_add(list\_entry\_t
\*elm, list\_entry\_t \*prev, list\_entry\_t \*next) { prev-\>next =
next-\>prev = elm; elm-\>next = next; elm-\>prev = prev; } /\* \* \*
Delete a list entry by making the prev/next entries point to each other.
\* \* This is only for internal list manipulation where we know \* the
prev/next entries already! \* \*/ static inline void
\_\_list\_del(list\_entry\_t \*prev, list\_entry\_t \*next) {
prev-\>next = next; next-\>prev = prev; } \#endif /\* !\_\_ASSEMBLER\_\_
\*/ \#endif /\* !\_\_LIBS\_LIST\_H\_\_ \*/ ============= Swap\_fifo.c
(kern\\mm)============= \#include \#include \#include \#include
\#include \#include \#include /\* [wikipedia]The simplest Page
Replacement Algorithm(PRA) is a FIFO algorithm. \* (1) Prepare: In order
to implement FIFO PRA, we should manage all swappable pages, so we can
\* link these pages into pra\_list\_head according the time order. At
first you should \* be familiar to the struct list in list.h. struct
list is a simple doubly linked list \* implementation. You should know
howto USE: list\_init, list\_add(list\_add\_after), \*
list\_add\_before, list\_del, list\_next, list\_prev. Another tricky
method is to transform \* a general list struct to a special struct
(such as struct page). You can find some MACRO: \* le2page (in
memlayout.h), (in future labs: le2vma (in vmm.h), le2proc (in
proc.h),etc. \*/ list\_entry\_t pra\_list\_head; /\* \* (2)
\_fifo\_init\_mm: init pra\_list\_head and let mm-\>sm\_priv point to
the addr of pra\_list\_head. \* Now, From the memory control struct
mm\_struct, we can access FIFO PRA \*/ static int
\_fifo\_init\_mm(struct mm\_struct \*mm) {
list\_init(&pra;\_list\_head); mm-\>sm\_priv = &pra;\_list\_head;
//cprintf(" mm-\>sm\_priv %x in fifo\_init\_mm\\n",mm-\>sm\_priv);
return 0; } /\* \* (3)\_fifo\_map\_swappable: According FIFO PRA, we
should link the most recent arrival page at the back of pra\_list\_head
qeueue \*/ static int \_fifo\_map\_swappable(struct mm\_struct \*mm,
uintptr\_t addr, struct Page \*page, int swap\_in) { list\_entry\_t
\*head=(list\_entry\_t\*) mm-\>sm\_priv; list\_entry\_t
\*entry=&(page-\>pra\_page\_link); assert(entry != NULL && head !=
NULL); //record the page access situlation /\*LAB3 EXERCISE 2: YOUR
CODE\*/ //(1)link the most recent arrival page at the back of the
pra\_list\_head qeueue. ===Your code 2=== return 0; } /\* \*
(4)\_fifo\_swap\_out\_victim: According FIFO PRA, we should unlink the
earliest arrival page in front of pra\_list\_head qeueue, \* then set
the addr of addr of this page to ptr\_page. \*/ static int
\_fifo\_swap\_out\_victim(struct mm\_struct \*mm, struct Page \*\*
ptr\_page, int in\_tick) { list\_entry\_t \*head=(list\_entry\_t\*)
mm-\>sm\_priv; assert(head != NULL); assert(in\_tick==0); /\* Select the
victim \*/ /\*LAB3 EXERCISE 2: YOUR CODE\*/ //(1) unlink the earliest
arrival page in front of pra\_list\_head qeueue //(2) set the addr of
addr of this page to ptr\_page /\* Select the tail \*/ ===Your code 3===
return 0; } static int \_fifo\_check\_swap(void) { cprintf("write Virt
Page c in fifo\_check\_swap\\n"); \*(unsigned char \*)0x3000 = 0x0c;
assert(pgfault\_num==4); cprintf("write Virt Page a in
fifo\_check\_swap\\n"); \*(unsigned char \*)0x1000 = 0x0a;
assert(pgfault\_num==4); cprintf("write Virt Page d in
fifo\_check\_swap\\n"); \*(unsigned char \*)0x4000 = 0x0d;
assert(pgfault\_num==4); cprintf("write Virt Page b in
fifo\_check\_swap\\n"); \*(unsigned char \*)0x2000 = 0x0b;
assert(pgfault\_num==4); cprintf("write Virt Page e in
fifo\_check\_swap\\n"); \*(unsigned char \*)0x5000 = 0x0e;
assert(pgfault\_num==5); cprintf("write Virt Page b in
fifo\_check\_swap\\n"); \*(unsigned char \*)0x2000 = 0x0b;
assert(pgfault\_num==5); cprintf("write Virt Page a in
fifo\_check\_swap\\n"); \*(unsigned char \*)0x1000 = 0x0a;
assert(pgfault\_num==6); cprintf("write Virt Page b in
fifo\_check\_swap\\n"); \*(unsigned char \*)0x2000 = 0x0b;
assert(pgfault\_num==7); cprintf("write Virt Page c in
fifo\_check\_swap\\n"); \*(unsigned char \*)0x3000 = 0x0c;
assert(pgfault\_num==8); cprintf("write Virt Page d in
fifo\_check\_swap\\n"); \*(unsigned char \*)0x4000 = 0x0d;
assert(pgfault\_num==9); return 0; } static int \_fifo\_init(void) {
return 0; } static int \_fifo\_set\_unswappable(struct mm\_struct \*mm,
uintptr\_t addr) { return 0; } static int \_fifo\_tick\_event(struct
mm\_struct \*mm) { return 0; } struct swap\_manager swap\_manager\_fifo
= { .name = "fifo swap manager", .init = &\_fifo\_init, .init\_mm =
&\_fifo\_init\_mm, .tick\_event = &\_fifo\_tick\_event, .map\_swappable
= &\_fifo\_map\_swappable, .set\_unswappable =
&\_fifo\_set\_unswappable, .swap\_out\_victim =
&\_fifo\_swap\_out\_victim, .check\_swap = &\_fifo\_check\_swap, }; "
866. "描述int
fork(void)系统调用的功能和接口，给出程序fork.c的输出结果，并用图示给出所有进程的父子关系。注：1）getpid()和getpp
id()是两个系统调用，分别返回本进程标识和父进程标识。2）你可以假定每次新进程创建时生成的进程标识是顺序加1得到的；在进程标识为1000的命令解释程序sh
ell中启动该程序的执行。 \#include \#include /\* getpid() and fork() are
system calls declared in unistd.h. They return \*/ /\* values of type
pid\_t. This pid\_t is a special type for process ids. \*/ /\* It's
equivalent to int. \*/ int main(void) { pid\_t childpid; int x = 5; int
i; childpid = fork(); for ( i = 0; i < 3; i++) { printf("This is process
%d; childpid = %d; The parent of this process has id %d; i = %d; x =
%d\\n", getpid(), childpid, getppid(), i, x); sleep(1); x++; } return 0;
}" 867.
"设P,Q,R共享一个缓冲区,P,Q构成一对生产者-消费者,R既为生产者又为消费?者。使用P,V
实现其同步。" 868.
"此问题是对读者-写者问题的一个扩展，既如果读者写者均是平等的即二者都不优先情况下。
此问题的一个更高的版本是说，每个资源可以同时读取的人的个数也是有限的（限制数RN）。"
869.
"有一个许多进程共享的数据区，有一些只读这个数据区的进程(reader)和一些只往数据区中写数据的进程(writer)；此外还需满足如下条件：
1.任意多的读进程可以同时读这个文件。
2.一次只有一个写进程可以往文件中写。
3.如果一个写进程正在往文件中写时，则禁止任何读进程和其他写进程。
实现基于先来先服务策略的读者－写者的问题，具体要求描述如下：
1.存在m个读者和n个写者，共享同一个缓冲区。
2.当没有读者在读，写者在写时，读者写者均可进入读或写。 3.当有读者在读时：
(1) 写者来了，则写者等待。 (2)
读者来了，则分两种情况处理：无写者等待，则读者可以直接进入读操作，如果有写者等待，则读者必须依次等待。
4.当有写者在写时，写者或读者来了，均需等待。
5.当写者写完后，如果等待队列中第一个是写者，则唤醒该写者；如果等待队列中第一个是读者，则唤醒该队列中从读者开始连续的所有读者。
6.当最后一个读者读后，如果有写者在等待，则唤醒第一个等待的写者。" 870.
"在一间酒吧里有三个音乐爱好者队列，第一队的音乐爱好者只有随身听，第二队的只有音乐磁带，第三队只有电池。而要听音乐就必须随身听，音乐磁带和电池这三种物品俱全
。酒吧老板依次出售这三种物品中的任意两种。当一名音乐爱好者得到这三种物品并听完一首乐曲后，酒吧老板才能再一次出售这三种物品中的任意两种。于是第二名音乐爱好者
得到这三种物品，并开始听乐曲。全部买卖就这样进行下去。试用P，V操作正确解决这一买卖。"
871.
"假设一个录像厅有0,1，2三种不同的录像片可由观众选择放映，录像厅的放映规则为:
任一时刻最多只能放映一种录像片，正在放映的录像片是自动循环放映的，最后一个观众主动离开时结束当前录像片的放映；
选择当前正在放映的录像片的观众可立即进入，允许同时有多位选择同一种录像片的观众同时观看，同时观看的观众数量不受限制；
等待观看其他录像片的观众按到达顺序排队，当一种新的录像片开始放映时，所有等待观看该录像片的观众可依次序进入录像厅同时观看。用一个进程代表一个观众。
要求:用信号量方法PV实现，并给出信号量定义和初始值。（最好也能写出录像厅的进程）"
872. "银行有n个柜员,每个顾客进入银行后先取一个号,并且等着叫号,当一
个柜员空闲后,就叫下一个号." 873.
"假设缓冲区buf1和缓冲区buf2无限大，进程p1向buf1写数据，进程p2向buf2写数据，
要求buf1数据个数和buf2数据个数的差保持在(m,n)之间(m页面调出-\>缺页中断-\>页面凋入
B.决定淘汰页-\>页面调入-\>缺页中断-\>页面凋出
C.缺页中断-\>决定淘汰页-\>页面调出-\>页面凋入
D.缺页中断-\>决定淘汰页-\>页面调入-\>页面凋出 915.
在I/O设备控制的发展过程中，最主要的推动因素是﹎﹎﹎﹎、提高I/O速度和设备利用率。
A.提高资源利用率 B.提高系统吞吐量 C.减少主机对I/O控制的干预
D.提高CPU与I/O设备的并行操作程度 916.
下面关于设备属性的论述中，正确的是＿＿＿＿。
A.字符设备的基本特征是可寻址到字节，即能指定输入的源地址或输出的目标地址
B.共享设备必须是可寻址的和可随机访问的设备
C.共享设备是指同一时间内允许多个进程同时访问的设备
D.在分配共享设备和独占设备时都可能引起进程死锁 917.
使用户所编制的程序与实际使用的物理设备无关是由﹎﹎﹎﹎功能实现的。
A.设备分配 B.缓冲管理 C.设备管理 D.设备独立性 918. 通道是一种( )。
A.I/O设备 B.设备控制器 C.I/O处理机 D.I/O控制器 919.
通道具有﹎﹎﹎﹎能力。 A.执行I/O指令集 B.执行CPU指令集 C.传输I/O命令
D.运行I/O进程 920. 实现CPU和外部设备并行工作的硬件支持是：( )。
A.中断机构 B.外部设备接口（通道、控制器等） C. 通道和中断 D.多总线 921.
在具有通道处理机的系统中，用户进程请求启动外设时，由 (
)根据I/O要求构造通道程序及通道状态字，并将通道程序保存在内存，然后执行启动“I/O”命令。
A.用户进程 B.应用程序 C.通道 D.操作系统 922.
在具有通道处理机的系统中，用户进程请求启动外设时，由操作系统根据I/O要求构造通道程序及通道状态字，并将通道程序保存在(
)，然后执行启动“I/O”命令。 A.内存 B.硬盘 C.通道 D.外部设备 923.
不通过CPU进行主存与I/O设备间大量的信息交换方式，可以是( )方式。 A.DMA
B.中断 C.查询等待 D.程序控制 924. 从下面关于设备独立性的论述中，第(
)条是正确的论述。 A.设备独立性是I/O设备具有独立执行I/O功能的一种特性。
B.设备独立性是指用户程序独立于具体使用的物理设备的一种特性。
C.设备独立性是指能独立实现设备共享的一种特性。
D.设备独立性是指设备驱动独立于具体使用的物理设备的一种特性。 925.
为了实现设备的独立性、系统中的逻辑设备表必须包含：( )。
A.逻辑设备名和物理设备名 B.逻辑设备名和驱动程序入口地址
C.物理设备名和驱动程序入口地址 D.逻辑、物理设备名和驱动程序入口地址 926.
使用编制的程序与实际使用的物理设备无关是由( )功能实现的。 A.设备分配
B.设备驱动 C.虚拟设备 D.设备独立性 927. 下面关于虚拟设备的论述中，第(
)条是正确的论述。
A.虚拟设备是指允许用户使用比系统中具有的物理设备更多的设备。
B.虚拟设备是指允许用户以标准化方式来使用物理设备。
C.虚拟设备是把一个物理设备变换成多个对应的逻辑设备。
D.虚拟设备是指允许用户程序不必全部装入内存便可使用系统中的设备。 928.
通过硬件和软件的功能扩充，把原来独占的设备改造成能为若干用户共享的设备，这种设备称为(
)。 A.存储设备 B.系统设备 C.虚拟设备 D.用户设备 929.
如果I/O所花费的时间比CPU处理时间短得多，则缓冲区( )。 A.最有效 B.几乎无效
C.均衡 D.都不是 930. 在现代操作系统中采用缓冲技术的主要目的是( )
A.改善用户编程环境 B.提高CPU的处理速度 C.提高CPU和设备之间的并行程度
D.实现与设备无关性 931. 下列有关SPOOLing系统的论述中第(
)条是正确的论述。
A.构成SPOOLing系统的基本条件，是具有外围输入机与外围输出机。
B.只要操作系统中采用了多道程序设计技术，就可以构成SPOOLing系统。
C.SPOOLing系统是虚拟存储技术的体现。
D.当输出设备忙时，SPOOLing系统中的用户程序暂停执行，待I/O
空闲时再被唤醒，去执行输出操作。
E.在SPOOLing系统中，用户程序可以随时将输出数据送到输出井中，待输出设备空闲时再执行数据输出操作。
932. 下列有关SPOOLing系统的论述中第( )条是正确的论述。
A.构成SPOOLing系统的基本条件，是只要具有大容量、高速硬盘作为输入井与输出井。
B.SPOOLing系统是建立在分时系统中。
C.SPOOLing系统是在用户程序要读取数据时起动输入进程输入数据。
D.当输出设备忙时，SPOOLing系统中的用户程序暂停执行，待I/O
空闲时再被唤醒，去执行输出操作。
E.SPOOLing系统实现了对I/O设备的虚拟，只要输入设备空闲，SPOOLing可预先将输入数据从设备传输到输入井中供用户程序随时读取。
933. 在采用SPOOLing技术的系统中，用户作业的打印输出结果首先被送到( )。
A.磁盘固定区域 B.内存固定区域 C.终端 D.打印机 934.
在操作系统中SPOOLing技术是一种并行机制，它可以使 ( )。 A.不同进程同时运行
B.应用程序和系统软件同时运行 C.不同系统软件同时运行
D.程序执行与打印同时进行 935.
在设备管理中，虚拟设备的引入和实现是为了充分利用设备，提高系统效率，采用(
)来模拟低速设备（输入机或打印机）的工作。 A.Spooling技术，利用磁带设备
B.Spooling技术，利用磁盘设备 C.脱机批处理系统 936.
SPOOLing是对脱机I/O工作方式的模拟，SPOOLing系统中的输入井是对脱机输入中的(
)进行模拟。 A.内存输入缓冲区 B.磁盘 C.外围控制机 D.输入设备 937.
SPOOLing是对脱机I/O工作方式的模拟，SPOOLing系统中的输出进程是对脱出输出中的(
)进行模拟。 A.内存输入缓冲区 B.磁盘 C.外围控制机 D.输入设备 938.
从下列关于驱动程序的论述中，选出一条正确的论述。 A.
驱动程序与I/O设备的特性紧密相关，因此应为每一I/O设备配备一个驱动程序。 B.
驱动程序与I/O控制方式紧密相关，因此对DMA方式应是以字节为单位去启动设备及进行中断处理。
C. 由于驱动程序与I/O设备（硬件）紧密相关，故必须全部用汇编语言书写。 D.
对于一台多用户机，配置了相同的8个终端，此时可以只配置一个由多个终端共享的驱动程序。
939.
操作系统设备管理功能的内部设计一般是基于分层的思想，因此通常将I/O软件组成4个层次，用户应用软件、终端应用层软件、中断应用层程序、中断处理程序、独立于设备
的软件和设备驱动程序，采用分层思想的主要目的是( )。 A.便于即擦即用
B.减少系统占用的空间 C.便于系统修改、扩充和移植 D.提高处理速度 940.
操作系统设备管理功能的内部设计一般是基于分层的思想，因此通常将I/O软件组成4个层次，用户应用软件、终端应用层软件、中断应用层程序、中断处理程序、独立于设备
的软件和设备驱动程序，当进程提出I/O请求访问硬件时，需要按(
)的层次结构进行。
A.进程请求I/O-\>独立于设备的软件―＞中断处理程序―＞设备驱动程序―＞硬件
B.进程请求I/O-\>独立于设备的软件―＞设备驱动程序―＞中断处理程序―＞硬件
C.进程请求I/O-\>设备驱动程序―＞中断处理程序―＞独立于设备的软件―＞硬件
D.进程请求I/O-\>设备驱动程序―＞独立于设备的软件―＞中断处理程序―＞硬件 941.
对磁盘进行移臂调度时，既考虑了减少寻找时间，又不频繁改变动臂的移动方向的调度算法是(
)。 A.先来先服务 B.最短寻找时间优先 C.电梯调度 D.优先级高者优先 942.
对移动臂磁盘的一次信息传输所花费的时间由三部分组成，它们是( )。
A.传送时间，延迟时间和寻找时间 B.旋转等待时间，延迟时间和寻找时间
C.磁头移动时间，延迟时间和寻找时间 D. 延迟时间，移动时间和等待时间 943. (
)调度算法总是从等待访问者中挑选等待时间最短的那个请求先执行。
A.先来先服务 B.最短寻找时间优先 C.电梯 D.单向扫描 944.
对磁盘进行移臂调度的目的是缩短( )。 A. 启动时间 B. 传送时间 C.
寻找定位时间 D. 旋转延迟时间 945. 下列第( )项不是文件系统的功能?
A.文件系统实现对文件的按名存取 B.负责实现数据的逻辑结构到物理结构的转换
C.提高磁盘的读写速度 D.提供对文件的存取方法和对文件的操作 946.
文件系统的主要目的是( )。 A.实现对文件的按名存取 B.实现虚拟存贮器
C.提高外围设备的输入输出速度 D.用于存贮系统文档 947.
按逻辑结构划分，文件主要有两类，UNIX中的文件系统采用﹎﹎﹎﹎。 A.网状文件
B.只读文件 C.读写文件 D.记录式文件 E.索引文件 F.流式文件 948.
通常，文件的逻辑结构可以分为两大类：无结构的( )和有结构的记录式文件。
A.堆文件 B. 流式文件 C. 索引文件 D.直接（Hash）文件 949.
通常，文件的逻辑结构中(
)组织方式，既适合于交互方式应用，也适合于批处理方式应用。 A.堆文件 B.
流式文件 C. 索引顺序文件 D. 顺序文件 950. 下面关于索引文件的论述中，第(
)条是正确的论述。
A.索引文件中，索引表的每个表项中含有相应记录的关键字和存放该记录的物理地址。
B.对顺序文件进行检索时，首先从FCB中读出文件的第一个盘块号；而对索引文件进行检索时，应先从FCB中读出文件索引表始址。
C.对于一个具有三级索引表的文件，存取一个记录通常要访问三次磁盘。
D.在文件较大时，无论是进行顺序存取还是随机存取，通常都是以索引文件方式为最快。
951. 下面关于顺序文件和链接文件的论述中错误的论述是( )。
A.顺序文件适于建立在顺序存储设备上，而不适合建立在磁盘上。
B.在链接文件中是在每个盘块中设置一链接指针，用于将文件的所有盘块链接起来。
C.顺序文件必须采用连续分配方式，而链接文件和索引文件则都可采取离散分配方式。
D.在MS-DOS中采用的是链接文件结构。 952.
文件信息的逻辑块号到磁盘物理块号的变换是由( )决定。 A. 逻辑结构 B. 页表
C. 物理结构 D. 重定位寄存器 953. 对于下列文件的物理结构，(
)只能采用顺序存取方式。 A.顺序文件 B.链接文件 C.索引文件 D.Hash文件 954.
一个采用一级索引文件系统，存取一块盘块信息通常要访问()次磁盘。 A.1 B.2
C.3 D.4 955.
一个采用二级索引文件系统，存取一块盘块信息通常要访问()次磁盘。 A.1 B.2
C.3 D.5 956.
一个采用三级索引文件系统，存取一块盘块信息通常要访问()次磁盘。 A.1 B.2
C.3 D.6 957.
设有一个包含1000个记录的索引文件，每个记录正好占用一个物理块。一个物理块可以存放10个索引表目。建立索引时，一个物理块应有一个索引表目，试问该文件至少应
该建立( )级索引〔假定一级索引占用一个物理块〕？ A.1 B.2 C.3 D.7 958.
设有一个包含1000个记录的索引文件，每个记录正好占用一个物理块。一个物理块可以存放10个索引表目。建立索引时，一个物理块应有一个索引表目，试问索引应占(
)个物理块？ A.1 B.11 C.111 D.1111 959.
设有一个包含1000个记录的索引文件，每个记录正好占用一个物理块。一个物理块可以存放10个索引表目。建立索引时，一个物理块应有一个索引表目，试问索引及其文件
本身应 占( )个物理块？ A.1000 B.1001 C.1011 D.1111 960.
文件管理实际上是对﹎﹎﹎﹎的管理。 A.主存空间 B.辅助存储空间
C.逻辑地址空间 D.物理地址空间 961. 在文件系统中设置一张(
)表，它是利用二进制的一位来表示磁盘中一个块的使用情况。 A.文件描述符表
B.链接指针表 C.文件表 D.空闲区表 E.位示图 962.
文件系统中用﹎﹎﹎﹎管理文件。 A.堆栈结构 B.指针 C.目录 D.页表 963.
为了允许不同用户的文件具有相同的文件名，通常在文件系统中采用﹎﹎﹎﹎。
A.重名翻译 B.多级目录 C.约定 D.路径 964. 文件系统的按名存取主要是通过(
)实现的。 A.存储空间管理 B.目录管理 C.文件安全性管理 D.文件读写管理 965.
Windows操作系统的一个文件的绝对路径名是从( )开始的整个通路上所有子目录
名组成的一个有序组合。 A.当前目录 B.根目录 C.家目录(home directory)
D.磁盘驱动器编号 966. 在UNIX (linux) 操作系统中文件的绝对路径名首先是(
)。 A.盘符 B. 根目录 C. 盘符或根目录 D. 以上都不是 967.
文件系统中每个文件有( )个文件控制块FCB。 A. 1 B.1或多于1 C.1或0 D.0 968.
将文件描述信息从目录项中分离出来（将文件控制块FCB分离为文件名和文件描述信息）
的好处是：( ) A.减少读文件时的I/O信息量 B.减少写文件时的I/O信息量
C.减少查文件时的I/O信息量 D.减少复制文件时的I/O信息量 969.
允许多个用户同时使用同一个共享文件时，下列( )做法是不对的。 A.
允许多个用户同时打开共享文件执行读操作 B. 允许读者和写者同时使用共享文件
C. 不允许读者和写者同时使用共享文件 D.
不允许多个写者同时对共享文件执行写操作 970.
操作系统为保证未经文件拥有者授权，任何其它用户不能使用该文件所提供的解决方法
是( ). A.文件保护 B.文件保密 C.文件转储 D.文件共享 971.
在linux/Unix中对文件有条件的共享是指：( )
A.给不同身份的用户赋予不同的访问权限
B.给不同身份的用户赋予相同的访问权限
C.给不同身份的用户赋予相同或不同的访问权限
D.给相同身份的用户赋予不同的访问权限 972.
假设在一个系统中一个文件有二个名字，它与一个文件保存为二个副本的区别是﹎﹎﹎
﹎。 A.前者比后者所占的存储空间大 B.前者需二个目录项，后者只需一个目录项
C.前者存取文件的速度快，后者存取速度慢
D.前者改变与某个名字相联系的文件时，另一个名字相联的文件也改变，后者的另一个副本不改变。
973. 用户请求使用一个已存在的文件时，其操作次序为( ) A.读／写→关闭 B.
打开→读／写 C.打开→读／写→关闭 974. 打开文件操作的使用是( )。
A.把整个文件从磁盘拷贝到内存 B.把文件目录项(FCB)从磁盘拷贝到内存
C.把整个文件和文件目录项(FCB)从磁盘拷贝到内存
D.把磁盘文件系统的控制管理信息从辅存读到内存 975. 976.
"桌上有一个空盒，盒内只允许放一个水果。妈妈轮流向盒内放桔子和苹果，儿子专等吃盒中的桔子，女儿专等吃盒中的苹果。若盒内已有水果，放者必须等待，若盒内没有自己
吃的水果，吃者必需等待。试在下述类PASCAL程序中虚线位置分别填上信号量、信号量初值和P、V操作实现三个进程正确的并发执行。
var
(信号量)﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎：semaphore：=
(信号量初值) ﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎﹎； begin
parbegin 妈:begin repeat 準備 ﹎﹎﹎﹎﹎﹎﹎﹎ 向盒内放桔子
﹎﹎﹎﹎﹎﹎﹎﹎ 準備 ﹎﹎﹎﹎﹎﹎﹎﹎ 向盒内放苹果 ﹎﹎﹎﹎﹎﹎﹎﹎
until false end 儿：begin repeat ﹎﹎﹎﹎﹎﹎﹎﹎ 拿盒中的桔子
﹎﹎﹎﹎﹎﹎﹎﹎ 吃桔子 until false end 女：begin repeat ﹎﹎﹎﹎﹎﹎﹎﹎
拿盒中的苹果 ﹎﹎﹎﹎﹎﹎﹎﹎ 吃苹果 until false end parend end " 977.
"假定在一个处理机上执行以下五个作业： 作业号 到达时间 运行时间 A 0 4 B 1
3 C 2 5 D 3 2 E 4 4
(1)画出采用FCFS调度算法时调度图，并计算每个作业的周转时间和计算平均周转时间。
(2)画出采用SJF调度算法时调度图，并计算每个作业的周转时间和计算平均周转时间。
(3)写出采用HRN（响应比高者优先）调度算法时选择作业号的次序和选择作业的依据（各作业的响应比）。
" 978. "试描述避免死锁的银行家算法，若系统运行中出现下述资源分配情况 进程
ALLOCATION NEED AVAILABLE A B C D A B C D A B C D P0 0 0 3 2 0 0 1 2 1 6
2 2 P1 1 0 0 0 1 7 5 0 P2 1 3 5 4 2 3 5 6 P3 0 3 3 2 0 6 5 2 P4 0 0 1 4
0 6 5 6
该系统是否安全？如果进程P2此时提出资源申请（1，2，2，2），系统能否将资源分配给它？为什么？
" 979. "1.
某虚拟存储器的用户空间共有32个页面，每页lKB，主存为16KB。假定某时刻系统为用户的第0、l、2、3页分别分配到物理块号为5、10、4、7中，试
分别写出虚拟地址1234和2345的页号和页内地址，并将虚拟地址变换为物理地址。"
980.
"考虑一个分页系统，其页表存放在内存，如果内存读写周期为1.0us，快表的访问时间为0.2us。如果设立一个可存放64个页表表项的快表，90%的地址变换可通
过快表完成，问内存平均存取周期为多少？" 981.
"在一个请求分页系统中，分别采用FIFO和
LRU页面置换算法时，假如一个作业的页面访问顺序为4，3，2，1，4，3，5，4，3，2，
l，5，当分配给该作业的物理块数M为4时，试试写出页面访问的过程，并计算访问中所发生的缺页次数和缺页率？"
982.
"一个文件系统中有一个20MB大文件和一个15KB小文件,当分别采用二级索引和UNIX
Sytem V 分配方案时(每块大小为2048B,每块地址用4B表示)，问:
(1)各文件系统管理的最大的文件是多少?
(2)每种方案对大、小二文件各需要多少专用块来记录文件的物理地址(说明各块的用途)
?
(3)如需要读大文件前面第5.5KB和后面（16M＋5.5KB）信息，则每个方案各需要多少次盘I/O操作?
" 983. "试述在设有快表的分页存贮管理系统的地址变换机构和地址变换过程。"
984. "试比较段式存贮管理与页式存贮管理异同？" 985.
"画出段式存贮管理系统地址变换机构。" 986.
"试述段页式存贮管理系统地址变换机构和地址变换过程。" 987.
"试述动态分区、分页和分段三种存储管理方案中如何实现信息的存储保护。"
988. "用户在使用配置UNIX/Linux
操作系统的计算机时不能将用户软盘随便插进和拿出，试从UNIX/Linux子文件系统的使用原理说明它需要一定的操作的依据
和操作的步骤。（写出在配置Linux/UNIX
OS的计算机上使用软盘的操作步骤和简要依据。）" 989.
"在某些系统中有这样的情况，假如某用户打开文件，向该文件中增加了若干新记录之后没有关闭文件就关机了，当他下次开机再打开文件时却无法读出所增加的新记录。试从打
开文件和关闭文件的作用出发，分析产生这种现象的原因，并说明编程时使用文件的操作的步骤。（写出在编程时使用文件的操作步骤和简要依据。）"
990. "什么是文件共享？试述UNIX系统中文件共享的实现方法和命令的使用。"
991. "试述UNIX (Linux) 树型带勾连的目录结构和查询方法。" 992.
"简述UNIX对文件实现存取控制的方法和命令的使用。" 993.
用户与操作系统的接口有 ， 两种。 994.
用户程序调用操作系统有关功能的途径是 。 995. UNIX系统是 ①
操作系统，DOS系统是 ② 操作系统。 996.
现代计算机中，CPU工作方式有目态和管态两种。目态是指运行 ①
程序，管态是指运行 ② 程序。执行编译程序时，CPU处于 ③ 。 997.
从资源分配的角度讲，计算机系统中的资源分为 、 、 和
。操作系统相应的组成部分是 、 、 和 。 998.
根据服务对象不同，常用的单处理机OS可以分为如下三种类型：
允许多个用户在其终端上同时交互地使用计算机的OS称为 ① ，它通常采用 ②
策略为用户服务； 允许用户把若干个作业提交计算机系统集中处理的OS，称为 ③
，衡量这种系统性能的一个主要指标是系统的 ④ ； 在 ⑤
的控制下，计算机系统能及时处理由过程控制反馈的数据并作出响应。设计这种系统时，应首先考虑系统的
⑥ 。 999. 实时系统通常采用 方法来提高可靠性。 1000.
计算机的操作系统是一种 。 A.应用软件 B.系统软件 C.工具软件
D.字表处理软件 1001. UNIX属于一种 操作系统。 A.分时系统 B.批处理系统
C.实时系统 D.分布式系统 1002. 操作系统是一组 程序。 A.文件管理
B.中断处理 C.资源管理 D.设备管理 1003. 下列四个操作系统中，是分时系统的为
。 A.CP／M B.MS－DOS C. UNIX D.WINDOWS NT 1004.
用户要在程序一级获得系统帮助，必须通过 。 A.进程调度 B.作业调度
C.键盘命令 D.系统调用 1005. 批处理系统的主要缺点是 。 A.CPU的利用率不高
B.失去了交互性 C.不具备并行性 D.以上都不是 1006. DOS操作系统主要的功能是
。 A.文件管理程序 B.中断处理程序 C.作业管理程序 D.打印管理程序 1007.
在Pascal程序中调用的sin（x）是 。 A.系统调用 B.标准子程序 C.操作系统命令
D.进程 1008. 计算机操作系统的功能是 。 A.把源程序代码转换为目标代码
B.实现计算机用户之间的相互交流 C.完成计算机硬件与软件之间的转换
D.控制、管理计算机系统的资源和程序的执行 1009.
在分时系统中，时间片一定时， ，响应时间越长。 A.内存越多 B.用户数越多
C.内存越少 D.用户数越少 1010. 1011. 1012. 1013. 1014. 1015. 1016.
"1）试说明硬中断（hardware interrupt）、异常（exception）和系统调用（system
call）的相同点和不同点。
2）下面代码完成在进入trap()函数前的准备工作。其中pushal完成包括esp在内的CPU寄存器压栈。试说明“pushl
%esp”的作用是什么？ =============trapentry.S (kern\\trap)=============
\#include \# vectors.S sends all traps here. .text .globl \_\_alltraps
\_\_alltraps: \# push registers to build a trap frame \# therefore make
the stack look like a struct trapframe pushl %ds pushl %es pushl %fs
pushl %gs pushal \# load GD\_KDATA into %ds and %es to set up data
segments for kernel movl $GD\_KDATA, %eax movw %ax, %ds movw %ax, %es
pushl %esp call trap \# pop the pushed stack pointer popl %esp \# return
falls through to trapret... .globl \_\_trapret \_\_trapret: \# restore
registers from stack popal \# restore %ds, %es, %fs and %gs popl %gs
popl %fs popl %es popl %ds \# get rid of the trap number and error code
addl $0x8, %esp iret =============Trap.c (kern\\trap)=============
...... /\* \* \* trap - handles or dispatches an exception/interrupt. if
and when trap() returns, \* the code in kern/trap/trapentry.S restores
the old CPU state saved in the \* trapframe and then uses the iret
instruction to return from the exception. \* \*/ void trap(struct
trapframe \*tf) { // dispatch based on what type of trap occurred
trap\_dispatch(tf); } ......" 1017.
"1）系统调用的参数传递有几种方式？各有什么特点？
2）sys\_exec是一个加载和执行指定可执行文件的系统调用。请说明在下面的ucore实现中，它的三个参数分别是以什么方式传递的。
=============Proc.c (kern\\process)============= ...... // do\_execve -
call exit\_mmap(mm)&pug;\_pgdir(mm) to reclaim memory space of current
process // - call load\_icode to setup new memory space accroding binary
prog. int do\_execve(const char \*name, int argc, const char \*\*argv) {
static\_assert(EXEC\_MAX\_ARG\_LEN \>= FS\_MAX\_FPATH\_LEN); struct
mm\_struct \*mm = current-\>mm; if (!(argc \>= 1 && argc <=
EXEC\_MAX\_ARG\_NUM)) { return -E\_INVAL; } char
local\_name[PROC\_NAME\_LEN + 1]; memset(local\_name, 0,
sizeof(local\_name)); char \*kargv[EXEC\_MAX\_ARG\_NUM]; const char
\*path; int ret = -E\_INVAL; lock\_mm(mm); if (name == NULL) {
snprintf(local\_name, sizeof(local\_name), " %d", current-\>pid); } else
{ if (!copy\_string(mm, local\_name, name, sizeof(local\_name))) {
unlock\_mm(mm); return ret; } } if ((ret = copy\_kargv(mm, argc, kargv,
argv)) != 0) { unlock\_mm(mm); return ret; } path = argv[0];
unlock\_mm(mm); files\_closeall(current-\>filesp); /\* sysfile\_open
will check the first argument path, thus we have to use a user- space
pointer, and argv[0] may be incorrect \*/ int fd; if ((ret = fd =
sysfile\_open(path, O\_RDONLY)) < 0) { goto execve\_exit; } if (mm !=
NULL) { lcr3(boot\_cr3); if (mm\_count\_dec(mm) == 0) { exit\_mmap(mm);
put\_pgdir(mm); mm\_destroy(mm); } current-\>mm = NULL; } ret=
-E\_NO\_MEM;; if ((ret = load\_icode(fd, argc, kargv)) != 0) { goto
execve\_exit; } put\_kargv(argc, kargv); set\_proc\_name(current,
local\_name); return 0; execve\_exit: put\_kargv(argc, kargv);
do\_exit(ret); panic("already exit: %e.\\n", ret); } ......
=============Syscall.c (kern\\syscall)============= ...... static int
sys\_exec(uint32\_t arg[]) { const char \*name = (const char \*)arg[0];
int argc = (int)arg[1]; const char \*\*argv = (const char \*\*)arg[2];
return do\_execve(name, argc, argv); } ...... static int
(\*syscalls[])(uint32\_t arg[]) = { [SYS\_exit] sys\_exit, [SYS\_fork]
sys\_fork, [SYS\_wait] sys\_wait, [SYS\_exec] sys\_exec, [SYS\_yield]
sys\_yield, [SYS\_kill] sys\_kill, [SYS\_getpid] sys\_getpid,
[SYS\_putc] sys\_putc, [SYS\_pgdir] sys\_pgdir, }; \#define
NUM\_SYSCALLS ((sizeof(syscalls)) / (sizeof(syscalls[0]))) void
syscall(void) { struct trapframe \*tf = current-\>tf; uint32\_t arg[5];
int num = tf-\>tf\_regs.reg\_eax; if (num \>= 0 && num < NUM\_SYSCALLS)
{ if (syscalls[num] != NULL) { arg[0] = tf-\>tf\_regs.reg\_edx; arg[1] =
tf-\>tf\_regs.reg\_ecx; arg[2] = tf-\>tf\_regs.reg\_ebx; arg[3] =
tf-\>tf\_regs.reg\_edi; arg[4] = tf-\>tf\_regs.reg\_esi;
tf-\>tf\_regs.reg\_eax = syscalls[num](arg); return ; } }
print\_trapframe(tf); panic("undefined syscall %d, pid = %d, name =
%s.\\n", num, current-\>pid, current-\>name); } ......
=============libs-user- ucore/syscall.c============= ...... int
sys\_exec(const char \*filename, const char \*\*argv, const char
\*\*envp) { return syscall(SYS\_exec, filename, argv, envp); } ......
=============libs-user-ucore/arch/i386/syscall.c============= ......
uint32\_t syscall(int num, ...) { va\_list ap; va\_start(ap, num);
uint32\_t a[MAX\_ARGS]; int i; for (i = 0; i < MAX\_ARGS; i++) { a[i] =
va\_arg(ap, uint32\_t); } va\_end(ap); uint32\_t ret; asm volatile ("int
%1;":"=a" (ret) :"i"(T\_SYSCALL), "a"(num), "d"(a[0]), "c"(a[1]),
"b"(a[2]), "D"(a[3]), "S"(a[4]) :"cc", "memory"); return ret; }" 1018.
"1）描述伙伴系统（Buddy
System）中对物理内存的分配和回收过程。2）假定一个操作系统内核中由伙伴系统管理的物理内存有1MB，试描述按下面顺序进行
物理内存分配和回收过程中，每次分配完成后的分配区域的首地址和大小，或每次回收完成后的空闲区域队列（要求说明，每个空闲块的首地址和大小）。建议给出分配和回收的
中间过程。 a) 进程A申请50KB； b) 进程B申请100KB； c) 进程C申请40KB； d)
进程D申请70KB； e) 进程B释放100KB； f) 进程E申请127KB； g) 进程D释放70KB；
h) 进程A释放50KB； i) 进程E释放127KB； j) 进程C释放40KB；" 1019.
"1）试用图示描述32位X86系统在采用4KB页面大小时的虚拟地址结构和地址转换过程。2）在采用4KB页面大小的32位X86的ucore虚拟存储系统中，进程
页面的起始地址由宏VPT确定。 \#define VPT 0x0D000000
请计算：2a)试给出页目录中自映射页表项的虚拟地址；2b)虚拟地址0X87654321对应的页目录项和页表项的虚拟地址。"
1020.
"试描述FIFO页面替换算法的基本原理，并swap\_fifo.c中未完成FIFA页面替换算法实验函数map\_swappable()和swap\_out\_vic
tim() 。 =============Defs.h (libs)============= /\* \* \* to\_struct -
get the struct from a ptr \* @ptr: a struct pointer of member \* @type:
the type of the struct this is embedded in \* @member: the name of the
member within the struct \* \*/ \#define to\_struct(ptr, type, member)
\\ ((type \*)((char \*)(ptr) - offsetof(type, member)))
=============Memlayout.h (kern\\mm)============= // convert list entry
to page \#define le2page(le, member) \\ to\_struct((le), struct Page,
member) =============List.h (libs)============= \#ifndef
\_\_LIBS\_LIST\_H\_\_ \#define \_\_LIBS\_LIST\_H\_\_ \#ifndef
\_\_ASSEMBLER\_\_ \#include /\* \* \* Simple doubly linked list
implementation. \* \* Some of the internal functions ("\_\_xxx") are
useful when manipulating \* whole lists rather than single entries, as
sometimes we already know \* the next/prev entries and we can generate
better code by using them \* directly rather than using the generic
single-entry routines. \* \*/ struct list\_entry { struct list\_entry
\*prev, \*next; }; typedef struct list\_entry list\_entry\_t; static
inline void list\_init(list\_entry\_t \*elm)
\_\_attribute\_\_((always\_inline)); static inline void
list\_add(list\_entry\_t \*listelm, list\_entry\_t \*elm)
\_\_attribute\_\_((always\_inline)); static inline void
list\_add\_before(list\_entry\_t \*listelm, list\_entry\_t \*elm)
\_\_attribute\_\_((always\_inline)); static inline void
list\_add\_after(list\_entry\_t \*listelm, list\_entry\_t \*elm)
\_\_attribute\_\_((always\_inline)); static inline void
list\_del(list\_entry\_t \*listelm) \_\_attribute\_\_((always\_inline));
static inline void list\_del\_init(list\_entry\_t \*listelm)
\_\_attribute\_\_((always\_inline)); static inline bool
list\_empty(list\_entry\_t \*list) \_\_attribute\_\_((always\_inline));
static inline list\_entry\_t \*list\_next(list\_entry\_t \*listelm)
\_\_attribute\_\_((always\_inline)); static inline list\_entry\_t
\*list\_prev(list\_entry\_t \*listelm)
\_\_attribute\_\_((always\_inline)); static inline void
\_\_list\_add(list\_entry\_t \*elm, list\_entry\_t \*prev,
list\_entry\_t \*next) \_\_attribute\_\_((always\_inline)); static
inline void \_\_list\_del(list\_entry\_t \*prev, list\_entry\_t \*next)
\_\_attribute\_\_((always\_inline)); /\* \* \* list\_init - initialize a
new entry \* @elm: new entry to be initialized \* \*/ static inline void
list\_init(list\_entry\_t \*elm) { elm-\>prev = elm-\>next = elm; } /\*
\* \* list\_add - add a new entry \* @listelm: list head to add after \*
@elm: new entry to be added \* \* Insert the new element @elm \*after\*
the element @listelm which \* is already in the list. \* \*/ static
inline void list\_add(list\_entry\_t \*listelm, list\_entry\_t \*elm) {
list\_add\_after(listelm, elm); } /\* \* \* list\_add\_before - add a
new entry \* @listelm: list head to add before \* @elm: new entry to be
added \* \* Insert the new element @elm \*before\* the element @listelm
which \* is already in the list. \* \*/ static inline void
list\_add\_before(list\_entry\_t \*listelm, list\_entry\_t \*elm) {
\_\_list\_add(elm, listelm-\>prev, listelm); } /\* \* \*
list\_add\_after - add a new entry \* @listelm: list head to add after
\* @elm: new entry to be added \* \* Insert the new element @elm
\*after\* the element @listelm which \* is already in the list. \* \*/
static inline void list\_add\_after(list\_entry\_t \*listelm,
list\_entry\_t \*elm) { \_\_list\_add(elm, listelm, listelm-\>next); }
/\* \* \* list\_del - deletes entry from list \* @listelm: the element
to delete from the list \* \* Note: list\_empty() on @listelm does not
return true after this, the entry is \* in an undefined state. \* \*/
static inline void list\_del(list\_entry\_t \*listelm) {
\_\_list\_del(listelm-\>prev, listelm-\>next); } /\* \* \*
list\_del\_init - deletes entry from list and reinitialize it. \*
@listelm: the element to delete from the list. \* \* Note: list\_empty()
on @listelm returns true after this. \* \*/ static inline void
list\_del\_init(list\_entry\_t \*listelm) { list\_del(listelm);
list\_init(listelm); } /\* \* \* list\_empty - tests whether a list is
empty \* @list: the list to test. \* \*/ static inline bool
list\_empty(list\_entry\_t \*list) { return list-\>next == list; } /\*
\* \* list\_next - get the next entry \* @listelm: the list head \*\*/
static inline list\_entry\_t \* list\_next(list\_entry\_t \*listelm) {
return listelm-\>next; } /\* \* \* list\_prev - get the previous entry
\* @listelm: the list head \*\*/ static inline list\_entry\_t \*
list\_prev(list\_entry\_t \*listelm) { return listelm-\>prev; } /\* \*
\* Insert a new entry between two known consecutive entries. \* \* This
is only for internal list manipulation where we know \* the prev/next
entries already! \* \*/ static inline void \_\_list\_add(list\_entry\_t
\*elm, list\_entry\_t \*prev, list\_entry\_t \*next) { prev-\>next =
next-\>prev = elm; elm-\>next = next; elm-\>prev = prev; } /\* \* \*
Delete a list entry by making the prev/next entries point to each other.
\* \* This is only for internal list manipulation where we know \* the
prev/next entries already! \* \*/ static inline void
\_\_list\_del(list\_entry\_t \*prev, list\_entry\_t \*next) {
prev-\>next = next; next-\>prev = prev; } \#endif /\* !\_\_ASSEMBLER\_\_
\*/ \#endif /\* !\_\_LIBS\_LIST\_H\_\_ \*/ ============= Swap\_fifo.c
(kern\\mm)============= \#include \#include \#include \#include
\#include \#include \#include /\* [wikipedia]The simplest Page
Replacement Algorithm(PRA) is a FIFO algorithm. \* (1) Prepare: In order
to implement FIFO PRA, we should manage all swappable pages, so we can
\* link these pages into pra\_list\_head according the time order. At
first you should \* be familiar to the struct list in list.h. struct
list is a simple doubly linked list \* implementation. You should know
howto USE: list\_init, list\_add(list\_add\_after), \*
list\_add\_before, list\_del, list\_next, list\_prev. Another tricky
method is to transform \* a general list struct to a special struct
(such as struct page). You can find some MACRO: \* le2page (in
memlayout.h), (in future labs: le2vma (in vmm.h), le2proc (in
proc.h),etc. \*/ list\_entry\_t pra\_list\_head; /\* \* (2)
\_fifo\_init\_mm: init pra\_list\_head and let mm-\>sm\_priv point to
the addr of pra\_list\_head. \* Now, From the memory control struct
mm\_struct, we can access FIFO PRA \*/ static int
\_fifo\_init\_mm(struct mm\_struct \*mm) {
list\_init(&pra;\_list\_head); mm-\>sm\_priv = &pra;\_list\_head;
//cprintf(" mm-\>sm\_priv %x in fifo\_init\_mm\\n",mm-\>sm\_priv);
return 0; } /\* \* (3)\_fifo\_map\_swappable: According FIFO PRA, we
should link the most recent arrival page at the back of pra\_list\_head
qeueue \*/ static int \_fifo\_map\_swappable(struct mm\_struct \*mm,
uintptr\_t addr, struct Page \*page, int swap\_in) { list\_entry\_t
\*head=(list\_entry\_t\*) mm-\>sm\_priv; list\_entry\_t
\*entry=&(page-\>pra\_page\_link); assert(entry != NULL && head !=
NULL); //record the page access situlation /\*LAB3 EXERCISE 2: YOUR
CODE\*/ //(1)link the most recent arrival page at the back of the
pra\_list\_head qeueue. ===Your code 2=== return 0; } /\* \*
(4)\_fifo\_swap\_out\_victim: According FIFO PRA, we should unlink the
earliest arrival page in front of pra\_list\_head qeueue, \* then set
the addr of addr of this page to ptr\_page. \*/ static int
\_fifo\_swap\_out\_victim(struct mm\_struct \*mm, struct Page \*\*
ptr\_page, int in\_tick) { list\_entry\_t \*head=(list\_entry\_t\*)
mm-\>sm\_priv; assert(head != NULL); assert(in\_tick==0); /\* Select the
victim \*/ /\*LAB3 EXERCISE 2: YOUR CODE\*/ //(1) unlink the earliest
arrival page in front of pra\_list\_head qeueue //(2) set the addr of
addr of this page to ptr\_page /\* Select the tail \*/ ===Your code 3===
return 0; } static int \_fifo\_check\_swap(void) { cprintf("write Virt
Page c in fifo\_check\_swap\\n"); \*(unsigned char \*)0x3000 = 0x0c;
assert(pgfault\_num==4); cprintf("write Virt Page a in
fifo\_check\_swap\\n"); \*(unsigned char \*)0x1000 = 0x0a;
assert(pgfault\_num==4); cprintf("write Virt Page d in
fifo\_check\_swap\\n"); \*(unsigned char \*)0x4000 = 0x0d;
assert(pgfault\_num==4); cprintf("write Virt Page b in
fifo\_check\_swap\\n"); \*(unsigned char \*)0x2000 = 0x0b;
assert(pgfault\_num==4); cprintf("write Virt Page e in
fifo\_check\_swap\\n"); \*(unsigned char \*)0x5000 = 0x0e;
assert(pgfault\_num==5); cprintf("write Virt Page b in
fifo\_check\_swap\\n"); \*(unsigned char \*)0x2000 = 0x0b;
assert(pgfault\_num==5); cprintf("write Virt Page a in
fifo\_check\_swap\\n"); \*(unsigned char \*)0x1000 = 0x0a;
assert(pgfault\_num==6); cprintf("write Virt Page b in
fifo\_check\_swap\\n"); \*(unsigned char \*)0x2000 = 0x0b;
assert(pgfault\_num==7); cprintf("write Virt Page c in
fifo\_check\_swap\\n"); \*(unsigned char \*)0x3000 = 0x0c;
assert(pgfault\_num==8); cprintf("write Virt Page d in
fifo\_check\_swap\\n"); \*(unsigned char \*)0x4000 = 0x0d;
assert(pgfault\_num==9); return 0; } static int \_fifo\_init(void) {
return 0; } static int \_fifo\_set\_unswappable(struct mm\_struct \*mm,
uintptr\_t addr) { return 0; } static int \_fifo\_tick\_event(struct
mm\_struct \*mm) { return 0; } struct swap\_manager swap\_manager\_fifo
= { .name = "fifo swap manager", .init = &\_fifo\_init, .init\_mm =
&\_fifo\_init\_mm, .tick\_event = &\_fifo\_tick\_event, .map\_swappable
= &\_fifo\_map\_swappable, .set\_unswappable =
&\_fifo\_set\_unswappable, .swap\_out\_victim =
&\_fifo\_swap\_out\_victim, .check\_swap = &\_fifo\_check\_swap, }; "
1021. "描述int
fork(void)系统调用的功能和接口，给出程序fork.c的输出结果，并用图示给出所有进程的父子关系。注：1）getpid()和getpp
id()是两个系统调用，分别返回本进程标识和父进程标识。2）你可以假定每次新进程创建时生成的进程标识是顺序加1得到的；在进程标识为1000的命令解释程序sh
ell中启动该程序的执行。 \#include \#include /\* getpid() and fork() are
system calls declared in unistd.h. They return \*/ /\* values of type
pid\_t. This pid\_t is a special type for process ids. \*/ /\* It's
equivalent to int. \*/ int main(void) { pid\_t childpid; int x = 5; int
i; childpid = fork(); for ( i = 0; i < 3; i++) { printf("This is process
%d; childpid = %d; The parent of this process has id %d; i = %d; x =
%d\\n", getpid(), childpid, getppid(), i, x); sleep(1); x++; } return 0;
}" 1022. 操作系统是（）。 A.硬件 B.系统软件 C.应用软件 D.虚拟机 1023.
下面关于SPOOL的叙述错误的是() A.SPOOL又称“斯普林”，是Simultaneous
Peripheral Operation On Line的缩写
B.SPOOL处理方式只是方便操作员，不能直接提高系统效率
C.SPOOL是把磁盘作为巨大缓冲器的技术
D.SPOOL处理方式不仅方便操作员，而且还提高系统效率 1024.
对于下列文件的物理结构，()只能采用顺序存取方式 A.顺序文件 B.链接文件
C.索引文件 D.Hash文件 1025.
设备分配问题中，算法实现时，同样要考虑安全性问题，防止在多个进程进行设备请求时，因相互等待对方释放所占设备所造成的()现象
A.瓶颈 B.碎片 C.系统抖动 D.死锁 1026.
下面有关可变分区管理中采用的主存分配算法说法错误的是（）
A.可变分区管理常采用的主存分配算法包括首次适应、最优适应和循环首次适应等算法
B.首次适应算法实现简单，但碎片过多使主存空间利用率降低
C.最优适应算法是最好的算法，但后到的较大作业很难得到满足
D.循环首次适应算法能使内存中的空闲分区分布得更均匀 1027.
如下表所示，虚拟段页式存储管理方案的特性为() 地址空间 空间浪费 存储共享
存储保护 动态扩充 动态连接 A.一维 大 不易 易 不可 不可 B.一维 小 易 不易
可以 不可 C.二维 大 不易 易 可以 可以 D.二维 小 易 易 可以 可以 1028.
执行一次磁盘输入输出操作所花费的时间包括
A.寻道时间、旋转延迟时间、传送时间和等待时间
B.寻道时间、等待时间、传送时间
C.等待时间、寻道时间、旋转延迟时间和读写时间
D.寻道时间、旋转延迟时间、传送时间 1029.
在下列操作系统的各个功能组成部分中,哪一个不需要有硬件的支持 A.进程调度
B.时钟管理 C.地址映射 D.中断系统 1030.
一个正在访问临界资源的进程由于申请等待I/O操作而被中断时
A.可以允许其他进程进入与该进程相关的临界区
B.不允许其他进程进入任何临界区 C.可以允许其他就绪进程抢占处理器，继续运行
D.不允许任何进程抢占处理器 1031. 批处理操作系统的特点不包括
A.提高了系统资源的利用率 B.用户可以直接干预作业的运行，具有交互性
C.提高了单位时间内的处理能力 D.提高了系统的吞吐率 1032.
下面不属于操作系统提供虚拟设备技术原因的是
A.独占设备可以作为共享设备来使用
B.独占设备使用的静态分配技术既不能充分利用设备，又不利于提高系统效率
C.在一定硬件和软件条件的基础上共享设备可以部分或全部地模拟独占设备的工作，提高独占设备的利用率和系统效率
D.计算机系统具有多道处理功能，允许多道作业同时执行 1033.
采用多道程序设计的实质之一是 A.以空间换取时间 B.将独享设备改造为共享设备
C.提高内存和I/O设备利用率 D.虚拟设备 1034. 访管指令的作用是 A.嵌套调用
B.用户使用的命令 C.用户态转换为核心态 D.保证运行在不同状态 1035.
不属于I/O控制方式的是 A.程序查询方式 B.复盖方式 C.DMA方式 D.中断驱动方式
1036. 软件共享的必要性是为了 A.节约内存空间 B.缩短运行时间
C.减少内外存对换信息量 D.A和C 1037.
下面软件系统中完全属于系统软件的一组是 A.操作系统、编译系统、windowsNT
B.接口软件、操作系统、软件开发工具
C.专用程序、财务管理软件、编译系统、操作系统
D.操作系统、接口软件、Office 2000 1038. 主存储器是
A.以“字”为单位进行编址的 B.是中央处理机能够直接访问的惟一的存储空间
C.与辅助存储器相比速度快、容量大、价格低的一类存储器
D.只能被CPU访问的存储器 1039. 特权指令 A.是可能影响系统安全的一类指令
B.既允许操作系统程序使用，又允许用户程序使用 C.是管态和目态运行的基本单位
D.是一种存储保护方法 1040. 下面有关选择进程调度算法的准则错误的是
A.尽量提高处理器利用率 B.尽可能提高系统吞吐量
C.适当增长进程在就绪队列中的等待时间 D.尽快响应交互式用户的请求 1041.
下面是关于重定位的有关描述，其中错误的是 A.绝对地址是主存空间的地址编号
B.用户程序中使用的从0地址开始的地址编号是逻辑地址
C.动态重定位中装入主存的作业仍保持原来的逻辑地址
D.静态重定位中装人主存的作业仍保持原来的逻辑地址 1042. 1043.
操作系统的所有程序都必须常驻内存 A.对 B.错 1044.
虚拟存储系统可以在每一台计算机上实现 A.对 B.错 1045.
执行系统调用时可以被中断 A.对 B.错 1046. 选择通道主要用于连接低速设备
A.对 B.错 1047.
在请求分页存储管理中，从主存中刚刚移走某一页面后，根据请求马上又调进该页，这种反复调进调出的现象，称为系统颠簸，也叫系统抖动
A.对 B.错 1048.
通道程序解决了I／O操作的独立性和各部件工作的并行性，采用通道技术后，能实现CPU与通道的并行操作
A.对 B.错 1049. 程序的顺序执行具有顺序性，封闭性和不可再现性 A.对 B.错
1050. 快表是高速缓存，是内存的一部分区域 A.对 B.错 1051.
磁盘上物理结构为链接结构的文件只能顺序存取 A.对 B.错 1052. 一旦出现死锁,
所有进程都不能运行 A.对 B.错 1053. 1054. "什么叫进程同步和互斥?举例说明"
1055. "什么是动态链接" 1056.
"在下面的条件下，若用一个位图来实现空闲表，那么存储空闲表需要多少位? （a）
共有500000个块，有200000个空闲块 （b） 共有500000个块，有0个空闲块" 1057.
"某系统使用请求分页存储管理，若页在内存中，满足一个内存请求需要150ns。若缺页率是10%，为使有效访问时间达到0.5ms,求不在内存的页面的平均访问时间
。" 1058.
"设P,Q,R共享一个缓冲区,P,Q构成一对生产者-消费者,R既为生产者又为消费?者。使用P,V
实现其同步。" 1059.
"此问题是对读者-写者问题的一个扩展，既如果读者写者均是平等的即二者都不优先情况下。
此问题的一个更高的版本是说，每个资源可以同时读取的人的个数也是有限的（限制数RN）。"
1060.
"有一个许多进程共享的数据区，有一些只读这个数据区的进程(reader)和一些只往数据区中写数据的进程(writer)；此外还需满足如下条件：
1.任意多的读进程可以同时读这个文件。
2.一次只有一个写进程可以往文件中写。
3.如果一个写进程正在往文件中写时，则禁止任何读进程和其他写进程。
实现基于先来先服务策略的读者－写者的问题，具体要求描述如下：
1.存在m个读者和n个写者，共享同一个缓冲区。
2.当没有读者在读，写者在写时，读者写者均可进入读或写。 3.当有读者在读时：
(1) 写者来了，则写者等待。 (2)
读者来了，则分两种情况处理：无写者等待，则读者可以直接进入读操作，如果有写者等待，则读者必须依次等待。
4.当有写者在写时，写者或读者来了，均需等待。
5.当写者写完后，如果等待队列中第一个是写者，则唤醒该写者；如果等待队列中第一个是读者，则唤醒该队列中从读者开始连续的所有读者。
6.当最后一个读者读后，如果有写者在等待，则唤醒第一个等待的写者。" 1061.
"在一间酒吧里有三个音乐爱好者队列，第一队的音乐爱好者只有随身听，第二队的只有音乐磁带，第三队只有电池。而要听音乐就必须随身听，音乐磁带和电池这三种物品俱全
。酒吧老板依次出售这三种物品中的任意两种。当一名音乐爱好者得到这三种物品并听完一首乐曲后，酒吧老板才能再一次出售这三种物品中的任意两种。于是第二名音乐爱好者
得到这三种物品，并开始听乐曲。全部买卖就这样进行下去。试用P，V操作正确解决这一买卖。"
1062.
"假设一个录像厅有0,1，2三种不同的录像片可由观众选择放映，录像厅的放映规则为:
任一时刻最多只能放映一种录像片，正在放映的录像片是自动循环放映的，最后一个观众主动离开时结束当前录像片的放映；
选择当前正在放映的录像片的观众可立即进入，允许同时有多位选择同一种录像片的观众同时观看，同时观看的观众数量不受限制；
等待观看其他录像片的观众按到达顺序排队，当一种新的录像片开始放映时，所有等待观看该录像片的观众可依次序进入录像厅同时观看。用一个进程代表一个观众。
要求:用信号量方法PV实现，并给出信号量定义和初始值。（最好也能写出录像厅的进程）"
1063. "银行有n个柜员,每个顾客进入银行后先取一个号,并且等着叫号,当一
个柜员空闲后,就叫下一个号." 1064.
"假设缓冲区buf1和缓冲区buf2无限大，进程p1向buf1写数据，进程p2向buf2写数据，
要求buf1数据个数和buf2数据个数的差保持在(m,n)之间(mref+=1;
returnpage-\>ref; } staticinlineint page\_ref\_dec(structPage\*page){
page-\>ref-=1; returnpage-\>ref; } ......
=============Pmm.c(kern\\mm)============= ......
//page\_remove\_pte-freeanPagesturctwhichisrelatedlinearaddressla
//-andclean(invalidate)ptewhichisrelatedlinearaddressla
//note:PTischanged,sotheTLBneedtobeinvalidate staticinlinevoid
page\_remove\_pte(pde\_t\*pgdir,uintptr\_tla,pte\_t\*ptep){
/\*LAB2EXERCISE3:YOURCODE \*
\*Pleasecheckifptepisvalid,andtlbmustbemanuallyupdatedifmappingisupdated
\* \*Maybeyouwanthelpcomment,BELOWcommentscanhelpyoufinishthecode \*
\*SomeUsefulMACROsandDEFINEs,youcanusetheminbelowimplementation.
\*MACROsorFunctions:
\*structPage\*pagepte2page(\*ptep):gettheaccordingpagefromthevalueofaptep
\*free\_page:freeapage
\*page\_ref\_dec(page):decreasepage-\>ref.NOTICE:ffpage-\>ref==0,thenthispageshouldbefree.
\*tlb\_invalidate(pde\_t\*pgdir,uintptr\_tla):InvalidateaTLBentry,butonlyifthepagetablesbeing
\*editedaretheonescurrentlyinusebytheprocessor. \*DEFINEs:
\*PTE\_P0x001//pagetable/directoryentryflagsbit:Present \*/ \#if0
if(0){//(1)checkifpagedirectoryispresent
structPage\*page=NULL;//(2)findcorrespondingpagetopte
//(3)decreasepagereference //(4)andfreethispagewhenpagereferencereachs0
//(5)clearsecondpagetableentry //(6)flushtlb } \#endif ===Yourcode1=== }
...... //invalidateaTLBentry,butonlyifthepagetablesbeing
//editedaretheonescurrentlyinusebytheprocessor. void
tlb\_invalidate(pde\_t\*pgdir,uintptr\_tla){ if(rcr3()==PADDR(pgdir)){
invlpg((void\*)la); } } staticvoid check\_alloc\_page(void){
pmm\_manager-\>check(); cprintf("check\_alloc\_page()succeeded!\\n"); }
=============Mmu.h(kern\\mm)=============
/\*pagetable/directoryentryflags\*/ \#definePTE\_P0x001//Present
\#definePTE\_W0x002//Writeable \#definePTE\_U0x004//User
\#definePTE\_PWT0x008//Write-Through
\#definePTE\_PCD0x010//Cache-Disable \#definePTE\_A0x020//Accessed
\#definePTE\_D0x040//Dirty \#definePTE\_PS0x080//PageSize
\#definePTE\_MBZ0x180//Bitsmustbezero
\#definePTE\_AVAIL0xE00//Availableforsoftwareuse
//ThePTE\_AVAILbitsaren'tusedbythekernelorinterpretedbythe
//hardware,souserprocessesareallowedtosetthemarbitrarily.
\#definePTE\_USER(PTE\_U|PTE\_W|PTE\_P) 1067. 1068. 1069. 1070. 1071.
1072. 1073. 1074. 1075. 1076. 1077. getpid() 1078. 1079. 1080. 1081.
1082.
在南开大学至天津大学间有一条弯曲的路，每次只允许一辆自行车通过，但中间有小的安全岛M（同时允许两辆车），可供两辆车在已进入两端小车错车，设计算法并使用P，V
实现。 ![](files/attach/images/content/20150326/14273452759802.png)
1083.
在一个盒子里，混装了数量相等的黑白围棋子·现在用自动分拣系统把黑子、白子分开，设分拣系统有二个进程P1
和P2 ，其中P1 拣白子；P2
拣黑子。规定每个进程每次拣一子；当一个进程在拣时，不允许另一个进程去拣；当一个进程拣了一子时，必须让另一个进程去拣．试写出两进程P1
和P2 能并发正确执行的程序。 1084.
设公共汽车上，司机和售票员的活动分别如下：司机的活动：启动车辆：正常行车；到站停车。售票员的活动：关车门；售票；开车门。在汽车不断地到站、停车、行驶过程中，
这两个活动有什么同步关系？用信号量和P 、V 操作实现它们的同步。
![](files/attach/images/content/20150326/14273453281116.png) 1085.
某寺庙，有小和尚、老和尚若干．庙内有一水缸，由小和尚提水入缸，供老和尚饮用。水缸可容纳10桶水，每次入水、取水仅为1桶，不可同时进行。水取自同一井中，水井径
窄，每次只能容纳一个水桶取水。设水桶个数为3个，试用信号灯和PV操作给出老和尚和小和尚的活动。
1086.
一座小桥(最多只能承重两个人)横跨南北两岸，任意时刻同一方向只允许一人过桥，南侧桥段和北侧桥段较窄只能通过一人，桥中央一处宽敞，允许两个人通过或歇息。试用信
号灯和PV操作写出南、北两岸过桥的同步算法。 1087.
两人公用一个账号，每次限存或取10元； 1088.
某高校计算机系开设网络课并安排上机实习，假设机房共有2m台机器，有2n名学生选课（m，n均大于等于1），规定：
\* 每两个学生组成一组，各占一台及其协同完成上机实习； \*
只有一组两个学生到齐，并且此时机房有空闲机器时，该组学生才能进入机房； \*
上机实习由一名教师检查，检查完毕，一组学生同时离开机房
试用P、V实现其过程。 \*\*注意：\*\* 本题目隐含一个进程(Guard )。 1089.
(18分)调度器是操作系统内核中依据调度算法进行进程切换选择的模块。
1）试描述步进调度算法(Stride Scheduling)的基本原理。 2）请补全下面
ucore代码中调度器和步进调度算法实现中所缺代码，以实现调度器和调度算法的功能。提示：每处需要补全的代码最少只需要一行，一共有9个空要填。
当然，你可以在需要补全代码的地方写多行来表达需要实现的功能，也允许修改已给出的代码。
3）试描述斜堆(skew heap)在这个步进调度算法中的作用。 kern/process/proc.h
==================== kern/process/proc.h ========================
\#ifndef \_\_KERN\_PROCESS\_PROC\_H\_\_ \#define
\_\_KERN\_PROCESS\_PROC\_H\_\_ \#include \#include \#include \#include
\#include // process's state in his life cycle enum proc\_state {
PROC\_UNINIT = 0, // uninitialized PROC\_SLEEPING, // sleeping
PROC\_RUNNABLE, // runnable(maybe running) PROC\_ZOMBIE, // almost dead,
and wait parent proc to reclaim his resource }; // Saved registers for
kernel context switches. // Don't need to save all the %fs etc. segment
registers, // because they are constant across kernel contexts. // Save
all the regular registers so we don't need to care // which are caller
save, but not the return register %eax. // (Not saving %eax just
simplifies the switching code.) // The layout of context must match code
in switch.S. struct context { uint32\_t eip; uint32\_t esp; uint32\_t
ebx; uint32\_t ecx; uint32\_t edx; uint32\_t esi; uint32\_t edi;
uint32\_t ebp; }; \#define PROC\_NAME\_LEN 15 \#define MAX\_PROCESS 4096
\#define MAX\_PID (MAX\_PROCESS \* 2) extern list\_entry\_t proc\_list;
struct proc\_struct { enum proc\_state state; // Process state int pid;
// Process ID int runs; // the running times of Proces uintptr\_t
kstack; // Process kernel stack volatile bool need\_resched; // bool
value: need to be rescheduled to release CPU? struct proc\_struct
\*parent; // the parent process struct mm\_struct \*mm; // Process's
memory management field struct context context; // Switch here to run
process struct trapframe \*tf; // Trap frame for current interrupt
uintptr\_t cr3; // CR3 register: the base addr of Page Directroy
Table(PDT) uint32\_t flags; // Process flag char name[PROC\_NAME\_LEN +
1]; // Process name list\_entry\_t list\_link; // Process link list
list\_entry\_t hash\_link; // Process hash list int exit\_code; // exit
code (be sent to parent proc) uint32\_t wait\_state; // waiting state
struct proc\_struct \*cptr, \*yptr, \*optr; // relations between
processes struct run\_queue \*rq; // running queue contains Process
list\_entry\_t run\_link; // the entry linked in run queue int
time\_slice; // time slice for occupying the CPU skew\_heap\_entry\_t
lab6\_run\_pool; // FOR LAB6 ONLY: the entry in the run pool uint32\_t
lab6\_stride; // FOR LAB6 ONLY: the current stride of the process
uint32\_t lab6\_priority; // FOR LAB6 ONLY: the priority of process, set
by lab6\_set\_priority(uint32\_t) }; \#define PF\_EXITING 0x00000001 //
getting shutdown \#define WT\_CHILD (0x00000001 | WT\_INTERRUPTED)
\#define WT\_INTERRUPTED 0x80000000 // the wait state could be
interrupted \#define le2proc(le, member) \\ to\_struct((le), struct
proc\_struct, member) extern struct proc\_struct \*idleproc, \*initproc,
\*current; void proc\_init(void); void proc\_run(struct proc\_struct
\*proc); int kernel\_thread(int (\*fn)(void \*), void \*arg, uint32\_t
clone\_flags); char \*set\_proc\_name(struct proc\_struct \*proc, const
char \*name); char \*get\_proc\_name(struct proc\_struct \*proc); void
cpu\_idle(void) \_\_attribute\_\_((noreturn)); struct proc\_struct
\*find\_proc(int pid); int do\_fork(uint32\_t clone\_flags, uintptr\_t
stack, struct trapframe \*tf); int do\_exit(int error\_code); int
do\_yield(void); int do\_execve(const char \*name, size\_t len, unsigned
char \*binary, size\_t size); int do\_wait(int pid, int \*code\_store);
int do\_kill(int pid); void lab6\_set\_priority(uint32\_t priority);
\#endif /\* !\_\_KERN\_PROCESS\_PROC\_H\_\_ \*/
=============================================================
kern/schedule/default\_sched.c
=============kern/schedule/default\_sched.c========================
\#include \#include \#include \#include \#include \#define
USE\_SKEW\_HEAP 1 /\* You should define the BigStride constant here\*/
/\* LAB6: YOUR CODE \*/ \#define BIG\_STRIDE 0x7FFFFFFF /\* ??? \*/ /\*
The compare function for two skew\_heap\_node\_t's and the \*
corresponding procs\*/ static int proc\_stride\_comp\_f(void \*a, void
\*b) { struct proc\_struct \*p = le2proc(a, lab6\_run\_pool); struct
proc\_struct \*q = le2proc(b, lab6\_run\_pool); int32\_t c =
p-\>lab6\_stride - q-\>lab6\_stride; if (c \> 0) return 1; else if (c ==
0) return 0; else return -1; } /\* \* stride\_init initializes the
run-queue rq with correct assignment for \* member variables, including:
\* \* - run\_list: should be a empty list after initialization. \* -
lab6\_run\_pool: NULL \* - proc\_num: 0 \* - max\_time\_slice: no need
here, the variable would be assigned by the caller. \* \* hint: see
proj13.1/libs/list.h for routines of the list structures. \*/ static
void stride\_init(struct run\_queue \*rq) { /\* LAB6: YOUR CODE \*/
list\_init(&(rq-\>run\_list)); rq-\>lab6\_run\_pool = NULL;
rq-\>proc\_num = 0; } /\* \* stride\_enqueue inserts the process
\`\`proc'' into the run-queue \* \`\`rq''. The procedure should
verify/initialize the relevant members \* of \`\`proc'', and then put
the \`\`lab6\_run\_pool'' node into the \* queue(since we use priority
queue here). The procedure should also \* update the meta date in
\`\`rq'' structure. \* \* proc-\>time\_slice denotes the time slices
allocation for the \* process, which should set to
rq-\>max\_time\_slice. \* \* hint: see proj13.1/libs/skew\_heap.h for
routines of the priority \* queue structures. \*/ static void
stride\_enqueue(struct run\_queue \*rq, struct proc\_struct \*proc) {
/\* LAB6: YOUR CODE \*/ \#if USE\_SKEW\_HEAP rq-\>lab6\_run\_pool =
……(1)……; \#else assert(list\_empty(&(proc-\>run\_link)));
list\_add\_before(&(rq-\>run\_list), &(proc-\>run\_link)); \#endif if
(proc-\>time\_slice == 0 || proc-\>time\_slice \> rq-\>max\_time\_slice)
{ proc-\>time\_slice = rq-\>max\_time\_slice; } proc-\>rq = rq;
rq-\>proc\_num ++; } /\* \* stride\_dequeue removes the process
\`\`proc'' from the run-queue \* \`\`rq'', the operation would be
finished by the skew\_heap\_remove \* operations. Remember to update the
\`\`rq'' structure. \* \* hint: see proj13.1/libs/skew\_heap.h for
routines of the priority \* queue structures. \*/ static void
stride\_dequeue(struct run\_queue \*rq, struct proc\_struct \*proc) {
/\* LAB6: YOUR CODE \*/ \#if USE\_SKEW\_HEAP rq-\>lab6\_run\_pool =
……(2)……; \#else assert(!list\_empty(&(proc-\>run\_link)) && proc-\>rq ==
rq); list\_del\_init(&(proc-\>run\_link)); \#endif rq-\>proc\_num --; }
/\* \* stride\_pick\_next pick the element from the \`\`run-queue'',
with the \* minimum value of stride, and returns the corresponding
process \* pointer. The process pointer would be calculated by macro
le2proc, \* see proj13.1/kern/process/proc.h for definition. Return NULL
if \* there is no process in the queue. \* \* When one proc structure is
selected, remember to update the stride \* property of the proc. (stride
+= BIG\_STRIDE / priority) \* \* hint: see proj13.1/libs/skew\_heap.h
for routines of the priority \* queue structures. \*/ static struct
proc\_struct \* stride\_pick\_next(struct run\_queue \*rq) { /\* LAB6:
YOUR CODE \*/ \#if USE\_SKEW\_HEAP if (rq-\>lab6\_run\_pool == NULL)
return NULL; struct proc\_struct \*p = le2proc(rq-\>lab6\_run\_pool,
lab6\_run\_pool); \#else list\_entry\_t \*le =
list\_next(&(rq-\>run\_list)); if (le == &rq-;\>run\_list) return NULL;
struct proc\_struct \*p = le2proc(le, run\_link); le = list\_next(le);
while (le != &rq-;\>run\_list) { struct proc\_struct \*q = le2proc(le,
run\_link); if ((int32\_t)(p-\>lab6\_stride - q-\>lab6\_stride) \> 0) p
= q; le = list\_next(le); } \#endif if (p-\>lab6\_priority == 0)
p-\>lab6\_stride += BIG\_STRIDE; else p-\>lab6\_stride = ……(3)……; return
p; } /\* \* stride\_proc\_tick works with the tick event of current
process. You \* should check whether the time slices for current process
is \* exhausted and update the proc struct \`\`proc''.
proc-\>time\_slice \* denotes the time slices left for current \*
process. proc-\>need\_resched is the flag variable for process \*
switching. \*/ static void stride\_proc\_tick(struct run\_queue \*rq,
struct proc\_struct \*proc) { /\* LAB6: YOUR CODE \*/ if
(proc-\>time\_slice \> 0) { ……(4)……; } if (proc-\>time\_slice == 0) {
……(5)……; } } struct sched\_class default\_sched\_class = { .name =
"stride\_scheduler", .init = stride\_init, .enqueue = ……(6)……, .dequeue
= ……(7)……, .pick\_next = ……(8)……, .proc\_tick = ……(9)……, };
=============================================================
libs/skew\_heap.h
====================libs/skew\_heap.h============================
\#ifndef \_\_LIBS\_SKEW\_HEAP\_H\_\_ \#define
\_\_LIBS\_SKEW\_HEAP\_H\_\_ struct skew\_heap\_entry { struct
skew\_heap\_entry \*parent, \*left, \*right; }; typedef struct
skew\_heap\_entry skew\_heap\_entry\_t; typedef int(\*compare\_f)(void
\*a, void \*b); static inline void skew\_heap\_init(skew\_heap\_entry\_t
\*a) \_\_attribute\_\_((always\_inline)); static inline
skew\_heap\_entry\_t \*skew\_heap\_merge( skew\_heap\_entry\_t \*a,
skew\_heap\_entry\_t \*b, compare\_f comp); static inline
skew\_heap\_entry\_t \*skew\_heap\_insert( skew\_heap\_entry\_t \*a,
skew\_heap\_entry\_t \*b, compare\_f comp)
\_\_attribute\_\_((always\_inline)); static inline skew\_heap\_entry\_t
\*skew\_heap\_remove( skew\_heap\_entry\_t \*a, skew\_heap\_entry\_t
\*b, compare\_f comp) \_\_attribute\_\_((always\_inline)); static inline
void skew\_heap\_init(skew\_heap\_entry\_t \*a) { a-\>left = a-\>right =
a-\>parent = NULL; } static inline skew\_heap\_entry\_t \*
skew\_heap\_merge(skew\_heap\_entry\_t \*a, skew\_heap\_entry\_t \*b,
compare\_f comp) { if (a == NULL) return b; else if (b == NULL) return
a; skew\_heap\_entry\_t \*l, \*r; if (comp(a, b) == -1) { r = a-\>left;
l = skew\_heap\_merge(a-\>right, b, comp); a-\>left = l; a-\>right = r;
if (l) l-\>parent = a; return a; } else { r = b-\>left; l =
skew\_heap\_merge(a, b-\>right, comp); b-\>left = l; b-\>right = r; if
(l) l-\>parent = b; return b; } } static inline skew\_heap\_entry\_t \*
skew\_heap\_insert(skew\_heap\_entry\_t \*a, skew\_heap\_entry\_t \*b,
compare\_f comp) { skew\_heap\_init(b); return skew\_heap\_merge(a, b,
comp); } static inline skew\_heap\_entry\_t \*
skew\_heap\_remove(skew\_heap\_entry\_t \*a, skew\_heap\_entry\_t \*b,
compare\_f comp) { skew\_heap\_entry\_t \*p = b-\>parent;
skew\_heap\_entry\_t \*rep = skew\_heap\_merge(b-\>left, b-\>right,
comp); if (rep) rep-\>parent = p; if (p) { if (p-\>left == b) p-\>left =
rep; else p-\>right = rep; return a; } else return rep; } \#endif /\*
!\_\_LIBS\_SKEW\_HEAP\_H\_\_ \*/
============================================================= 1090.
(15分)公平的读者-写者（Reader-Writer
Problem）问题是指，多个读者进程（Reader）与多个写者进程（Writer）共享一个数据区；读者进程和写者进程对共享数据区的访问满足下列条件。
1）多个读者进程可以同时对共享数据区进行访问；
2）多个写者进程只能对共享数据区进行互斥访问；
3）读者进程与写者进程只能对共享数据区进行互斥访问；
4）当有写者进程等待时，其后到达的读者进程不能先于该写者进程对共享数据区进行访问；
5）当有读者进程等待时，其后到达的写者进程不能先于该读者进程对共享数据区进行访问；
试用信号量机制实现读者进程Reader（）和写者进程
Writer（）。要求：用信号量方法（不允许使用信号量集），并给出信号量定义和初始值；在代码中要有适当的注释，以说明信号量定义的作用和代码的含义；用类
C 语言描述共享变量和函数。 1091.
(8分)某计算机系统中有18个同类型共享资源，有K个进程竞争使用，每个进程最多需要3个共享资源。该系统不会发生死锁的K的最大值是多少？要求给出计算过程，并说
明理由。 1092. (8分)给出下面程序fork-example.cpp的输出结果；
=====================fork-example.cpp===========================
\#include \#include \#include \#include \#include using namespace std;
int globalVariable = 2; main() { string sIdentifier; int iStackVariable
= 20; pid\_t pID = fork(); if (pID == 0) { sIdentifier = "Child Process:
"; globalVariable++; iStackVariable++; } else if (pID < 0) { cerr <<
"Failed to fork" << endl; exit(1); } else { sIdentifier = "Parent
Process:"; } cout << sIdentifier; cout << " Global variable: " <<
globalVariable; cout << " Stack variable: " << iStackVariable << endl; }
============================================================= 1093.
(16分)下面是ucore内核中与yield()系统调用实现相关源代码，可实现用户线程主动放弃CPU使用权的功能。
1）试描述ucore中用户进程利用yield()进行主动让出CPU的工作过程；
2）请补全其中所缺的代码，以正确完成从用户态函数yield()的功能。提示：每处需要补全的代码最少只需要一行，一共有11个空要填。当然，你可以在需要补全代码
的地方写多行来表达需要实现的功能，也允许修改已给出的代码。
libs-user-ucore/syscall.h ================= libs-user-ucore/syscall.h
======================== \#ifndef \_\_USER\_LIBS\_SYSCALL\_H\_\_
\#define \_\_USER\_LIBS\_SYSCALL\_H\_\_ \#include ...... int
sys\_yield(void); ...... \#endif /\* !\_\_USER\_LIBS\_SYSCALL\_H\_\_ \*/
=============================================================
libs-user-ucore/arch/i386/syscall.c
=============libs-user-ucore/arch/i386/syscall.c====================
\#include \#include \#include \#include \#include \#include \#include
\#define MAX\_ARGS 5 uint32\_t syscall(int num, ...) { va\_list ap;
va\_start(ap, num); uint32\_t a[MAX\_ARGS]; int i; for (i = 0; i <
MAX\_ARGS; i ++) { a[i] = va\_arg(ap, uint32\_t); } va\_end(ap);
uint32\_t ret; asm volatile ( "int %1;" : "=a" (ret) : "i" (T\_SYSCALL),
"a" (num), "d" (a[0]), "c" (a[1]), "b" (a[2]), "D" (a[3]), "S" (a[4]) :
"cc", "memory"); return ret; }
=============================================================
libs-user-ucore/syscall.c
==================libs-user-ucore/syscall.c========================
\#include \#include \#include \#include \#include \#include \#include
extern uintptr\_t syscall (int num, ...); ...... int sys\_yield(void) {
return ……(1)……; } ......
=============================================================
kern-ucore/glue-ucore/libs/unistd.h
=============kern-ucore/glue-ucore/libs/unistd.h===================
\#ifndef \_\_LIBS\_UNISTD\_H\_\_ \#define \_\_LIBS\_UNISTD\_H\_\_
\#define T\_SYSCALL 0x80 /\* syscall number \*/ ...... \#define
SYS\_yield 10 ...... \#endif /\* !\_\_LIBS\_UNISTD\_H\_\_ \*/
=============================================================
kern-ucore/arch/i386/glue-ucore/trap.c =============
kern-ucore/arch/i386/glue-ucore/trap.c =============== ...... static
void trap\_dispatch(struct trapframe \*tf) { char c; int ret; switch
(tf-\>tf\_trapno) { case T\_DEBUG: case T\_BRKPT: debug\_monitor(tf);
break; case T\_PGFLT: if ((ret = pgfault\_handler(tf)) != 0) {
print\_trapframe(tf); if (pls\_read(current) == NULL) { panic("handle
pgfault failed. %e\\n", ret); } else { if (trap\_in\_kernel(tf)) {
panic("handle pgfault failed in kernel mode. %e\\n", ret); }
kprintf("killed by kernel.\\n"); do\_exit(-E\_KILLED); } } break; case
……(2)……: syscall(); break; case IRQ\_OFFSET + IRQ\_TIMER: ticks ++;
assert(pls\_read(current) != NULL); run\_timer\_list(); break; case
IRQ\_OFFSET + IRQ\_COM1: case IRQ\_OFFSET + IRQ\_KBD: if ((c =
cons\_getc()) == 13) { debug\_monitor(tf); } else { extern void
dev\_stdin\_write(char c); dev\_stdin\_write(c); } break; case
IRQ\_OFFSET + IRQ\_IDE1: case IRQ\_OFFSET + IRQ\_IDE2: /\* do nothing
\*/ break; default: print\_trapframe(tf); if (pls\_read(current) !=
NULL) { kprintf("unhandled trap.\\n"); do\_exit(-E\_KILLED); }
panic("unexpected trap in kernel.\\n"); } } void trap(struct trapframe
\*tf) { // used for previous projects if (pls\_read(current) == NULL) {
trap\_dispatch(tf); } else { // keep a trapframe chain in stack struct
trapframe \*otf = pls\_read(current)-\>tf; pls\_read(current)-\>tf = tf;
bool in\_kernel = trap\_in\_kernel(tf); trap\_dispatch(tf);
pls\_read(current)-\>tf = otf; if (!in\_kernel) { may\_killed(); if
(pls\_read(current)-\>need\_resched) { ……(3)……; } } } }
=============================================================
kern-ucore/schedule/sched.c
=============kern-ucore/schedule/sched.c=========================
\#include \#include \#include \#include \#include \#include \#include
\#include \#include \#define current (pls\_read(current)) \#define
idleproc (pls\_read(idleproc)) ...... \#include \#define MT\_SUPPORT
void schedule(void) { bool intr\_flag; struct proc\_struct \*next;
\#ifndef MT\_SUPPORT list\_entry\_t head; int lapic\_id =
pls\_read(lapic\_id); \#endif local\_intr\_save(intr\_flag); int
lcpu\_count = pls\_read(lcpu\_count); { current-\>need\_resched =
……(4)……; \#ifndef MT\_SUPPORT if (current-\>mm) {
assert(current-\>mm-\>lapic == lapic\_id); current-\>mm-\>lapic = -1; }
\#endif if (current-\>state == PROC\_RUNNABLE && current-\>pid \>=
lcpu\_count) { sched\_class\_enqueue(current); } \#ifndef MT\_SUPPORT
list\_init(&head;); while (1) { next = ……(5)……; if (next != NULL)
sched\_class\_dequeue(next); if (next && next-\>mm && next-\>mm-\>lapic
!= -1) { list\_add(&head;, &(next-\>run\_link)); } else { list\_entry\_t
\*cur; while ((cur = list\_next(&head;)) != &head;) {
list\_del\_init(cur); sched\_class\_enqueue(le2proc(cur, run\_link)); }
break; } } \#else next = ……(6)……; if (next != NULL)
sched\_class\_dequeue(next); \#endif /\* !MT\_SUPPORT \*/ if (next ==
NULL) { next = ……(7)……; } next-\>runs ++; /\* Collect information
here\*/ if (sched\_collect\_info) { int lcpu\_count =
pls\_read(lcpu\_count); int lcpu\_idx = pls\_read(lcpu\_idx); int loc =
sched\_info\_head[lcpu\_idx]; int prev =
sched\_info\_pid[loc\*lcpu\_count + lcpu\_idx]; if (next-\>pid == prev)
sched\_info\_times[loc\*lcpu\_count + lcpu\_idx] ++; else {
sched\_info\_head[lcpu\_idx] ++; if (sched\_info\_head[lcpu\_idx] \>=
PGSIZE / sizeof(uint16\_t) / lcpu\_count) sched\_info\_head[lcpu\_idx] =
0; loc = sched\_info\_head[lcpu\_idx]; uint16\_t prev\_pid =
sched\_info\_pid[loc\*lcpu\_count + lcpu\_idx]; uint16\_t prev\_times =
sched\_info\_times[loc\*lcpu\_count + lcpu\_idx]; if (prev\_times \> 0
&& prev\_pid \>= lcpu\_count + 2) sched\_slices[lcpu\_idx][prev\_pid %
SLICEPOOL\_SIZE] += prev\_times; sched\_info\_pid[loc\*lcpu\_count +
lcpu\_idx] = next-\>pid; sched\_info\_times[loc\*lcpu\_count +
lcpu\_idx] = 1; } } \#ifndef MT\_SUPPORT assert(!next-\>mm ||
next-\>mm-\>lapic == -1); if (next-\>mm) next-\>mm-\>lapic = lapic\_id;
\#endif if (next != current) { ……(8)……; } }
local\_intr\_restore(intr\_flag); } void add\_timer(timer\_t \*timer) {
bool intr\_flag; local\_intr\_save(intr\_flag); { assert(timer-\>expires
\> 0 && timer-\>proc != NULL);
assert(list\_empty(&(timer-\>timer\_link))); list\_entry\_t \*le =
list\_next(&timer;\_list); while (le != &timer;\_list) { timer\_t \*next
= le2timer(le, timer\_link); if (timer-\>expires < next-\>expires) {
next-\>expires -= timer-\>expires; break; } timer-\>expires -=
next-\>expires; le = list\_next(le); } list\_add\_before(le,
&(timer-\>timer\_link)); } local\_intr\_restore(intr\_flag); } ......
=============================================================
kern-ucore/process/proc.c
================kern-ucore/process/proc.c======================== ......
// proc\_run - make process "proc" running on cpu // NOTE: before call
switch\_to, should load base addr of "proc"'s new PDT void
proc\_run(struct proc\_struct \*proc) { if (proc != current) { bool
intr\_flag; struct proc\_struct \*prev = current, \*next = proc; //
kprintf("(%d) =\> %d\\n", lapic\_id, next-\>pid);
local\_intr\_save(intr\_flag); { pls\_write(current, proc);
load\_rsp0(next-\>kstack + KSTACKSIZE);
mp\_set\_mm\_pagetable(next-\>mm); ……(9)……; }
local\_intr\_restore(intr\_flag); } } ...... // do\_yield - ask the
scheduler to reschedule int do\_yield(void) { current-\>need\_resched =
……(10)……; return 0; } ......
=============================================================
kern-ucore/arch/i386/syscall/syscall.c
=============kern-ucore/arch/i386/syscall/syscall.c=================
...... static uint32\_t sys\_yield(uint32\_t arg[]) { return ……(11)……; }
...... static uint32\_t (\*syscalls[])(uint32\_t arg[]) = { ......
[SYS\_yield] sys\_yield, ...... }; \#define NUM\_SYSCALLS
((sizeof(syscalls)) / (sizeof(syscalls[0]))) void syscall(void) { struct
trapframe \*tf = pls\_read(current)-\>tf; uint32\_t arg[5]; int num =
tf-\>tf\_regs.reg\_eax; if (num \>= 0 && num < NUM\_SYSCALLS) { if
(syscalls[num] != NULL) { arg[0] = tf-\>tf\_regs.reg\_edx; arg[1] =
tf-\>tf\_regs.reg\_ecx; arg[2] = tf-\>tf\_regs.reg\_ebx; arg[3] =
tf-\>tf\_regs.reg\_edi; arg[4] = tf-\>tf\_regs.reg\_esi;
tf-\>tf\_regs.reg\_eax = syscalls[num](arg); return ; } }
print\_trapframe(tf); panic("undefined syscall %d, pid = %d, name =
%s.\\n", num, pls\_read(current)-\>pid, pls\_read(current)-\>name); }
============================================================= 1094.
(18分)文件系统是操作系统内核中用于持久保存数据的功能模块。
1）试描述SFS文件系统中的文件存储组织，即文件内部数据块存储位置和顺序的组织方法；
2）试描述ucore文件系统在一个SFS文件的最后附加一个新数据块实现方法；
3）试解释下面
ucore代码中文件系统实现中与append\_block()函数相关的指定代码行的作用。注意：需要解释的代码共有12处。
kern/fs/sfs/sfs.h
========================kern/fs/sfs/sfs.h========================
\#ifndef \_\_KERN\_FS\_SFS\_SFS\_H\_\_ \#define
\_\_KERN\_FS\_SFS\_SFS\_H\_\_ \#include \#include \#include \#include
\#include \#define SFS\_MAGIC 0x2f8dbe2a /\* magic number for sfs \*/
\#define SFS\_BLKSIZE PGSIZE /\* size of block \*/ \#define SFS\_NDIRECT
12 /\* \# of direct blocks in inode \*/ \#define SFS\_MAX\_INFO\_LEN 31
/\* max length of infomation \*/ \#define SFS\_MAX\_FNAME\_LEN
FS\_MAX\_FNAME\_LEN /\* max length of filename \*/ \#define
SFS\_MAX\_FILE\_SIZE (1024UL \* 1024 \* 128) /\* max file size (128M)
\*/ \#define SFS\_BLKN\_SUPER 0 /\* block the superblock lives in \*/
\#define SFS\_BLKN\_ROOT 1 /\* location of the root dir inode \*/
\#define SFS\_BLKN\_FREEMAP 2 /\* 1st block of the freemap \*/ /\* \# of
bits in a block \*/ \#define SFS\_BLKBITS (SFS\_BLKSIZE \* CHAR\_BIT)
/\* \# of entries in a block \*/ \#define SFS\_BLK\_NENTRY (SFS\_BLKSIZE
/ sizeof(uint32\_t)) /\* file types \*/ \#define SFS\_TYPE\_INVAL 0 /\*
Should not appear on disk \*/ \#define SFS\_TYPE\_FILE 1 \#define
SFS\_TYPE\_DIR 2 \#define SFS\_TYPE\_LINK 3 /\* \* On-disk superblock
\*/ struct sfs\_super { uint32\_t magic; /\* magic number, should be
SFS\_MAGIC \*/ uint32\_t blocks; /\* \# of blocks in fs \*/ uint32\_t
unused\_blocks; /\* \# of unused blocks in fs \*/ char
info[SFS\_MAX\_INFO\_LEN + 1]; /\* infomation for sfs \*/ }; /\* inode
(on disk) \*/ struct sfs\_disk\_inode { uint32\_t size; /\* size of the
file (in bytes) \*/ uint16\_t type; /\* one of SYS\_TYPE\_\* above \*/
uint16\_t nlinks; /\* \# of hard links to this file \*/ uint32\_t
blocks; /\* ……(1)…… \*/ uint32\_t direct[SFS\_NDIRECT]; /\* ……(2)…… \*/
uint32\_t indirect; /\* ……(3)…… \*/ // uint32\_t db\_indirect; /\*
double indirect blocks \*/ // unused }; /\* file entry (on disk) \*/
struct sfs\_disk\_entry { uint32\_t ino; /\* inode number \*/ char
name[SFS\_MAX\_FNAME\_LEN + 1]; /\* file name \*/ }; \#define
sfs\_dentry\_size \\ sizeof(((struct sfs\_disk\_entry \*)0)-\>name) /\*
inode for sfs \*/ struct sfs\_inode { struct sfs\_disk\_inode \*din; /\*
on-disk inode \*/ uint32\_t ino; /\* inode number \*/ bool dirty; /\*
true if inode modified \*/ int reclaim\_count; /\* kill inode if it hits
zero \*/ semaphore\_t sem; /\* semaphore for din \*/ list\_entry\_t
inode\_link; /\* entry for linked-list in sfs\_fs \*/ list\_entry\_t
hash\_link; /\* entry for hash linked-list in sfs\_fs \*/ }; \#define
le2sin(le, member) \\ to\_struct((le), struct sfs\_inode, member) /\*
filesystem for sfs \*/ struct sfs\_fs { struct sfs\_super super; /\*
on-disk superblock \*/ struct device \*dev; /\* device mounted on \*/
struct bitmap \*freemap; /\* blocks in use are mared 0 \*/ bool
super\_dirty; /\* true if super/freemap modified \*/ void \*sfs\_buffer;
/\* buffer for non-block aligned io \*/ semaphore\_t fs\_sem; /\*
semaphore for fs \*/ semaphore\_t io\_sem; /\* semaphore for io \*/
semaphore\_t mutex\_sem; /\* semaphore for link/unlink and rename \*/
list\_entry\_t inode\_list; /\* inode linked-list \*/ list\_entry\_t
\*hash\_list; /\* inode hash linked-list \*/ }; /\* hash for sfs \*/
\#define SFS\_HLIST\_SHIFT 10 \#define SFS\_HLIST\_SIZE (1 <<
SFS\_HLIST\_SHIFT) \#define sin\_hashfn(x) (hash32(x,
SFS\_HLIST\_SHIFT)) /\* size of freemap (in bits) \*/ \#define
sfs\_freemap\_bits(super) ROUNDUP((super)-\>blocks, SFS\_BLKBITS) /\*
size of freemap (in blocks) \*/ \#define sfs\_freemap\_blocks(super)
ROUNDUP\_DIV((super)-\>blocks, SFS\_BLKBITS) struct fs; struct inode;
void sfs\_init(void); int sfs\_mount(const char \*devname); void
lock\_sfs\_fs(struct sfs\_fs \*sfs); void lock\_sfs\_io(struct sfs\_fs
\*sfs); void lock\_sfs\_mutex(struct sfs\_fs \*sfs); void
unlock\_sfs\_fs(struct sfs\_fs \*sfs); void unlock\_sfs\_io(struct
sfs\_fs \*sfs); void unlock\_sfs\_mutex(struct sfs\_fs \*sfs); int
sfs\_rblock(struct sfs\_fs \*sfs, void \*buf, uint32\_t blkno, uint32\_t
nblks); int sfs\_wblock(struct sfs\_fs \*sfs, void \*buf, uint32\_t
blkno, uint32\_t nblks); int sfs\_rbuf(struct sfs\_fs \*sfs, void \*buf,
size\_t len, uint32\_t blkno, off\_t offset); int sfs\_wbuf(struct
sfs\_fs \*sfs, void \*buf, size\_t len, uint32\_t blkno, off\_t offset);
int sfs\_sync\_super(struct sfs\_fs \*sfs); int
sfs\_sync\_freemap(struct sfs\_fs \*sfs); int sfs\_clear\_block(struct
sfs\_fs \*sfs, uint32\_t blkno, uint32\_t nblks); int
sfs\_load\_inode(struct sfs\_fs \*sfs, struct inode \*\*node\_store,
uint32\_t ino); \#endif /\* !\_\_KERN\_FS\_SFS\_SFS\_H\_\_ \*/
=============================================================
tools/mksfs.c =======================
tools/mksfs.c=========================== ...... \#define SFS\_MAGIC
0x2f8dbe2a \#define SFS\_NDIRECT 12 \#define SFS\_BLKSIZE 4096 // 4K
\#define SFS\_MAX\_NBLKS (1024UL \* 512) // 4K \* 512K \#define
SFS\_MAX\_INFO\_LEN 31 \#define SFS\_MAX\_FNAME\_LEN 255 \#define
SFS\_MAX\_FILE\_SIZE (1024UL \* 1024 \* 128) // 128M \#define
SFS\_BLKBITS (SFS\_BLKSIZE \* CHAR\_BIT) \#define SFS\_TYPE\_FILE 1
\#define SFS\_TYPE\_DIR 2 \#define SFS\_TYPE\_LINK 3 \#define
SFS\_BLKN\_SUPER 0 \#define SFS\_BLKN\_ROOT 1 \#define
SFS\_BLKN\_FREEMAP 2 struct cache\_block { uint32\_t ino; struct
cache\_block \*hash\_next; void \*cache; }; struct cache\_inode { struct
inode { uint32\_t size; uint16\_t type; uint16\_t nlinks; uint32\_t
blocks; uint32\_t direct[SFS\_NDIRECT]; uint32\_t indirect; uint32\_t
db\_indirect; } inode; ino\_t real; uint32\_t ino; uint32\_t nblks;
struct cache\_block \*l1, \*l2; struct cache\_inode \*hash\_next; };
struct sfs\_fs { struct { uint32\_t magic; uint32\_t blocks; uint32\_t
unused\_blocks; char info[SFS\_MAX\_INFO\_LEN + 1]; } super; struct
subpath { struct subpath \*next, \*prev; char \*subname; } \_\_sp\_nil,
\*sp\_root, \*sp\_end; int imgfd; uint32\_t ninos, next\_ino; struct
cache\_inode \*root; struct cache\_inode \*inodes[HASH\_LIST\_SIZE];
struct cache\_block \*blocks[HASH\_LIST\_SIZE]; }; struct sfs\_entry {
uint32\_t ino; char name[SFS\_MAX\_FNAME\_LEN + 1]; }; static uint32\_t
sfs\_alloc\_ino(struct sfs\_fs \*sfs) { if (sfs-\>next\_ino <
sfs-\>ninos) { sfs-\>super.unused\_blocks --; return sfs-\>next\_ino ++;
} bug("out of disk space.\\n"); } ...... \#define show\_fullpath(sfs,
name) subpath\_show(stderr, sfs, name) void open\_dir(struct sfs\_fs
\*sfs, struct cache\_inode \*current, struct cache\_inode \*parent);
void open\_file(struct sfs\_fs \*sfs, struct cache\_inode \*file, const
char \*filename, int fd); void open\_link(struct sfs\_fs \*sfs, struct
cache\_inode \*file, const char \*filename); \#define SFS\_BLK\_NENTRY
(SFS\_BLKSIZE / sizeof(uint32\_t)) \#define SFS\_L0\_NBLKS SFS\_NDIRECT
\#define SFS\_L1\_NBLKS (SFS\_BLK\_NENTRY + SFS\_L0\_NBLKS) \#define
SFS\_L2\_NBLKS (SFS\_BLK\_NENTRY \* SFS\_BLK\_NENTRY + SFS\_L1\_NBLKS)
\#define SFS\_LN\_NBLKS (SFS\_MAX\_FILE\_SIZE / SFS\_BLKSIZE) static
void update\_cache(struct sfs\_fs \*sfs, struct cache\_block \*\*cbp,
uint32\_t \*inop) { uint32\_t ino = \*inop; struct cache\_block \*cb =
\*cbp; if (ino == 0) { cb = alloc\_cache\_block(sfs, 0); ino = cb-\>ino;
} else if (cb == NULL || cb-\>ino != ino) { cb =
search\_cache\_block(sfs, ino); assert(cb != NULL && cb-\>ino == ino); }
\*cbp = cb, \*inop = ino; } static void append\_block(struct sfs\_fs
\*sfs, struct cache\_inode \*file, size\_t size, uint32\_t ino, const
char \*filename) { static\_assert(SFS\_LN\_NBLKS <= SFS\_L2\_NBLKS);
assert(size <= SFS\_BLKSIZE); uint32\_t nblks = file-\>nblks; struct
inode \*inode = &(file-\>inode); if (nblks \>= SFS\_LN\_NBLKS) {
open\_bug(sfs, filename, "file is too big.\\n"); } if (nblks <
SFS\_L0\_NBLKS) { /\* ……(4)…… \*/ inode-\>direct[nblks] = ino; /\*
……(5)…… \*/ } else if (nblks < SFS\_L1\_NBLKS) { /\* ……(6)…… \*/ nblks
-= SFS\_L0\_NBLKS; /\* ……(7)…… \*/ update\_cache(sfs, &(file-\>l1),
&(inode-\>indirect)); uint32\_t \*data = file-\>l1-\>cache; data[nblks]
= ino; /\* ……(8)…… \*/ } else if (nblks < SFS\_L2\_NBLKS) { /\* ……(9)……
\*/ nblks -= SFS\_L1\_NBLKS; /\* ……(10)…… \*/ update\_cache(sfs,
&(file-\>l2), &(inode-\>db\_indirect)); uint32\_t \*data2 =
file-\>l2-\>cache; update\_cache(sfs, &(file-\>l1), &data2;[nblks /
SFS\_BLK\_NENTRY]); uint32\_t \*data1 = file-\>l1-\>cache; data1[nblks %
SFS\_BLK\_NENTRY] = ino; /\* ……(11)…… \*/ } file-\>nblks ++;
inode-\>size += size; inode-\>blocks ++; /\* ……(12)…… \*/ } ......
============================================================= 1095.
(6分)设文件F1的当前引用计数值为1，先建立F1的符号链接（软链接）文件F2，再建立F1的硬链接文件F3，然后删除F1。此时，F2和F3的引用计数值分别是
多少？要求说明理由。 1096.
(11分)I/O子系统是操作系统中负责计算机系统与外界进行信息交互功能。键盘和显示器是计算机系统中最基本的I/O设备。
1）试描述ucore内核中是如何实现命令行状态的键盘输入时屏幕回显的；
2）试解释下面与I/O子系统中指定代码行的作用。注意：需要解释的代码共有10处。
kern-ucore/arch/i386/driver/console.c ============
kern-ucore/arch/i386/driver/console.c================= \#include
\#include \#include \#include \#include \#include \#include \#include
\#include \#include /\* stupid I/O delay routine necessitated by
historical PC design flaws \*/ static void delay(void) { inb(0x84);
inb(0x84); inb(0x84); inb(0x84); } ...... static uint16\_t \*crt\_buf;
static uint16\_t crt\_pos; static uint16\_t addr\_6845; /\* TEXT-mode
CGA/VGA display output \*/ static void cga\_init(void) { volatile
uint16\_t \*cp = (uint16\_t \*)(CGA\_BUF + KERNBASE); uint16\_t was =
\*cp; \*cp = (uint16\_t) 0xA55A; if (\*cp != 0xA55A) { cp =
(uint16\_t\*)(MONO\_BUF + KERNBASE); addr\_6845 = MONO\_BASE; } else {
cp = was; addr\_6845 = CGA\_BASE; } // Extract cursor location uint32\_t
pos; outb(addr\_6845, 14); pos = inb(addr\_6845 + 1) << 8; /\* ……(1)……
\*/ outb(addr\_6845, 15); pos |= inb(addr\_6845 + 1); /\* ……(2)…… \*/
crt\_buf = (uint16\_t\*) cp; /\* ……(3)…… \*/ crt\_pos = pos; } static
bool serial\_exists = 0; static void serial\_init(void) { ...... }
...... /\* cga\_putc - print character to console \*/ static void
cga\_putc(int c) { // set black on white if (!(c & \~0xFF)) { c |=
0x0700; } switch (c & 0xff) { case '\\b': if (crt\_pos \> 0) { crt\_pos
--; crt\_buf[crt\_pos] = (c & \~0xff) | ' '; } break; case '\\n':
crt\_pos += CRT\_COLS; case '\\r': crt\_pos -= (crt\_pos % CRT\_COLS);
break; default: crt\_buf[crt\_pos ++] = c; // write the character break;
} // What is the purpose of this? if (crt\_pos \>= CRT\_SIZE) { int i;
memmove(crt\_buf, crt\_buf + CRT\_COLS, (CRT\_SIZE - CRT\_COLS) \*
sizeof(uint16\_t)); for (i = CRT\_SIZE - CRT\_COLS; i < CRT\_SIZE; i ++)
{ crt\_buf[i] = 0x0700 | ' '; } crt\_pos -= CRT\_COLS; } // move that
little blinky thing outb(addr\_6845, 14); outb(addr\_6845 + 1, crt\_pos
\>\> 8); outb(addr\_6845, 15); outb(addr\_6845 + 1, crt\_pos); } ......
/\* \* \* Here we manage the console input buffer, where we stash
characters \* received from the keyboard or serial port whenever the
corresponding \* interrupt occurs. \* \*/ \#define CONSBUFSIZE 512
static struct { uint8\_t buf[CONSBUFSIZE]; uint32\_t rpos; uint32\_t
wpos; } cons; /\* \* \* cons\_intr - called by device interrupt routines
to feed input \* characters into the circular console input buffer. \*
\*/ static void cons\_intr(int (\*proc)(void)) { int c; while ((c =
(\*proc)()) != -1) { if (c != 0) { cons.buf[cons.wpos ++] = c; /\*
……(4)…… \*/ if (cons.wpos == CONSBUFSIZE) { cons.wpos = 0; /\* ……(5)……
\*/ } } } } /\* serial\_proc\_data - get data from serial port \*/
static int serial\_proc\_data(void) { if (!(inb(COM1 + COM\_LSR) &
COM\_LSR\_DATA)) { return -1; } int c = inb(COM1 + COM\_RX); if (c ==
127) { c = '\\b'; } return c; } /\* serial\_intr - try to feed input
characters from serial port \*/ void serial\_intr(void) { if
(serial\_exists) { cons\_intr(serial\_proc\_data); } } /\*\*\*\*\*
Keyboard input code \*\*\*\*\*/ \#define NO 0 \#define SHIFT (1<<0)
\#define CTL (1<<1) \#define ALT (1<<2) \#define CAPSLOCK (1<<3)
\#define NUMLOCK (1<<4) \#define SCROLLLOCK (1<<5) \#define E0ESC (1<<6)
static uint8\_t shiftcode[256] = { [0x1D] CTL, [0x2A] SHIFT, [0x36]
SHIFT, [0x38] ALT, [0x9D] CTL, [0xB8] ALT }; static uint8\_t
togglecode[256] = { [0x3A] CAPSLOCK, [0x45] NUMLOCK, [0x46] SCROLLLOCK
}; static uint8\_t normalmap[256] = { NO, 0x1B, '1', '2', '3', '4', '5',
'6', // 0x00 '7', '8', '9', '0', '-', '=', '\\b', '\\t', 'q', 'w', 'e',
'r', 't', 'y', 'u', 'i', // 0x10 'o', 'p', '[', ']', '\\n', NO, 'a',
's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', // 0x20 '\\'', '\`', NO,
'\\\\', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', NO, '\*', //
0x30 NO, ' ', NO, NO, NO, NO, NO, NO, NO, NO, NO, NO, NO, NO, NO, '7',
// 0x40 '8', '9', '-', '4', '5', '6', '+', '1', '2', '3', '0', '.', NO,
NO, NO, NO, // 0x50 [0xC7] KEY\_HOME, [0x9C] '\\n' /\*KP\_Enter\*/,
[0xB5] '/' /\*KP\_Div\*/, [0xC8] KEY\_UP, [0xC9] KEY\_PGUP, [0xCB]
KEY\_LF, [0xCD] KEY\_RT, [0xCF] KEY\_END, [0xD0] KEY\_DN, [0xD1]
KEY\_PGDN, [0xD2] KEY\_INS, [0xD3] KEY\_DEL }; static uint8\_t
shiftmap[256] = { NO, 033, '!', '@', '\#', '$', '%', '\^', // 0x00 '&',
'\*', '(', ')', '\_', '+', '\\b', '\\t', 'Q', 'W', 'E', 'R', 'T', 'Y',
'U', 'I', // 0x10 'O', 'P', '{', '}', '\\n', NO, 'A', 'S', 'D', 'F',
'G', 'H', 'J', 'K', 'L', ':', // 0x20 '"', '\~', NO, '|', 'Z', 'X', 'C',
'V', 'B', 'N', 'M', '<', '\>', '?', NO, '\*', // 0x30 NO, ' ', NO, NO,
NO, NO, NO, NO, NO, NO, NO, NO, NO, NO, NO, '7', // 0x40 '8', '9', '-',
'4', '5', '6', '+', '1', '2', '3', '0', '.', NO, NO, NO, NO, // 0x50
[0xC7] KEY\_HOME, [0x9C] '\\n' /\*KP\_Enter\*/, [0xB5] '/'
/\*KP\_Div\*/, [0xC8] KEY\_UP, [0xC9] KEY\_PGUP, [0xCB] KEY\_LF, [0xCD]
KEY\_RT, [0xCF] KEY\_END, [0xD0] KEY\_DN, [0xD1] KEY\_PGDN, [0xD2]
KEY\_INS, [0xD3] KEY\_DEL }; \#define C(x) (x - '@') static uint8\_t
ctlmap[256] = { NO, NO, NO, NO, NO, NO, NO, NO, NO, NO, NO, NO, NO, NO,
NO, NO, C('Q'), C('W'), C('E'), C('R'), C('T'), C('Y'), C('U'), C('I'),
C('O'), C('P'), NO, NO, '\\r', NO, C('A'), C('S'), C('D'), C('F'),
C('G'), C('H'), C('J'), C('K'), C('L'), NO, NO, NO, NO, C('\\\\'),
C('Z'), C('X'), C('C'), C('V'), C('B'), C('N'), C('M'), NO, NO, C('/'),
NO, NO, [0x97] KEY\_HOME, [0xB5] C('/'), [0xC8] KEY\_UP, [0xC9]
KEY\_PGUP, [0xCB] KEY\_LF, [0xCD] KEY\_RT, [0xCF] KEY\_END, [0xD0]
KEY\_DN, [0xD1] KEY\_PGDN, [0xD2] KEY\_INS, [0xD3] KEY\_DEL }; static
uint8\_t \*charcode[4] = { normalmap, shiftmap, ctlmap, ctlmap }; /\* \*
\* kbd\_proc\_data - get data from keyboard \* \* The kbd\_proc\_data()
function gets data from the keyboard. \* If we finish a character,
return it, else 0. And return -1 if no data. \* \*/ static int
kbd\_proc\_data(void) { int c; uint8\_t data; static uint32\_t shift; if
((inb(KBSTATP) & KBS\_DIB) == 0) { return -1; } data = inb(KBDATAP); if
(data == 0xE0) { // E0 escape character shift |= E0ESC; return 0; } else
if (data & 0x80) { // Key released data = (shift & E0ESC ? data : data &
0x7F); shift &= \~(shiftcode[data] | E0ESC); return 0; } else if (shift
& E0ESC) { // Last character was an E0 escape; or with 0x80 data |=
0x80; shift &= \~E0ESC; } shift |= shiftcode[data]; /\* ……(6)…… \*/
shift \^= togglecode[data]; c = charcode[shift & (CTL | SHIFT)][data];
if (shift & CAPSLOCK) { if ('a' <= c && c <= 'z') c += 'A' - 'a'; /\*
……(7)…… \*/ else if ('A' <= c && c <= 'Z') c += 'a' - 'A'; } // Process
special keys // Ctrl-Alt-Del: reboot if (!(\~shift & (CTL | ALT)) && c
== KEY\_DEL) { kprintf("Rebooting!\\n"); outb(0x92, 0x3); // courtesy of
Chris Frost } return c; } /\* kbd\_intr - try to feed input characters
from keyboard \*/ void kbd\_intr(void) { cons\_intr(kbd\_proc\_data);
/\* ……(8)…… \*/ } static void kbd\_init(void) { // drain the kbd buffer
kbd\_intr(); pic\_enable(IRQ\_KBD); } /\* cons\_init - initializes the
console devices \*/ void cons\_init(void) { cga\_init(); serial\_init();
kbd\_init(); if (!serial\_exists) { kprintf("serial port does not
exist!!\\n"); } } /\* cons\_putc - print a single character @c to
console devices \*/ void cons\_putc(int c) { bool intr\_flag;
local\_intr\_save(intr\_flag); { lpt\_putc(c); cga\_putc(c);
serial\_putc(c); } local\_intr\_restore(intr\_flag); } /\* \* \*
cons\_getc - return the next input character from console, \* or 0 if
none waiting. \* \*/ int cons\_getc(void) { int c = 0; bool intr\_flag;
local\_intr\_save(intr\_flag); { // poll for any pending input
characters, // so that this function works even when interrupts are
disabled // (e.g., when called from the kernel monitor). serial\_intr();
kbd\_intr(); // grab the next character from the input buffer. if
(cons.rpos != cons.wpos) { c = cons.buf[cons.rpos ++]; /\* ……(9)…… \*/
if (cons.rpos == CONSBUFSIZE) { cons.rpos = 0; /\* ……(10)…… \*/ } } }
local\_intr\_restore(intr\_flag); return c; }
============================================================= 1097.
在一个只允许单向行驶的十字路口，分别有若干由东向西，由南向北的车辆在等待通过十字路口。为了安全，每次只允许一辆车通过。当有车辆通过时其它车辆必须等候，当无车
辆在路口行驶时则允许一辆车通过。请用PV操作实现保证十字路口安全行驶的自动管理系统。
1098.
有4位哲学家围着一个圆桌在思考和进餐，每人思考时手中什么都不拿，当需要进餐时，每人需要用刀和叉各一把，餐桌上的布置如图2-12所示，共有2把刀和2把叉，每把
刀或叉供相邻的两个人使用。请用信号量及PV操作说明4位哲学家的同步过程。
1099.
桌上有一个空盘子，只允许放一个水果。爸爸可以向盘中放苹果，也可以向盘中放桔子，儿子专等吃盘中的桔子，女儿专等吃盘中的苹果。规定当盘空时，一次只能放一只水果，
请用PV操作实现爸爸、儿子、女儿3个并发进程的同步。 1100.
主存有两个空闲区F1、F2。F1为220KB，F2为120KB，另外依次有J1、J2、J3三个作业请求加载运行，它们的主存需求量分别是40KB、160KB、
100KB，试比较最先适应算法、最优适应算法和最坏适应算法的性能。 1101.
下表给出了某系统中的空闲分区表，系统采用可变式分区存储管理策略。现有以下作业序列：96KB、20KB、200KB。若用最先适应算法和最优适应算法。解答中的也
做相应修改。来处理这个作业序列，试问哪一种算法可以满足该作业序列的请求，为什么？
序号| 始址| 大小 ---|---|--- 1| 100K| 32K 2| 150K| 10K 3| 200K| 5K 4|
220K| 218K 5| 530K| 96K 1102.
在一个页式存储管理系统中，页面大小为1KB，主存中用户区的起始地址为1000，假定页表如下。现有一逻辑地址，页号为2，页内地址为20，试设计相应的物理地址，
并画图说明地址转换过程。 1103.
设一页式存储管理系统，向用户提供逻辑地址空间最大为16页，每页2048字节，主存总共有8个存储块，试问逻辑地址应为多少位？主存空间有多大？
1104.
在一个页式存储管理系统中，某作业的页表如下表所示。已知页面大小为1024字节，用户区的基址为1000，试将逻辑地址1011、2148、3000、4000、5
012转换为相应的物理地址。 页号| 块号 ---|--- 0| 2 1| 3 2| 1 3| 6 1105.
在一个请求分页存储管理的系统中，一个程序的页面走向为6,0,1,2,0,3,0,4,2,3,分别采用最佳置换算法、先进先出置换算法、最近最久未使用算法，完成
下列要求。设分配给该程序的存储块数M=3,每调进一个新页就发生一次缺页中断。
完成下表，求缺页中断次数和缺页率 时刻| 1| 2| 3| 4| 5| 6| 7| 8| 9| 10
---|---|---|---|---|---|---|---|---|---|--- 访问顺序| 6| 0| 1| 2| 0| 3|
0| 4| 2| 3 M=3| | | | | | | | | | | | | | | | | | | | | | | | | | | | f|
| | | | | | | | | 1106.
假定磁带记录密度为每英寸800字符，每一逻辑记录为160字符，块间隙为0.6英寸。今有1500个逻辑记录需要存储，试计算磁带的利用率？若要使磁带空间利用率不
少于50%，至少应以多少个逻辑记录为一组？这说明了什么问题？ 1107.
某软盘有40个磁道，磁头从一个磁道移到另一个磁道需要6ms。文件在磁盘上非连续存放，逻辑上相邻数据块的平均距离为13磁道，每块的旋转延迟时间及传输时间分别为
100ms、25ms，问读取一个100块的文件需要多少时间？如果系统对磁盘进行了整理，让同一个磁盘块尽可能靠拢，从而使逻辑上相邻的数据块的平均距离降为2磁道
，这时读取一个100块的文件需要多少时间？ 1108.
若磁头的当前位置为100磁道，磁头正向磁道号增加的方向移动。现有一磁盘读写请求队列：23、376、205、132、19、61、190、398、29、4、18
、40。若采用先来先服务、最短寻道时间优先和扫描（电梯调度）算法，试计算平均寻道长度各为多少？
1109.
磁盘请求以10、22、20、2、40、6、38柱面的次序到达磁盘驱动器。寻道时每个柱面移动需要6ms，计算以下寻道次序和寻道时间。
（1）先来先服务 （2）电梯调度算法（起始向磁道号大的方向移动）
在所有情况下磁头臂起始都位于柱面20号上。 1110.
有一磁盘组共有10个盘面，每个盘面上有100个磁道，每个磁道有16个扇区。假定分配以扇区为单位，若使用位示图管理磁盘空间，问位示图需要占用多少空间？若空闲文
件目录的每条记录占用5个字节，问什么时候空闲文件目录大于位示图？ 1111.
假定磁盘块的大小为1KB，对于540MB的硬盘，其文件分配表FAT需要占用多少存储空间？当硬盘容量为1.2GB时，FAT需要占用多少空间？
1112. 在一个单道批处理系统中，一组作业的提交时间和运行时间作业 提交时间
运行时间 J1 8：00 1.0 J2 8：50 0.50 J3 9：00 0.20 J4 9：10 0.10
试计算以下三种作业调度算法的平均周转时间和平均带权周转时间（1）先来先服务
（2）短作业优先 （3）响应比高者优先 1113.
1）操作系统的微内核结构特征是什么？2）它有什么优点和缺点？3）在微内核结构中，内存管理、进程通信、文件系统、I/O管理这几种操作系统功能中，哪些是放在内核
中的？哪些是放在用户态的？ 1114.
1）试描述进程执行中利用堆栈实现函数调用和返回的过程。2）请补全下面print\_stackframe()函数所缺的代码，以利用函数调用时保存在堆栈中的信息输
出嵌套调用的函数入口地址和参数信息。
=============kern-ucore/arch/i386/debug/kdebug.c============= /\* \* \*
print\_debuginfo - read and print the stat information for the address
@eip, \* and info.eip\_fn\_addr should be the first address of the
related function. \* \*/ void print\_debuginfo(uintptr\_t eip) { …… }
static uint32\_t read\_eip(void) \_\_attribute\_\_((noinline)); static
uint32\_t read\_eip(void) { …… } /\* \* \* print\_stackframe - print a
list of the saved eip values from the nested 'call' \* instructions that
led to the current point of execution \* \* The x86 stack pointer,
namely esp, points to the lowest location on the stack \* that is
currently in use. Everything below that location in stack is free.
Pushing \* a value onto the stack will invole decreasing the stack
pointer and then writing \* the value to the place that stack pointer
pointes to. And popping a value do the \* opposite. \* \* The ebp (base
pointer) register, in contrast, is associated with the stack \*
primarily by software convention. On entry to a C function, the
function's \* prologue code normally saves the previous function's base
pointer by pushing \* it onto the stack, and then copies the current esp
value into ebp for the duration \* of the function. If all the functions
in a program obey this convention, \* then at any given point during the
program's execution, it is possible to trace \* back through the stack
by following the chain of saved ebp pointers and determining \* exactly
what nested sequence of function calls caused this particular point in
the \* program to be reached. This capability can be particularly
useful, for example, \* when a particular function causes an assert
failure or panic because bad arguments \* were passed to it, but you
aren't sure who passed the bad arguments. A stack \* backtrace lets you
find the offending function. \* \* The inline function read\_ebp() can
tell us the value of current ebp. And the \* non-inline function
read\_eip() is useful, it can read the value of current eip, \* since
while calling this function, read\_eip() can read the caller's eip from
\* stack easily. \* \* In print\_debuginfo(), the function
debuginfo\_eip() can get enough information about \* calling-chain.
Finally print\_stackframe() will trace and print them for debugging. \*
\* Note that, the length of ebp-chain is limited. In boot/bootasm.S,
before jumping \* to the kernel entry, the value of ebp has been set to
zero, that's the boundary. \* \*/ void print\_stackframe(void) {
uint32\_t ebp = read\_ebp(), eip = read\_eip(); int i, j; for (i = 0;
ebp != 0 && i < 10; i ++) { kprintf("ebp:0x%08x eip:0x%08x args:", ebp,
eip); uint32\_t \*args = (uint32\_t \*) \_--YOUR CODE 1--\_; for (j = 0;
j < 4; j ++) { kprintf("0x%08x ", args[j]); } kprintf("\\n");
print\_debuginfo(eip - 1); eip = ((uint32\_t \*) \_--YOUR CODE 2--\_;
ebp = ((uint32\_t \*) \_--YOUR CODE 3--\_; } } 1115.
1）系统调用接口是操作系统内核向用户进程提供操作系统服务的接口。试描述用户进程通过系统调用使用操作系统服务的过程。2）gettime\_msec是一个获取当前
系统时间的系统调用。请补全该系统调用的实现代码。
=============libs-user-ucore/ulib.c============= unsigned int
gettime\_msec(void) { return (unsigned int)sys\_gettime(); }
=============libs-user-ucore/syscall.c============= size\_t
sys\_gettime(void) { return (size\_t) \_--YOUR CODE 4--\_; }
=============libs-user-ucore/arch/i386/syscall.c============= \#define
MAX\_ARGS 5 uint32\_t syscall(int num, ...) { va\_list ap; va\_start(ap,
num); uint32\_t a[MAX\_ARGS]; int i; for (i = 0; i < MAX\_ARGS; i ++) {
a[i] = va\_arg(ap, uint32\_t); } va\_end(ap); uint32\_t ret; asm
volatile ( "int %1;" : "=a" (ret) : "i" (T\_SYSCALL), "a" (num), "d"
(a[0]), "c" (a[1]), "b" (a[2]), "D" (a[3]), "S" (a[4]) : "cc",
"memory"); return ret; }
=============libs-user-ucore/common/unistd.h============= /\* syscall
number \*/ \#define SYS\_exit 1 \#define SYS\_fork 2 \#define SYS\_wait
3 \#define SYS\_exec 4 \#define SYS\_clone 5 \#define SYS\_exit\_thread
9 \#define SYS\_yield 10 \#define SYS\_sleep 11 \#define SYS\_kill 12
\#define SYS\_gettime 17 \#define SYS\_getpid 18 \#define SYS\_brk 19 ……
=============kern-ucore/arch/i386/glue-ucore/trap.c============= static
void trap\_dispatch(struct trapframe \*tf) { char c; int ret; switch
(tf-\>tf\_trapno) { case T\_DEBUG: case T\_BRKPT: debug\_monitor(tf);
break; case T\_PGFLT: if ((ret = pgfault\_handler(tf)) != 0) {
print\_trapframe(tf); if (pls\_read(current) == NULL) { panic("handle
pgfault failed. %e\\n", ret); } else { if (trap\_in\_kernel(tf)) {
panic("handle pgfault failed in kernel mode. %e\\n", ret); }
kprintf("killed by kernel.\\n"); do\_exit(-E\_KILLED); } } break; case
T\_SYSCALL: \_--YOUR CODE 5--\_; break; case IRQ\_OFFSET + IRQ\_TIMER:
ticks ++; assert(pls\_read(current) != NULL); run\_timer\_list(); break;
case IRQ\_OFFSET + IRQ\_COM1: case IRQ\_OFFSET + IRQ\_KBD: if ((c =
cons\_getc()) == 13) { debug\_monitor(tf); } else { extern void
dev\_stdin\_write(char c); dev\_stdin\_write(c); } break; case
IRQ\_OFFSET + IRQ\_IDE1: case IRQ\_OFFSET + IRQ\_IDE2: /\* do nothing
\*/ break; default: print\_trapframe(tf); if (pls\_read(current) !=
NULL) { kprintf("unhandled trap.\\n"); do\_exit(-E\_KILLED); }
panic("unexpected trap in kernel.\\n"); } } void trap(struct trapframe
\*tf) { // used for previous projects if (pls\_read(current) == NULL) {
trap\_dispatch(tf); } else { // keep a trapframe chain in stack struct
trapframe \*otf = pls\_read(current)-\>tf; pls\_read(current)-\>tf = tf;
bool in\_kernel = trap\_in\_kernel(tf); \_--YOUR CODE 6--\_;
pls\_read(current)-\>tf = otf; if (!in\_kernel) { may\_killed(); if
(pls\_read(current)-\>need\_resched) { schedule(); } } } }
=============kern-ucore/arch/i386/syscall/syscall.c============= ……
static uint32\_t sys\_gettime(uint32\_t arg[]) { return (int)ticks; } ……
static uint32\_t (\*syscalls[])(uint32\_t arg[]) = { [SYS\_exit]
sys\_exit, [SYS\_fork] sys\_fork, [SYS\_wait] sys\_wait, [SYS\_exec]
sys\_exec, [SYS\_clone] sys\_clone, [SYS\_exit\_thread]
sys\_exit\_thread, [SYS\_yield] sys\_yield, [SYS\_kill] sys\_kill,
[SYS\_sleep] sys\_sleep, [SYS\_gettime] \_--YOUR CODE 7--\_,
[SYS\_getpid] sys\_getpid, …… }; \#define NUM\_SYSCALLS
((sizeof(syscalls)) / (sizeof(syscalls[0]))) void syscall(void) { struct
trapframe \*tf = pls\_read(current)-\>tf; uint32\_t arg[5]; int num =
tf-\>tf\_regs.reg\_eax; if (num \>= 0 && num < NUM\_SYSCALLS) { if
(syscalls[num] != NULL) { arg[0] = tf-\>tf\_regs.reg\_edx; arg[1] =
tf-\>tf\_regs.reg\_ecx; arg[2] = tf-\>tf\_regs.reg\_ebx; arg[3] =
tf-\>tf\_regs.reg\_edi; arg[4] = tf-\>tf\_regs.reg\_esi;
tf-\>tf\_regs.reg\_eax = \_--YOUR CODE 8--\_; return ; } }
print\_trapframe(tf); panic("undefined syscall %d, pid = %d, name =
%s.\\n", num, pls\_read(current)-\>pid, pls\_read(current)-\>name); }
1116. 1）试利用图示描述伙伴系统（Buddy
System）中对物理内存的分配和回收过程。2）请补全下面伙伴系统实现中所缺的代码。
=============kern-ucore/arch/i386/mm/buddy\_pmm.c============= // {1, 2,
4, 8, 16, 32, 64, 128, 256, 512, 1024} // from 2\^0 \~ 2\^10 \#define
MAX\_ORDER 10 static free\_area\_t free\_area[MAX\_ORDER + 1]; //x from
0 \~ MAX\_ORDER \#define free\_list(x) (free\_area[x].free\_list)
\#define nr\_free(x) (free\_area[x].nr\_free) \#define MAX\_ZONE\_NUM 10
struct Zone { struct Page \*mem\_base; } zones[MAX\_ZONE\_NUM] =
{{NULL}}; //buddy\_init - init the free\_list(0 \~ MAX\_ORDER) & reset
nr\_free(0 \~ MAX\_ORDER) static void buddy\_init(void) { int i; for (i
= 0; i <= MAX\_ORDER; i ++) { list\_init(&free;\_list(i)); nr\_free(i) =
0; } } //buddy\_init\_memmap - build free\_list for Page base follow n
continuing pages. static void buddy\_init\_memmap(struct Page \*base,
size\_t n) { …… } //getorder - return order, the minmal 2\^order \>= n
static inline size\_t getorder(size\_t n) { size\_t order, order\_size;
for (order = 0, order\_size = 1; order <= MAX\_ORDER; order ++,
order\_size <<= 1) { if (n <= order\_size) { return order; } }
panic("getorder failed. %d\\n", n); } //buddy\_alloc\_pages\_sub - the
actual allocation implimentation, return a page whose size \>=n, // -
the remaining free parts insert to other free list static inline struct
Page \* buddy\_alloc\_pages\_sub(size\_t order) { assert(order <=
MAX\_ORDER); size\_t cur\_order; for (cur\_order = order; cur\_order <=
MAX\_ORDER; cur\_order ++) { if (!list\_empty(&free;\_list(cur\_order)))
{ list\_entry\_t \*le = list\_next(&free;\_list(cur\_order)); struct
Page \*page = le2page(le, page\_link); nr\_free(cur\_order) --; \_--YOUR
CODE 9--\_(le); size\_t size = 1 << cur\_order; while (cur\_order \>
order) { cur\_order --; size \>\>= 1; struct Page \*buddy = page + size;
buddy-\>property = cur\_order; SetPageProperty(buddy);
nr\_free(cur\_order) ++; \_--YOUR CODE 10--\_(&free;\_list(cur\_order),
&(buddy-\>page\_link)); } ClearPageProperty(page); return page; } }
return NULL; } //buddy\_alloc\_pages - call buddy\_alloc\_pages\_sub to
alloc 2\^order\>=n pages static struct Page \*
buddy\_alloc\_pages(size\_t n) { assert(n \> 0); size\_t order =
getorder(n), order\_size = (1 << order); struct Page \*page =
buddy\_alloc\_pages\_sub(order); if (page != NULL && n != order\_size) {
free\_pages(page + n, order\_size - n); } return page; }
//page\_is\_buddy - Does this page belong to the No. zone\_num Zone &
this page // - be in the continuing page block whose size is 2\^order
pages? static inline bool page\_is\_buddy(struct Page \*page, size\_t
order, int zone\_num) { if (page2ppn(page) < npage) { if
(page-\>zone\_num == zone\_num) { return !PageReserved(page) &&
PageProperty(page) && page-\>property == order; } } return 0; }
//page2idx - get the related index number idx of continuing page block
which this page belongs to static inline ppn\_t page2idx(struct Page
\*page) { return page - zones[page-\>zone\_num].mem\_base; } //idx2page
- get the related page according to the index number idx of continuing
page block static inline struct Page \* idx2page(int zone\_num, ppn\_t
idx) { return zones[zone\_num].mem\_base + idx; }
//buddy\_free\_pages\_sub - the actual free implimentation, should
consider how to // - merge the adjacent buddy block static void
buddy\_free\_pages\_sub(struct Page \*base, size\_t order) { ppn\_t
buddy\_idx, page\_idx = page2idx(base); assert((page\_idx & ((1 <<
order) - 1)) == 0); struct Page \*p = base; for (; p != base + (1 <<
order); p ++) { assert(!PageReserved(p) && !PageProperty(p)); p-\>flags
= 0; set\_page\_ref(p, 0); } int zone\_num = base-\>zone\_num; while
(order < MAX\_ORDER) { buddy\_idx = page\_idx \^ (1 << order); struct
Page \*buddy = idx2page(zone\_num, buddy\_idx); if
(!page\_is\_buddy(buddy, order, zone\_num)) { break; } nr\_free(order)
--; \_--YOUR CODE 11--\_(&(buddy-\>page\_link));
ClearPageProperty(buddy); page\_idx &= buddy\_idx; order ++; } struct
Page \*page = idx2page(zone\_num, page\_idx); page-\>property = order;
SetPageProperty(page); nr\_free(order) ++; \_--YOUR CODE
12--\_(&free;\_list(order), &(page-\>page\_link)); }
//buddy\_free\_pages - call buddy\_free\_pages\_sub to free n continuing
page block static void buddy\_free\_pages(struct Page \*base, size\_t n)
{ assert(n \> 0); if (n == 1) { buddy\_free\_pages\_sub(base, 0); } else
{ size\_t order = 0, order\_size = 1; while (n \>= order\_size) {
assert(order <= MAX\_ORDER); if ((page2idx(base) & order\_size) != 0) {
buddy\_free\_pages\_sub(base, order); base += order\_size; n -=
order\_size; } order ++; order\_size <<= 1; } while (n != 0) { while (n
< order\_size) { order --; order\_size \>\>= 1; }
buddy\_free\_pages\_sub(base, order); base += order\_size; n -=
order\_size; } } } //buddy\_nr\_free\_pages - get the nr: the number of
free pages static size\_t buddy\_nr\_free\_pages(void) { size\_t ret =
0, order = 0; for (; order <= MAX\_ORDER; order ++) { ret +=
nr\_free(order) \* (1 << order); } return ret; } //buddy\_check - check
the correctness of buddy system static void buddy\_check(void) { …… }
//the buddy system pmm const struct pmm\_manager buddy\_pmm\_manager = {
.name = "buddy\_pmm\_manager", .init = buddy\_init, .init\_memmap =
buddy\_init\_memmap, .alloc\_pages = buddy\_alloc\_pages, .free\_pages =
buddy\_free\_pages, .nr\_free\_pages = buddy\_nr\_free\_pages, .check =
buddy\_check, }; 1117.
1）试用图示描述32位X86系统在采用4KB页面大小时的页表结构。2）在采用4KB页面大小的32位X86的ucore虚拟存储系统中，进程页面的起始地址由宏V
PT确定。 \#define VPT 0xFAC00000
请计算：2a)页目录（PDE）在虚拟地址空间中的起始地址；2b)虚拟地址0X87654321对应的页目录项和页表项的虚拟地址。
1118.
1）试描述ucore的进程创建系统调用fork（）的基本过程。2）请补全fork系统调用的实现代码。
=============kern-ucore/process/proc.c============= // get\_pid - alloc
a unique pid for process static int get\_pid(void) { …… } …… int
do\_fork(uint32\_t clone\_flags, uintptr\_t stack, struct trapframe
\*tf) { int ret = -E\_NO\_FREE\_PROC; struct proc\_struct \*proc; if
(nr\_process \>= MAX\_PROCESS) { goto fork\_out; } ret = -E\_NO\_MEM; if
((proc = alloc\_proc()) == NULL) { goto fork\_out; } proc-\>parent =
\_--YOUR CODE 13--\_; list\_init(&(proc-\>thread\_group));
assert(current-\>wait\_state == 0); assert(current-\>time\_slice \>= 0);
proc-\>time\_slice = current-\>time\_slice / 2; current-\>time\_slice -=
proc-\>time\_slice; if (setup\_kstack(proc) != 0) { goto
bad\_fork\_cleanup\_proc; } if (copy\_sem(clone\_flags, proc) != 0) {
goto bad\_fork\_cleanup\_kstack; } if (copy\_fs(clone\_flags, proc) !=
0) { goto bad\_fork\_cleanup\_sem; } if (copy\_mm(clone\_flags, proc) !=
0) { goto bad\_fork\_cleanup\_fs; } if (copy\_thread(clone\_flags, proc,
stack, tf) != 0) { goto bad\_fork\_cleanup\_sem; } bool intr\_flag;
local\_intr\_save(intr\_flag); { proc-\>pid = \_--YOUR CODE 14--\_;
hash\_proc(proc); set\_links(proc); if (clone\_flags & CLONE\_THREAD) {
list\_add\_before(&(current-\>thread\_group), &(proc-\>thread\_group));
} } local\_intr\_restore(intr\_flag); wakeup\_proc(proc); ret = \_--YOUR
CODE 15--\_; fork\_out: return ret; bad\_fork\_cleanup\_fs:
put\_fs(proc); bad\_fork\_cleanup\_sem: put\_sem\_queue(proc);
bad\_fork\_cleanup\_kstack: put\_kstack(proc); bad\_fork\_cleanup\_proc:
kfree(proc); goto fork\_out; }
=============kern-ucore/arch/i386/process/proc.c============= // forkret
-- the first kernel entry point of a new thread/process // NOTE: the
addr of forkret is setted in copy\_thread function // after switch\_to,
the current proc will execute here. static void forkret(void) {
forkrets(pls\_read(current)-\>tf); } …… // copy\_thread - setup the
trapframe on the process's kernel stack top and // - setup the kernel
entry point and stack of process int copy\_thread(uint32\_t
clone\_flags, struct proc\_struct \*proc, uintptr\_t esp, struct
trapframe \*tf) { proc-\>tf = (struct trapframe \*)(proc-\>kstack +
KSTACKSIZE) - 1; \*(proc-\>tf) = \*tf; proc-\>tf-\>tf\_regs.reg\_eax =
0; proc-\>tf-\>tf\_esp = esp; proc-\>tf-\>tf\_eflags |= FL\_IF;
proc-\>context.eip = (uintptr\_t) \_--YOUR CODE 16--\_;
proc-\>context.esp = (uintptr\_t)(proc-\>tf); return 0; } 1119.
试用图示描述五状态进程模型，要求给出状态描述和各状态间的变迁。 1120.
在管道通信机制中,用信号量描述读进程和写进程访问管道文件的过程,假设管
道文件大小为10KB. 1121.
桌上有一空盘,允许存放一只水果。爸爸可向盘中放苹果,也可向盘中放桔子,儿
子专等吃盘中的桔子,女儿专等吃盘中的苹果。规定当盘空时一次只能放一只水果供
吃者取用,请用P、V原语实现爸爸、儿子、女儿三个并发进程的同步 1122.
在南开大学至天津大学间有一条弯曲的路,每次只允许一辆自行车通过,但中间
有小的安全岛M(同时允许两辆车),可供两辆车在已进入两端小车错车,设计算法并使用P,V实现。
1123. 3.说明五状态进程模型的状态定义和转换 一、(16分)
请说明五状态进程模型中的状态和状态含义，并说明哪些状态会发生转换以及转换的原因。
1124. 4.时钟置换算法 一、(10分)
（1）试描述虚拟存储管理系统中的时钟置换算法（Clock Page
Replacement）的工作原理；
（2）假定在一个采用时钟置换算法的虚拟存储系统中某进程分配了4个物理页面，当进程按c,
a, d, b, e, c, b, a, d, b, c, a,
d的序列进行页面访问时，会出现多少次缺页？要求说明过程。如果需要，你可以补充假定条件。
1125. \*5.地址变换和页表地址
一、(20分)（1）请使用图示来简要描述采用多级页面的虚拟存储系统中的地址变换过程。
（2）假定在一个32位计算机系统中，采用多级页表结构来实现虚拟存储管理，页面大小为4KB，每级页表大小为一个页面的大小，每个页表项占8字节。请问该计算机系统
中要使用几级页表？各级各占多少位？对于虚拟地址0X87654321对应的各级页表号分别是多少？
1126. 1127. 7 内存计算题 一、 (12分)
请求分页管理系统中，假定页表内容下表所示： 页号 | 页框（Page Frame）号 |
有效位（存在位） ---|---|--- 0 | 101H | 1 1 | N/A | 0 2 | 254H | 1
页面大小为4KB，一次内存的访问时间是100ns，一次快表（TLB）的访问时间是10ns，处理一次缺页的平均时间是10\^8ns（已包含更新TLB和页表的时间
），进程的驻留集大小固定为2，采用最近最少使用置换算法（LRU）和局部淘汰策略。假设：TLB初始为空；地址转换时先访问TLB，若TLB未命中，再访问页表（忽
略访问页表之后的TLB更新时间）；有效位为0表示页面不在内存，会产生缺页中断，缺页中断处理后，返回到产生缺页中断的指令处重新执行。设有虚地址访问序列2362
H、1565H、25A5H，请问：
（1）依次访问上述三个虚地址，各需多少时间？给出计算过程。
（2）基于上述访问序列，虚地址1565H的物理地址是多少？请说明理由 1128. 1129.
fork例子 第二题： 一、 （10分）给出程序fork.c的输出结果。
注：1）getpid()和getppid()是两个系统调用，分别返回本进程标识和父进程标识。
2）你可以假定每次新进程创建时生成的进程标识是顺序加1得到的；在进程标识为1000的命令解释程序shell中启动该程序的执行
nclude \#include /\* getpid() and fork() are system calls declared in
unistd.h. They return \*/ /\* values of type pid\_t. This pid\_t is a
special type for process ids. \*/ /\* It's equivalent to int. \*/ int
main(void) { pid\_t childpid; int x = 5; int i; childpid = fork(); for (
i = 0; i < 2; i++) { printf(This is process %d; childpid = %d; The
parent of this process has id %d; i = %d; x = %d\\n" getpid() 1130.
1131. 1132. 资源分配图： 第五题： 一、 （10分）银行家算法(Banker's
Algorithm)是一种在资源分配过程中避免出现死锁的算法，资源管理者可以有进程申请资源时，使用银行家算法来判断分配相应资源后是否可能出现死锁。试回答下列问题。
1）形成死锁的条件是什么？ 2）试用伪代码描述银行家算法。
3）假设系统中有A、B、C和D这四类资源，有P1、P2和P3这三个进程正在使用这些资源。
下面某次资源申请后的资源占用情况。请问这个状态是否安全？如果是安全的，请给出一个可能的资源分配和回收序列。
当前的可用资源情况： A B C D 3 1 1 2 当前各进程的已分配资源情况： A B C D
P1 1 0 3 3 P2 1 2 2 1 P3 1 2 1 0 各进程声称的最大资源申请情况： A B C D
P1 1 2 3 4 P2 3 3 2 2 P3 1 3 5 0 1133.
文件系统：链表方式文件组织方式是什么？访问指定文件偏移位置数据所对应的文件块位置。
第六题： 一、
（10分）基本的文件组织方式有哪几种？请用图示方式描述UNIX文件系统UFS的文件组织方式。
1134.
在一个盒子里,混装了数量相等的黑白围棋子·现在用自动分拣系统把黑子、白
子分开,设分拣系统有二个进程P1 和P2 ,其中P1 拣白子;P2
拣黑子。规定每个进程
每次拣一子;当一个进程在拣时,不允许另一个进程去拣;当一个进程拣了一子时,必
须让另一个进程去拣.试写出两进程P1 和P2 能并发正确执行的程序。 1135.
设公共汽车上,司机和售票员的活动分别如下:司机的活动:启动车辆:正常行
车;到站停车。售票员的活动:关车门;售票;开车门。在汽车不断地到站、停车、行驶过程中,这两个活动有什么同步关系?用信号量和P
、V 操作实现它们的同步 1136.
某寺庙,有小和尚、老和尚若干.庙内有一水缸,由小和尚提水入缸,供老和尚
饮用。水缸可容纳10桶水,每次入水、取水仅为1桶,不可同时进行。水取自同一井中,
水井径窄,每次只能容纳一个水桶取水。设水桶个数为3个,试用信号灯和PV操作给出
老和尚和小和尚的活动。 1137.
一座小桥(最多只能承重两个人)横跨南北两岸,任意时刻同一方向只允许一人过
桥,南侧桥段和北侧桥段较窄只能通过一人,桥中央一处宽敞,允许两个人通过或歇
息。试用信号灯和PV操作写出南、北两岸过桥的同步算法。 1138.
在一个盒子里,混装了数量相等的黑白围棋子·现在用自动分拣系统把黑子、白
子分开,设分拣系统有二个进程P1 和P2 ,其中P1 拣白子;P2
拣黑子。规定每个进程
每次拣一子;当一个进程在拣时,不允许另一个进程去拣;当一个进程拣了一子时,必
须让另一个进程去拣.试写出两进程P1 和P2 能并发正确执行的程序。 1139.
设公共汽车上,司机和售票员的活动分别如下:司机的活动:启动车辆:正常行
车;到站停车。售票员的活动:关车门;售票;开车门。在汽车不断地到站、停车、行驶过程中,这两个活动有什么同步关系?用信号量和P
、V 操作实现它们的同步 1140.
某寺庙,有小和尚、老和尚若干.庙内有一水缸,由小和尚提水入缸,供老和尚
饮用。水缸可容纳10桶水,每次入水、取水仅为1桶,不可同时进行。水取自同一井中,
水井径窄,每次只能容纳一个水桶取水。设水桶个数为3个,试用信号灯和PV操作给出
老和尚和小和尚的活动。 1141.
一座小桥(最多只能承重两个人)横跨南北两岸,任意时刻同一方向只允许一人过
桥,南侧桥段和北侧桥段较窄只能通过一人,桥中央一处宽敞,允许两个人通过或歇
息。试用信号灯和PV操作写出南、北两岸过桥的同步算法。 1142. 1143.
下面是ucore中用于按需分页处理过程的内核代码。请补全其中所缺的代码，以正确完成按需分页过程.
kern/trap/trap.h --------------------------------- ... struct trapframe
{ struct pushregs tf\_regs; uint16\_t tf\_es; uint16\_t tf\_padding1;
uint16\_t tf\_ds; uint16\_t tf\_padding2; uint32\_t tf\_trapno; /\*
below here defined by x86 hardware \*/ uint32\_t tf\_err; uintptr\_t
tf\_eip; uint16\_t tf\_cs; uint16\_t tf\_padding3; uint32\_t tf\_eflags;
// below here only when crossing rings, such as from user to kernel
uintptr\_t tf\_esp; uint16\_t tf\_ss; uint16\_t tf\_padding4; }
\_\_attribute\_\_((packed)); ... ---------------------------------
kern/trap/trap.c --------------------------------- ... static int
pgfault\_handler(struct trapframe \*tf) { extern struct mm\_struct
\*check\_mm\_struct; } print\_pgfault(tf); if (check\_mm\_struct !=
NULL) { return do\_pgfault(check\_mm\_struct, tf-\>tf\_err, rcr2()); }
panic("unhandled page fault.\\n"); } static void trap\_dispatch(struct
trapframe \*tf) { char c; int ret; switch ( --YOUR CODE 1-- ) { .YOUR..
case T\_PGFLT: if ( --YOUR CODE 2-- ) != 0) { print\_trapframe(trapf);
if (current == NULL) { panic("handle pgfault failed. %e\\n", ret); }
else { ... } } break; ... } void trap(struct trapframe \*tf) { //
dispatch based on what type of trap occurred trap\_dispatch(tf); } ...
// do\_pgfault - interrupt handler to process the page fault execption
int do\_pgfault(struct mm\_struct \*mm, uint32\_t error\_code,
uintptr\_t addr) { int ret = -E\_INVAL; struct vma\_struct \*vma =
find\_vma(mm, addr); if (vma == NULL || vma-\>vm\_start \> addr) { goto
failed; } switch (error\_code & 3) { default: /\* default is 3: write,
present \*/ case 2: /\* write, not present \*/ if (!(vma-\>vm\_flags &
VM\_WRITE)) { goto failed; } break; case 1: /\* read, present \*/ goto
failed; case 0: /\* read, not present \*/ if (!(vma-\>vm\_flags &
(VM\_READ | VM\_EXEC))) { goto failed; } } uint32\_t perm = PTE\_U; if
(vma-\>vm\_flags & VM\_WRITE) { perm |= PTE\_W; } addr = ROUNDDOWN(addr,
PGSIZE); ret = -E\_NO\_MEM; if (pgdir\_alloc\_page(mm-\>pgdir, addr,
perm) == 0) { goto failed; } ret = 0; failed: return ret; } ...
--------------------------------- Pmm.h
--------------------------------- ... //ppn is physical page number
static inline ppn\_t page2ppn(struct Page \*page) { return --YOUR CODE
3--; } //pa is physical address static inline uintptr\_t page2pa(struct
Page \*page) { return --YOUR CODE 4--; } ...
--------------------------------- pmm.c
--------------------------------- ... // virtual address of physicall
page array struct Page \*pages; // amount of physical memory (in pages)
size\_t npage = 0; // virtual address of boot-time page directory pde\_t
\*boot\_pgdir = NULL; …… // pgdir\_alloc\_page - call alloc\_page &
page\_insert functions to // - allocate a page size memory & setup an
addr map // - pa<-\>la with linear address la and the PDT pgdir struct
Page \* pgdir\_alloc\_page(pde\_t \*pgdir, uintptr\_t la, uint32\_t
perm) { struct Page \*page = alloc\_page(); if (page != NULL) { if
(page\_insert(pgdir, page, la, perm) != 0) { free\_page(page); return
NULL; } } return page; } ... //page\_insert - build the map of phy addr
of an Page with the linear addr la // paramemters: // pgdir: the kernel
virtual base address of PDT // page: the Page which need to map // la:
the linear address need to map // perm: the permission of this Page
which is setted in related pte // return value: always 0 //note: PT is
changed, so the TLB need to be invalidate int page\_insert(pde\_t
\*pgdir, struct Page \*page, uintptr\_t la, uint32\_t perm) { pte\_t
\*ptep = get\_pte(pgdir, la, 1); if (ptep == NULL) { return -E\_NO\_MEM;
} page\_ref\_inc(page); if (\*ptep & PTE\_P) { struct Page \*p =
pte2page(\*ptep); if (p == page) { page\_ref\_dec(page); } else {
page\_remove\_pte(pgdir, la, ptep); } } \*ptep = --YOUR CODE 5--
tlb\_invalidate(pgdir, la); return 0; }
--------------------------------- 1144.
在管道通信机制中,用信号量描述读进程和写进程访问管道文件的过程,假设管
道文件大小为10KB. 1145.
桌上有一空盘,允许存放一只水果。爸爸可向盘中放苹果,也可向盘中放桔子,儿
子专等吃盘中的桔子,女儿专等吃盘中的苹果。规定当盘空时一次只能放一只水果供
吃者取用,请用P、V原语实现爸爸、儿子、女儿三个并发进程的同步 1146.
在南开大学至天津大学间有一条弯曲的路,每次只允许一辆自行车通过,但中间
有小的安全岛M(同时允许两辆车),可供两辆车在已进入两端小车错车,设计算法并使用P,V实现。
1147.
在一个盒子里,混装了数量相等的黑白围棋子·现在用自动分拣系统把黑子、白
子分开,设分拣系统有二个进程P1 和P2 ,其中P1 拣白子;P2
拣黑子。规定每个进程
每次拣一子;当一个进程在拣时,不允许另一个进程去拣;当一个进程拣了一子时,必
须让另一个进程去拣.试写出两进程P1 和P2 能并发正确执行的程序。 1148.
设公共汽车上,司机和售票员的活动分别如下:司机的活动:启动车辆:正常行
车;到站停车。售票员的活动:关车门;售票;开车门。在汽车不断地到站、停车、行驶过程中,这两个活动有什么同步关系?用信号量和P
、V 操作实现它们的同步 1149.
某寺庙,有小和尚、老和尚若干.庙内有一水缸,由小和尚提水入缸,供老和尚
饮用。水缸可容纳10桶水,每次入水、取水仅为1桶,不可同时进行。水取自同一井中,
水井径窄,每次只能容纳一个水桶取水。设水桶个数为3个,试用信号灯和PV操作给出
老和尚和小和尚的活动。 1150.
一座小桥(最多只能承重两个人)横跨南北两岸,任意时刻同一方向只允许一人过
桥,南侧桥段和北侧桥段较窄只能通过一人,桥中央一处宽敞,允许两个人通过或歇
息。试用信号灯和PV操作写出南、北两岸过桥的同步算法。 1151.
下面是ucore中用于按需分页处理过程的内核代码。请补全其中所缺的代码，以正确完成按需分页过程.
kern/trap/trap.h --------------------------------- ... struct trapframe
{ struct pushregs tf\_regs; uint16\_t tf\_es; uint16\_t tf\_padding1;
uint16\_t tf\_ds; uint16\_t tf\_padding2; uint32\_t tf\_trapno; /\*
below here defined by x86 hardware \*/ uint32\_t tf\_err; uintptr\_t
tf\_eip; uint16\_t tf\_cs; uint16\_t tf\_padding3; uint32\_t tf\_eflags;
// below here only when crossing rings, such as from user to kernel
uintptr\_t tf\_esp; uint16\_t tf\_ss; uint16\_t tf\_padding4; }
\_\_attribute\_\_((packed)); ... ---------------------------------
kern/trap/trap.c --------------------------------- ... static int
pgfault\_handler(struct trapframe \*tf) { extern struct mm\_struct
\*check\_mm\_struct; } print\_pgfault(tf); if (check\_mm\_struct !=
NULL) { return do\_pgfault(check\_mm\_struct, tf-\>tf\_err, rcr2()); }
panic("unhandled page fault.\\n"); } static void trap\_dispatch(struct
trapframe \*tf) { char c; int ret; switch ( --YOUR CODE 1-- ) { .YOUR..
case T\_PGFLT: if ( --YOUR CODE 2-- ) != 0) { print\_trapframe(trapf);
if (current == NULL) { panic("handle pgfault failed. %e\\n", ret); }
else { ... } } break; ... } void trap(struct trapframe \*tf) { //
dispatch based on what type of trap occurred trap\_dispatch(tf); } ...
// do\_pgfault - interrupt handler to process the page fault execption
int do\_pgfault(struct mm\_struct \*mm, uint32\_t error\_code,
uintptr\_t addr) { int ret = -E\_INVAL; struct vma\_struct \*vma =
find\_vma(mm, addr); if (vma == NULL || vma-\>vm\_start \> addr) { goto
failed; } switch (error\_code & 3) { default: /\* default is 3: write,
present \*/ case 2: /\* write, not present \*/ if (!(vma-\>vm\_flags &
VM\_WRITE)) { goto failed; } break; case 1: /\* read, present \*/ goto
failed; case 0: /\* read, not present \*/ if (!(vma-\>vm\_flags &
(VM\_READ | VM\_EXEC))) { goto failed; } } uint32\_t perm = PTE\_U; if
(vma-\>vm\_flags & VM\_WRITE) { perm |= PTE\_W; } addr = ROUNDDOWN(addr,
PGSIZE); ret = -E\_NO\_MEM; if (pgdir\_alloc\_page(mm-\>pgdir, addr,
perm) == 0) { goto failed; } ret = 0; failed: return ret; } ...
--------------------------------- Pmm.h
--------------------------------- ... //ppn is physical page number
static inline ppn\_t page2ppn(struct Page \*page) { return --YOUR CODE
3--; } //pa is physical address static inline uintptr\_t page2pa(struct
Page \*page) { return --YOUR CODE 4--; } ...
--------------------------------- pmm.c
--------------------------------- ... // virtual address of physicall
page array struct Page \*pages; // amount of physical memory (in pages)
size\_t npage = 0; // virtual address of boot-time page directory pde\_t
\*boot\_pgdir = NULL; …… // pgdir\_alloc\_page - call alloc\_page &
page\_insert functions to // - allocate a page size memory & setup an
addr map // - pa<-\>la with linear address la and the PDT pgdir struct
Page \* pgdir\_alloc\_page(pde\_t \*pgdir, uintptr\_t la, uint32\_t
perm) { struct Page \*page = alloc\_page(); if (page != NULL) { if
(page\_insert(pgdir, page, la, perm) != 0) { free\_page(page); return
NULL; } } return page; } ... //page\_insert - build the map of phy addr
of an Page with the linear addr la // paramemters: // pgdir: the kernel
virtual base address of PDT // page: the Page which need to map // la:
the linear address need to map // perm: the permission of this Page
which is setted in related pte // return value: always 0 //note: PT is
changed, so the TLB need to be invalidate int page\_insert(pde\_t
\*pgdir, struct Page \*page, uintptr\_t la, uint32\_t perm) { pte\_t
\*ptep = get\_pte(pgdir, la, 1); if (ptep == NULL) { return -E\_NO\_MEM;
} page\_ref\_inc(page); if (\*ptep & PTE\_P) { struct Page \*p =
pte2page(\*ptep); if (p == page) { page\_ref\_dec(page); } else {
page\_remove\_pte(pgdir, la, ptep); } } \*ptep = --YOUR CODE 5--
tlb\_invalidate(pgdir, la); return 0; }
--------------------------------- 1152.
3.说明五状态进程模型的状态定义和转换 一、(16分)
请说明五状态进程模型中的状态和状态含义，并说明哪些状态会发生转换以及转换的原因。
1153. 4.时钟置换算法 一、(10分)
（1）试描述虚拟存储管理系统中的时钟置换算法（Clock Page
Replacement）的工作原理；
（2）假定在一个采用时钟置换算法的虚拟存储系统中某进程分配了4个物理页面，当进程按c,
a, d, b, e, c, b, a, d, b, c, a,
d的序列进行页面访问时，会出现多少次缺页？要求说明过程。如果需要，你可以补充假定条件。
1154. \*5.地址变换和页表地址
一、(20分)（1）请使用图示来简要描述采用多级页面的虚拟存储系统中的地址变换过程。
（2）假定在一个32位计算机系统中，采用多级页表结构来实现虚拟存储管理，页面大小为4KB，每级页表大小为一个页面的大小，每个页表项占8字节。请问该计算机系统
中要使用几级页表？各级各占多少位？对于虚拟地址0X87654321对应的各级页表号分别是多少？
1155. 6.fork程序输出 一、
(10分)给出程序fork.c的输出结果。注：（c1）getpid()和getppid()是两个系统调用，分别返回本进程标识和父
进程标识。（2）你可以假定每次新进程创建时生成的进程标识是顺序加1得到的，该程序执行时创建的第一个进程的标识为1000。
, fork.c ---------------------- /\* Includes \*/ \#include /\* Symbolic
Constants \*/ \#include /\* Primitive System Data Types \*/ \#include
/\* Errors \*/ \#include /\* Input/Output \*/ \#include /\* Wait for
Process Termination \*/ \#include /\* General Utilities \*/ int main() {
pid\_t childpid; /\* variable to store the child's pid \*/ int retval;
/\* child process: user-provided return code \*/ int status; /\* parent
process: child's exit status \*/ /\* only 1 int variable is needed
because each process would have its own instance of the variable here, 2
int variables are used for clarity \*/ /\* now create new process \*/
childpid = fork(); if (childpid \>= 0) /\* fork succeeded \*/ { if
(childpid == 0) /\* fork() returns 0 to the child process \*/ {
printf("CHILD: I am the child process!\\n"); printf("CHILD: Here's my
PID: %d\\n", getpid()); printf("CHILD: My parent's PID is: %d\\n",
getppid()); printf("CHILD: The value of my copy of childpid is: %d\\n",
childpid); printf("CHILD: Sleeping for 1 second...\\n"); sleep(1); /\*
sleep for 1 second \*/ printf("CHILD: Enter an exit value (0 to 255):
"); scanf(" %d", &retval;); printf("CHILD: Goodbye!\\n"); exit(retval);
/\* child exits with user-provided return code \*/ } else /\* fork()
returns new pid to the parent process \*/ { printf("PARENT: I am the
parent process!\\n"); printf("PARENT: Here's my PID: %d\\n", getpid());
printf("PARENT: The value of my copy of childpid is %d\\n", childpid);
printf("PARENT: I will now wait for my child to exit.\\n");
wait(&status;); /\* wait for child to exit, and store its status \*/
printf("PARENT: Child's exit code is: %d\\n", WEXITSTATUS(status));
printf("PARENT: Goodbye!\\n"); exit(0); /\* parent exits \*/ } } else
/\* fork returns -1 on failure \*/ { perror("fork"); /\* display error
message \*/ exit(0); } } 1156. 7 内存计算题 一、 (12分)
请求分页管理系统中，假定页表内容下表所示： 页号 | 页框（Page Frame）号 |
有效位（存在位） ---|---|--- 0 | 101H | 1 1 | N/A | 0 2 | 254H | 1
页面大小为4KB，一次内存的访问时间是100ns，一次快表（TLB）的访问时间是10ns，处理一次缺页的平均时间是10\^8ns（已包含更新TLB和页表的时间
），进程的驻留集大小固定为2，采用最近最少使用置换算法（LRU）和局部淘汰策略。假设：TLB初始为空；地址转换时先访问TLB，若TLB未命中，再访问页表（忽
略访问页表之后的TLB更新时间）；有效位为0表示页面不在内存，会产生缺页中断，缺页中断处理后，返回到产生缺页中断的指令处重新执行。设有虚地址访问序列2362
H、1565H、25A5H，请问：
（1）依次访问上述三个虚地址，各需多少时间？给出计算过程。
（2）基于上述访问序列，虚地址1565H的物理地址是多少？请说明理由 1157.
系统调用访问过程 第一题：
一、（2362H2分）下面是与read()系统调用实现相关源代码。请补全其中所缺的代码，以正确完成从用户态函数read()到内核态函数sysfil
e\_read()的参数传递和返回过程。提示：每处需要补全的代码只需要一行，一共有10个空要填。
user/libs/file.c --------------------------------- ... int read(int fd,
void \*base, size\_t len) { ...(1)... } ...
--------------------------------- user/libs/syscall.c
--------------------------------- ... \#define MAX\_ARGS static inline
int syscall(int num, ...) { int ret; va\_list ap; va\_start(ap, num);
uint32\_t a[MAX\_ARGS]; int i; for (i = 0; i < MAX\_ARGS; i ++) { a[i] =
va\_arg(ap, uint32\_t); } va\_end(ap); asm volatile ( "int %1;" : "=a"
(ret) : "i" (T\_SYSCALL), "a" (num), "d" (a[0]), "c" (a[1]), "b" (a[2]),
"D" (a[3]), "S" (a[4]) : "cc", "memory"); return ret; } ... int
sys\_read(int fd, void \*base, size\_t len) { ...(2)... } ...
--------------------------------- libs/stdarg.h
--------------------------------- ... typedef char \* va\_list; \#define
\_\_va\_size(type) \\ ((sizeof(type) + (sizeof(long) - 1)) /
sizeof(long) \* sizeof(long)) \#define va\_start(ap, last) \\ ((ap) =
(va\_list)&(last) + \_\_va\_size(last)) \#define va\_arg(ap, type) \\
(\*(type \*)((ap) += \_\_va\_size(type), (ap) - \_\_va\_size(type)))
\#define va\_end(ap) ((void)0) ... ---------------------------------
libs/unistd.h --------------------------------- ... \#define T\_SYSCALL
0x80 /\* syscall number \*/ ... \#define SYS\_read 102 \#define
SYS\_write 103 ... ---------------------------------
kern/syscall/syscall.c --------------------------------- ... struct
trapframe { struct pushregs tf\_regs; uint16\_t tf\_es; uint16\_t
tf\_padding1; uint16\_t tf\_ds; uint16\_t tf\_padding2; uint32\_t
tf\_trapno; /\* below here defined by x86 hardware \*/ uint32\_t
tf\_err; uintptr\_t tf\_eip; uint16\_t tf\_cs; uint16\_t tf\_padding3;
uint32\_t tf\_eflags; /\* below here only when crossing rings, such as
from user to kernel \*/ uintptr\_t tf\_esp; uint16\_t tf\_ss; uint16\_t
tf\_padding4; }; ... --------------------------------- kern/trap/trap.c
--------------------------------- ... static void trap\_dispatch(struct
trapframe \*tf) { char c; int ret; switch (...(3)...) { case T\_DEBUG:
case T\_BRKPT: debug\_monitor(tf); break; case T\_PGFLT: if ((ret =
pgfault\_handler(tf)) != 0) { print\_trapframe(tf); if (current == NULL)
{ panic("handle pgfault failed. %e\\n", ret); } else { if
(trap\_in\_kernel(tf)) { panic("handle pgfault failed in kernel mode.
%e\\n", ret); } cprintf("killed by kernel.\\n"); do\_exit(-E\_KILLED); }
} break; case T\_SYSCALL: ...(4)... break; case IRQ\_OFFSET +
IRQ\_TIMER: ticks ++; assert(current != NULL); run\_timer\_list();
break; case IRQ\_OFFSET + IRQ\_COM1: case IRQ\_OFFSET + IRQ\_KBD: if ((c
= cons\_getc()) == 13) { debug\_monitor(tf); } else { extern void
dev\_stdin\_write(char c); dev\_stdin\_write(c); } break; case
IRQ\_OFFSET + IRQ\_IDE1: case IRQ\_OFFSET + IRQ\_IDE2: /\* do nothing
\*/ break; default: print\_trapframe(tf); if (current != NULL) {
cprintf("unhandled trap.\\n"); do\_exit(-E\_KILLED); } panic("unexpected
trap in kernel.\\n"); } } void trap(struct trapframe \*tf) { // used for
previous projects if (current == NULL) { trap\_dispatch(tf); } else { //
keep a trapframe chain in stack struct trapframe \*otf = current-\>tf;
current-\>tf = tf; bool in\_kernel = trap\_in\_kernel(tf); ...(5)...
current-\>tf = otf; if (!in\_kernel) { if (current-\>flags &
PF\_EXITING) { do\_exit(-E\_KILLED); } if (current-\>need\_resched) {
schedule(); } } } } ... ---------------------------------
kern/syscall/syscall.c --------------------------------- ... static int
sys\_read(uint32\_t arg[]) { int fd = (int)arg[0]; size\_t len =
(size\_t)...(6)...; void \*base = (void \*)...(7)...; ...(8a)... } ...
static int (\*syscalls[])(uint32\_t arg[]) = { ... [SYS\_read]
sys\_read, [SYS\_write] sys\_write, ... [SYS\_mkfifo] sys\_mkfifo, };
\#define NUM\_SYSCALLS ((sizeof(syscalls)) / (sizeof(syscalls[0]))) void
syscall(void) { struct trapframe \*tf = current-\>tf; uint32\_t arg[5];
int num = tf-\>...(8b)...; if (num \>= 0 && num < NUM\_SYSCALLS) { if
(syscalls[num] != NULL) { arg[0] = tf-\>tf\_regs.reg\_edx; arg[1] =
tf-\>tf\_regs.reg\_ecx; arg[2] = tf-\>tf\_regs.reg\_ebx; arg[3] =
tf-\>tf\_regs.reg\_edi; arg[4] = tf-\>tf\_regs.reg\_esi;
tf-\>tf\_regs.reg\_eax = ...(9)...; return ; } } print\_trapframe(tf);
panic("undefined syscall %d, pid = %d, name = %s.\\n", num,
current-\>pid, current-\>name); } ... ---------------------------------
kern/fs/sysfile.c --------------------------------- ... int
sysfile\_read(int fd, void \*base, size\_t len) { struct mm\_struct \*mm
= current-\>mm; if (len == 0) { return 0; } if (!file\_testfd(fd, 1, 0))
{ return -E\_INVAL; } void \*buffer; if ((buffer = kmalloc(IOBUF\_SIZE))
== NULL) { return -E\_NO\_MEM; } int ret = 0; size\_t copied = 0, alen;
while (len != 0) { if ((alen = IOBUF\_SIZE) \> len) { alen = len; } ret
= ...(10)...; if (alen != 0) { lock\_mm(mm); { if (copy\_to\_user(mm,
base, buffer, alen)) { assert(len \>= alen); base += alen, len -= alen,
copied += alen; } else if (ret == 0) { ret = -E\_INVAL; } }
unlock\_mm(mm); } if (ret != 0 || alen == 0) { goto out; } } out:
kfree(buffer); if (copied != 0) { return copied; } return ret; } ...
--------------------------------- kern/fs/file.c
--------------------------------- ... int file\_read(int fd, void
\*base, size\_t len, size\_t \*copied\_store) { int ret; struct file
\*file; \*copied\_store = 0; if ((ret = fd2file(fd, &file;)) != 0) {
return ret; } if (!file-\>readable) { return -E\_INVAL; }
filemap\_acquire(file); struct iobuf \_\_iob, \*iob =
iobuf\_init(&\_\_iob, base, len, file-\>pos); ret =
vop\_read(file-\>node, iob); size\_t copied = iobuf\_used(iob); if
(file-\>status == FD\_OPENED) { file-\>pos += copied; } \*copied\_store
= copied; filemap\_release(file); return ret; } ...
--------------------------------- 1158. fork例子 第二题： 一、
（10分）给出程序fork.c的输出结果。
注：1）getpid()和getppid()是两个系统调用，分别返回本进程标识和父进程标识。
2）你可以假定每次新进程创建时生成的进程标识是顺序加1得到的；在进程标识为1000的命令解释程序shell中启动该程序的执行
nclude \#include /\* getpid() and fork() are system calls declared in
unistd.h. They return \*/ /\* values of type pid\_t. This pid\_t is a
special type for process ids. \*/ /\* It's equivalent to int. \*/ int
main(void) { pid\_t childpid; int x = 5; int i; childpid = fork(); for (
i = 0; i < 2; i++) { printf(This is process %d; childpid = %d; The
parent of this process has id %d; i = %d; x = %d\\n" getpid() 1159.
调度算法： 第三题： 一、
(18分)调度器是操作系统内核中依据调度算法进行进程切换选择的模块。1）试描述时间片轮转算法（Round
Robin）的基本原理。2）下面代码是ucore中调度器和时间片轮转算法的实现代码。请补全其中所缺代码，以实现调度器和调度算法的功能。提示：每处需要补全的代码只需要一行，一共有7个空要填。
sched.h ----------------------------------------------- … struct
proc\_struct; typedef struct { unsigned int expires; struct proc\_struct
\*proc; list\_entry\_t timer\_link; } timer\_t; \#define le2timer(le,
member) \\ to\_struct((le), timer\_t, member) static inline timer\_t \*
timer\_init(timer\_t \*timer, struct proc\_struct \*proc, int expires) {
timer-\>expires = expires; timer-\>proc = proc;
list\_init(&(timer-\>timer\_link)); return timer; } struct run\_queue;
struct sched\_class { const char \*name; void (\*init)(struct run\_queue
\*rq); void (\*enqueue)(struct run\_queue \*rq, struct proc\_struct
\*proc); void (\*dequeue)(struct run\_queue \*rq, struct proc\_struct
\*proc); struct proc\_struct \*(\*pick\_next)(struct run\_queue \*rq);
void (\*proc\_tick)(struct run\_queue \*rq, struct proc\_struct \*proc);
}; struct run\_queue { list\_entry\_t run\_list; unsigned int proc\_num;
int max\_time\_slice; list\_entry\_t rq\_link; }; \#define le2rq(le,
member) \\ to\_struct((le), struct run\_queue, member) void
sched\_init(void); void wakeup\_proc(struct proc\_struct \*proc); void
schedule(void); void add\_timer(timer\_t \*timer); void
del\_timer(timer\_t \*timer); void run\_timer\_list(void); extern struct
proc\_struct \*idleproc, \*initproc, \*current; extern struct
proc\_struct \*kswapd; … -----------------------------------------------
sched.c ----------------------------------------------- … static
list\_entry\_t timer\_list; static struct sched\_class \*sched\_class;
static struct run\_queue \*rq; static inline void
sched\_class\_enqueue(struct proc\_struct \*proc) { if (proc !=
idleproc) { sched\_class-\>enqueue(rq, proc); } } static inline void
sched\_class\_dequeue(struct proc\_struct \*proc) {
sched\_class-\>dequeue(rq, proc); } static inline struct proc\_struct \*
sched\_class\_pick\_next(void) { return sched\_class-\>pick\_next(rq); }
static void sched\_class\_proc\_tick(struct proc\_struct \*proc) { if
(proc != idleproc) { sched\_class-\>proc\_tick(rq, proc); } else {
proc-\>need\_resched = 1; } } static struct run\_queue \_\_rq[4]; void
sched\_init(void) { list\_init(&timer;\_list); rq = \_\_rq;
list\_init(&(rq-\>rq\_link)); rq-\>max\_time\_slice = 8; int i; for (i =
1; i < sizeof(\_\_rq) / sizeof(\_\_rq[0]); i ++) {
list\_add\_before(&(rq-\>rq\_link), &(\_\_rq[i].rq\_link));
\_\_rq[i].max\_time\_slice = rq-\>max\_time\_slice \* (1 << i); }
sched\_class = &MLFQ;\_sched\_class; sched\_class-\>init(rq);
cprintf("sched class: %s\\n", sched\_class-\>name); } void
wakeup\_proc(struct proc\_struct \*proc) { assert(proc-\>state !=
PROC\_ZOMBIE); bool intr\_flag; local\_intr\_save(intr\_flag); { if
(proc-\>state != PROC\_RUNNABLE) { proc-\>state = PROC\_RUNNABLE;
proc-\>wait\_state = 0; sched\_class\_enqueue(proc); } else {
warn("wakeup runnable process.\\n"); } }
local\_intr\_restore(intr\_flag); } void schedule(void) { bool
intr\_flag; struct proc\_struct \*next; local\_intr\_save(intr\_flag); {
current-\>need\_resched = 0; if (current-\>state == PROC\_RUNNABLE) {
...(1)... } if ((next = sched\_class\_pick\_next()) != NULL) { ...(2)...
} } local\_intr\_restore(intr\_flag); if (next == NULL) { next =
...(3)...; } next-\>runs ++; if (next != current) { ...(4)... } } …
----------------------------------------------- sched\_RR.c
----------------------------------------------- … static void
RR\_init(struct run\_queue \*rq) { list\_init(&(rq-\>run\_list));
rq-\>proc\_num = 0; } static void RR\_enqueue(struct run\_queue \*rq,
struct proc\_struct \*proc) { assert(list\_empty(&(proc-\>run\_link)));
list\_add\_before(&(rq-\>run\_list), &(proc-\>run\_link)); if
(proc-\>time\_slice == 0 || proc-\>time\_slice \> rq-\>max\_time\_slice)
{ ...(5)... } proc-\>rq = rq; rq-\>proc\_num ++; } static void
RR\_dequeue(struct run\_queue \*rq, struct proc\_struct \*proc) {
assert(!list\_empty(&(proc-\>run\_link)) && proc-\>rq == rq);
list\_del\_init(&(proc-\>run\_link)); rq-\>proc\_num --; } static struct
proc\_struct \* RR\_pick\_next(struct run\_queue \*rq) { list\_entry\_t
\*le = list\_next(&(rq-\>run\_list)); if (le != &(rq-\>run\_list)) {
return le2proc(le, run\_link); } return NULL; } static void
RR\_proc\_tick(struct run\_queue \*rq, struct proc\_struct \*proc) { if
(proc-\>time\_slice \> 0) { ...(6)... } if (proc-\>time\_slice == 0) {
...(7)... } } struct sched\_class RR\_sched\_class = { .name =
"RR\_scheduler", .init = RR\_init, .enqueue = RR\_enqueue, .dequeue =
RR\_dequeue, .pick\_next = RR\_pick\_next, .proc\_tick = RR\_proc\_tick,
}; ----------------------------------------------- proc.c
----------------------------------------------- … // proc\_run - make
process "proc" running on cpu // NOTE: before call switch\_to, should
load base addr of "proc"'s new PDT void proc\_run(struct proc\_struct
\*proc) { if (proc != current) { bool intr\_flag; struct proc\_struct
\*prev = current, \*next = proc; local\_intr\_save(intr\_flag); {
current = proc; load\_esp0(next-\>kstack + KSTACKSIZE);
lcr3(next-\>cr3); switch\_to(&(prev-\>context), &(next-\>context)); }
local\_intr\_restore(intr\_flag); } } …
----------------------------------------------- 1160.
管程：实现代码填空、读者优先的应用代码完成； 第四题： 一、
（22分）管程是操作系统提供的一种进程同步机制，利用管程可解决进程间通信时遇到的同步互斥问题。读者-写者问题（Reader-writer
problem）是一个经典的同步问题。写者优先的读者-写者问题是指，假定有多个并发的读进程和写进程都要访问一个共享的数据结构，要求：(1)读写互斥；(2)写
写互斥；(3)允许多个读进程同时访问；(4)只要有写进程提出申请，其后提出申请的读进程就必须等待该写进程完成访问
。下面是ucore中管程机制和写者优先的读者-写者问题的实现代码。请尝试补全其中所缺的代码，以正确实现管程机制和读者-
写者间的读写操作协调。提示：文件“cdt\_wf.c”中的补全代码可能需要在一处加多行代码，其他需要补全的代码只需要一行，一共有11个空要填。
condition.h ----------------------------------------------- … typedef
struct { int numWaiting; int valid; wait\_queue\_t wait\_queue; }
condition\_t; \#define cdtid2cdt(cdt\_id) \\ ((condition\_t
\*)((uintptr\_t)(cdt\_id) + KERNBASE)) \#define cdt2cdtid(cdt) \\
((cdt\_t)((uintptr\_t)(cdt) - KERNBASE)) void
condition\_value\_init(condition\_t \*cdt) { ...(1)... cdt-\>valid=1;
wait\_queue\_init(&(cdt-\>wait\_queue)); } int condition\_init(){
condition\_t \*cdt; if ((cdt = kmalloc(sizeof(condition\_t))) != NULL) {
condition\_value\_init( cdt ); } if (cdt != NULL) { return
cdt2cdtid(cdt); } return -E\_INVAL; } int condition\_free(cdt\_t
cdt\_id) { condition\_t \*cdt = cdtid2cdt(cdt\_id); int ret = -E\_INVAL;
if (cdt != NULL) { bool intr\_flag; local\_intr\_save(intr\_flag); {
cdt-\>valid = 0, ret = 0; wakeup\_queue(&(cdt-\>wait\_queue),
WT\_INTERRUPTED, 1); kfree(cdt); } local\_intr\_restore(intr\_flag); }
return ret; } int condition\_wait(cdt\_t cdt\_id, klock\_t kl\_id){
condition\_t \*cdt = cdtid2cdt(cdt\_id); bool intr\_flag;
local\_intr\_save(intr\_flag); ...(2)... wait\_t \_\_wait, \*wait =
&\_\_wait; ...(3)... local\_intr\_restore(intr\_flag);
sys\_unlock(kl\_id); schedule(); sys\_lock(kl\_id);
//local\_intr\_save(intr\_flag);
//wait\_current\_del(&(cdt-\>wait\_queue), wait);
//local\_intr\_restore(intr\_flag); if (wait-\>wakeup\_flags !=
WT\_UCONDITION) { return wait-\>wakeup\_flags; } return 0; } int
condition\_signal(cdt\_t cdt\_id){ condition\_t \*cdt =
cdtid2cdt(cdt\_id); if (cdt == NULL) { return -E\_INVAL; } bool
intr\_flag; local\_intr\_save(intr\_flag); if (cdt-\>numWaiting \> 0) {
wait\_t \*wait; if ((wait = wait\_queue\_first(&(cdt-\>wait\_queue))) !=
NULL) { assert(wait-\>proc-\>wait\_state == WT\_UCONDITION); ...(4)... }
...(5)... } local\_intr\_restore(intr\_flag); return 0; } …
----------------------------------------------- ulib.c
----------------------------------------------- … cdt\_t cdt\_init(){
return sys\_cdt\_init(); } int cdt\_signal(cdt\_t cdt\_id){ return
sys\_cdt\_signal(cdt\_id); } int cdt\_wait(cdt\_t cdt\_id ,klock\_t
klock\_id){ return sys\_cdt\_wait(cdt\_id ,klock\_id); } int
cdt\_free(cdt\_t cdt\_id){ return sys\_cdt\_free(cdt\_id); } klock\_t
klock\_init(){ return sys\_klock\_init(); } int klock\_aquire(klock\_t
klock\_id){ return sys\_klock\_aquire(klock\_id); } int
klock\_release(klock\_t klock\_id){ return
sys\_klock\_release(klock\_id); } int klock\_free(klock\_t klock\_id){
return sys\_klock\_free(klock\_id); } …
----------------------------------------------- cdt\_wf.c
----------------------------------------------- … int \*active\_reader ;
// \# count of active readers int \*active\_writer ; // \# count of
active writers int \*waiting\_reader ; // \# count of waiting readers
int \*waiting\_writer ; // \# count of waiting writers cdt\_t
cdt\_okToRead; cdt\_t cdt\_okToWrite; klock\_t lock; void failed(void) {
cprintf("FAIL: T.T\\n"); exit(-1); } void init(void) { if
((cdt\_okToRead = cdt\_init()) < 0 || (cdt\_okToWrite = cdt\_init()) <
0) { failed(); } if ((lock = klock\_init()) < 0) { failed(); } if
((active\_reader = shmem\_malloc(sizeof(int))) == NULL ||
(active\_writer = shmem\_malloc(sizeof(int))) == NULL ||
(waiting\_reader = shmem\_malloc(sizeof(int))) == NULL ||
(waiting\_writer = shmem\_malloc(sizeof(int))) == NULL) { failed(); }
\*active\_reader = \*active\_writer = \*waiting\_reader =
\*waiting\_writer = 0; } void check\_init\_value(void) { if
(cdt\_okToRead < 0 || cdt\_okToWrite < 0 ) { failed(); } if (lock < 0 )
{ failed(); } if (\*active\_reader != 0 || \*active\_writer != 0 ||
\*waiting\_reader != 0 || \*waiting\_writer != 0) { failed(); } } void
free\_wf(void){ if ( cdt\_free(cdt\_okToRead) < 0 ||
cdt\_free(cdt\_okToWrite) < 0 ){ scprintf(" conditon free failed! \\n");
exit(-1); } if ( klock\_free(lock) < 0 ){ scprintf(" kernal lock free
failed! \\n"); exit(-1); } } void start\_read(void) {
klock\_aquire(lock); ...(6)... klock\_release(lock); } void
done\_read(void) { klock\_aquire(lock); ...(7)... klock\_release(lock);
} void start\_write(void) { klock\_aquire(lock); ...(8)...
klock\_release(lock); } void done\_write(void) { klock\_aquire(lock);
...(9)... if ((\*waiting\_writer) \> 0) { ...(10)... } else if
((\*waiting\_reader) \> 0) { int wakecount=0; while(...(11)...){
cdt\_signal(cdt\_okToRead); wakecount++; } } klock\_release(lock); }
void writer(int id, int time) { scprintf("writer %d: (pid:%d) arrive
\\n", id, getpid()); start\_write(); scprintf(" writer\_wf %d: (pid:%d)
start %d\\n", id, getpid(), time); sleep(time); scprintf(" writer\_wf
%d: (pid:%d) end %d\\n", id, getpid(), time); done\_write(); } void
reader(int id, int time) { scprintf("reader %d: (pid:%d) arrive\\n", id,
getpid()); start\_read(); scprintf(" reader\_wf %d: (pid:%d) start
%d\\n", id, getpid(), time); sleep(time); scprintf(" reader\_wf %d:
(pid:%d) end %d\\n", id, getpid(), time); done\_read(); } void
read\_test\_wf(void) { … } void write\_test\_wf(void) { … } void
read\_write\_test\_wf(void) { … } int main(void) { init();
read\_test\_wf(); write\_test\_wf(); read\_write\_test\_wf();
free\_wf(); cprintf("condition reader\_writer\_wf\_test pass..\\n");
return 0; } ----------------------------------------------- wait.c
----------------------------------------------- … void
wait\_init(wait\_t \*wait, struct proc\_struct \*proc) { wait-\>proc =
proc; wait-\>wakeup\_flags = WT\_INTERRUPTED;
list\_init(&(wait-\>wait\_link)); } void
wait\_queue\_init(wait\_queue\_t \*queue) {
list\_init(&(queue-\>wait\_head)); } void
wait\_queue\_add(wait\_queue\_t \*queue, wait\_t \*wait) {
assert(list\_empty(&(wait-\>wait\_link)) && wait-\>proc != NULL);
wait-\>wait\_queue = queue; list\_add\_before(&(queue-\>wait\_head),
&(wait-\>wait\_link)); } void wait\_queue\_del(wait\_queue\_t \*queue,
wait\_t \*wait) { assert(!list\_empty(&(wait-\>wait\_link)) &&
wait-\>wait\_queue == queue); list\_del\_init(&(wait-\>wait\_link)); }
wait\_t \* wait\_queue\_next(wait\_queue\_t \*queue, wait\_t \*wait) {
assert(!list\_empty(&(wait-\>wait\_link)) && wait-\>wait\_queue ==
queue); list\_entry\_t \*le = list\_next(&(wait-\>wait\_link)); if (le
!= &(queue-\>wait\_head)) { return le2wait(le, wait\_link); } return
NULL; } wait\_t \* wait\_queue\_prev(wait\_queue\_t \*queue, wait\_t
\*wait) { assert(!list\_empty(&(wait-\>wait\_link)) &&
wait-\>wait\_queue == queue); list\_entry\_t \*le =
list\_prev(&(wait-\>wait\_link)); if (le != &(queue-\>wait\_head)) {
return le2wait(le, wait\_link); } return NULL; } wait\_t \*
wait\_queue\_first(wait\_queue\_t \*queue) { list\_entry\_t \*le =
list\_next(&(queue-\>wait\_head)); if (le != &(queue-\>wait\_head)) {
return le2wait(le, wait\_link); } return NULL; } wait\_t \*
wait\_queue\_last(wait\_queue\_t \*queue) { list\_entry\_t \*le =
list\_prev(&(queue-\>wait\_head)); if (le != &(queue-\>wait\_head)) {
return le2wait(le, wait\_link); } return NULL; } bool
wait\_queue\_empty(wait\_queue\_t \*queue) { return
list\_empty(&(queue-\>wait\_head)); } bool wait\_in\_queue(wait\_t
\*wait) { return !list\_empty(&(wait-\>wait\_link)); } void
wakeup\_wait(wait\_queue\_t \*queue, wait\_t \*wait, uint32\_t
wakeup\_flags, bool del) { if (del) { wait\_queue\_del(queue, wait); }
wait-\>wakeup\_flags = wakeup\_flags; wakeup\_proc(wait-\>proc); } void
wakeup\_first(wait\_queue\_t \*queue, uint32\_t wakeup\_flags, bool del)
{ wait\_t \*wait; if ((wait = wait\_queue\_first(queue)) != NULL) {
wakeup\_wait(queue, wait, wakeup\_flags, del); } } void
wakeup\_queue(wait\_queue\_t \*queue, uint32\_t wakeup\_flags, bool del)
{ wait\_t \*wait; if ((wait = wait\_queue\_first(queue)) != NULL) { if
(del) { do { wakeup\_wait(queue, wait, wakeup\_flags, 1); } while ((wait
= wait\_queue\_first(queue)) != NULL); } else { do { wakeup\_wait(queue,
wait, wakeup\_flags, 0); } while ((wait = wait\_queue\_next(queue,
wait)) != NULL); } } } void wait\_current\_set(wait\_queue\_t \*queue,
wait\_t \*wait, uint32\_t wait\_state) { assert(current != NULL);
wait\_init(wait, current); current-\>state = PROC\_SLEEPING;
current-\>wait\_state = wait\_state; wait\_queue\_add(queue, wait); }
----------------------------------------------- proc.h
----------------------------------------------- … //the wait state
\#define WT\_CHILD (0x00000001 | WT\_INTERRUPTED) // wait child process
\#define WT\_TIMER (0x00000002 | WT\_INTERRUPTED) // wait timer \#define
WT\_KSWAPD 0x00000003 // wait kswapd to free page \#define WT\_KSEM
0x00000100 // wait kernel semaphore \#define WT\_USEM (0x00000101 |
WT\_INTERRUPTED) // wait user semaphore \#define WT\_EVENT\_SEND
(0x00000110 | WT\_INTERRUPTED) // wait the sending event \#define
WT\_EVENT\_RECV (0x00000111 | WT\_INTERRUPTED) // wait the recving event
\#define WT\_MBOX\_SEND (0x00000120 | WT\_INTERRUPTED) // wait the
sending mbox \#define WT\_MBOX\_RECV (0x00000121 | WT\_INTERRUPTED) //
wait the recving mbox \#define WT\_UCONDITION (0x00000130 |
WT\_INTERRUPTED) // wait user condition --liuruilin \#define
WT\_INTERRUPTED 0x80000000 // the wait state could be interrupted …
----------------------------------------------- 1161. 资源分配图：
第五题： 一、 （10分）银行家算法(Banker's
Algorithm)是一种在资源分配过程中避免出现死锁的算法，资源管理者可以有进程申请资源时，使用银
行家算法来判断分配相应资源后是否可能出现死锁。试回答下列问题。
1）形成死锁的条件是什么？ 2）试用伪代码描述银行家算法。
3）假设系统中有A、B、C和D这四类资源，有P1、P2和P3这三个进程正在使用这些资源。
下面某次资源申请后的资源占用情况。请问这个状态是否安全？如果是安全的，请给出一个可能的资源分配和回收序列。
当前的可用资源情况： A B C D 3 1 1 2 当前各进程的已分配资源情况： A B C D
P1 1 0 3 3 P2 1 2 2 1 P3 1 2 1 0 各进程声称的最大资源申请情况： A B C D
P1 1 2 3 4 P2 3 3 2 2 P3 1 3 5 0 1162.
文件系统：链表方式文件组织方式是什么？访问指定文件偏移位置数据所对应的文件块位置。
第六题： 一、
（10分）基本的文件组织方式有哪几种？请用图示方式描述UNIX文件系统UFS的文件组织方式。
